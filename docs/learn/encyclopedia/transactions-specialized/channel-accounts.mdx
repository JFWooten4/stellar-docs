---
title: Channel Accounts
sidebar_position: 10
---

import { CodeExample } from "@site/src/components/CodeExample";

Channel accounts are a design pattern for submitting transactions to the network in bursts. Channel accounts are not what might come to mind in terms of layer-2 channels. Rather, they are a set specialized accounts that act as proxies to submit transactions quickly.

:::caution

Submitting transactions quickly [often requires](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0006.md) hot signing keys. It is best practice to extensively test your systems on [the testnet](../../fundamentals/networks.mdx#testnet) before deploying in high-speed production. Moreover, you may consider using hardware security modules or [multisignature wallets](../security/signatures-multisig.mdx#thresholds) to secure your accounts.

:::

## Background Motivation

Channel accounts take advantage of the fact that the [source account](../../glossary.mdx#source-account) of a [transaction](../../../data/horizon/api-reference/resources/transactions/README.mdx) ($S_T$) can be different than the source account of the [operations](../../../data/horizon/api-reference/resources/operations/README.mdx) inside a transaction ($S_O$).

![Seperate Sources](/assets/channel-accounts/layering.png)

:::info Packet Propogation

Stellar validators are spread across the globe, making it challenging to garauntee immediate order of arrival from one source. Only by sequencing [a validator](../../../validators/README.mdx) can you control physical delays for your transactions, as signals vary in [network lag](https://stellarbeat.io/nodes/GARYGQ5F2IJEBCZJCBNPWNWVDOFK7IBOHLJKKSG2TMHDQKEEC6P4PE4V?center=1#:~:text=Externalize,lag) to reach [other nodes](../../../data/horizon/admin-guide/ingestion.mdx). Accordingly, channel accounts are the only way to guarantee layer-1 settlement for many consecutive transactions.

:::

This guide walks through an example using channel accounts to send 500 payment operations in close ledgers. It uses a primary account ($A_P$) to hold Lumens and five channel accounts for submitting transactions ($A_{C_{1\text{--}5}}$).

![Asset Allocation](/assets/channel-accounts/custody.png)

:::note Block Size

You can create as many channel accounts as needed to maintain your desired transaction rate. However, one ledger [can only fit](https://stellar.expert/explorer/public/protocol-history) 1,000 operations from all peers. To keep [fees](../../fundamentals/fees-resource-limits-metering.mdx#inclusion-fee) within reason and minimize congestion, it is best practice to limit yourself to 300 operations per ledger. For higher throughput in non-emergency applications, consider using other scaling solutions like [Starlight](../../glossary.mdx#starlight).

:::

### Sequence Numbers

The network rejects transactions with [sequence numbers](../../glossary.mdx#sequence-number) that are not strictly increasing. Previously, if you sent even just two transactions in the same ledger, there was a [reasonable chance](https://stellar.stackexchange.com/questions/1675/channel-concept-in-stellar) they would arrive out of sequence. Accordingly, to prevent failures, the network [now restricts](https://stellar.org/blog/developers/proposed-changes-to-transaction-submission#:~:text=1,ledger) each source account to submit no more than one transaction per ledger.

<CodeExample>
```python
from stellar_sdk import Server, TransactionBuilder, Network, Keypair

# While you might know where this Horizon instance should be,
# You'd need to manually delay transmission to control order.
server = Server("https://horizon-testnet.stellar.org")

secret_key = "SDY5TRQSEUSHS7UX26QMNMZ4X543UWZQPJZ7LQQUA3NAKDFVYTAWAB74"
source_keypair = Keypair.from_secret(secret_key)
source_account = server.load_account(source_keypair.public_key)

transaction_1 = TransactionBuilder(
  source_account = source_account,
  network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
  base_fee = 100
)

transaction_2 = TransactionBuilder(
  source_account = source_account,
  network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
  base_fee = 100
)

# Initialize arrays of 200 recipient public keys
first_100_users = [...]
second_100_users = [...]

# Attempting to send 200 operations at once from a single source
for n in range(100):
  transaction_1.append_payment_op(
    destination = first_100_users[n],
    amount = "10",
    asset = Asset.native()
  )
  transaction_2.append_payment_op(
    destination = second_100_users[n],
    amount = "10",
    asset = Asset.native()
  )

transaction_1 = transaction_1.set_timeout(30).build()
transaction_1.sign(sourceKeypair)

transaction_2 = transaction_2.set_timeout(30).build()
transaction_2.sign(sourceKeypair)

# Likely to fail due to misordered sequence numbers at validator
server.submit_transaction(transaction_1)

# Adding a delay here or checking for transaction_1 confirmation lets you
# account for network latency and submission timing in slower use cases.
server.submit_transaction(transaction_2)
```

```js
const { Server, TransactionBuilder, Networks, Keypair, Asset } = require('stellar-sdk');

// Define the server
const server = new Server('https://horizon-testnet.stellar.org');

const secretKey = 'SDY5TRQSEUSHS7UX26QMNMZ4X543UWZQPJZ7LQQUA3NAKDFVYTAWAB74';
const sourceKeypair = Keypair.fromSecret(secretKey);
const sourceAccount = await server.loadAccount(sourceKeypair.publicKey());

const transaction1 = new TransactionBuilder(sourceAccount, {
  networkPassphrase: Networks.TESTNET,
  fee: 100
});

const transaction2 = new TransactionBuilder(sourceAccount, {
  networkPassphrase: Networks.TESTNET,
  fee: 100
});

// Initialize arrays of 200 recipient public keys
const first100Users = [...];
const second100Users = [...];

// Attempting to send 200 operations at once from a single source
for (let n = 0; n < 100; n++) {
  transaction1.addOperation(StellarSdk.Operation.payment({
    destination: first100Users[n],
    asset: Asset.native(),
    amount: '10'
  }));
  transaction2.addOperation(StellarSdk.Operation.payment({
    destination: second100Users[n],
    asset: Asset.native(),
    amount: '10'
  }));
}

const builtTransaction1 = transaction1.setTimeout(30).build();
builtTransaction1.sign(sourceKeypair);

const builtTransaction2 = transaction2.setTimeout(30).build();
builtTransaction2.sign(sourceKeypair);

// Submit transactions
await server.submitTransaction(builtTransaction1);
// Add a delay or confirmation check for builtTransaction1 here or face conflicts
await server.submitTransaction(builtTransaction2);
```

```java
import org.stellar.sdk.*;
import org.stellar.sdk.requests.Server;
import org.stellar.sdk.responses.AccountResponse;

import java.util.List;

public class StellarPayment {
  public static void main(String[] args) {
    try {
      Server server = new Server("https://horizon-testnet.stellar.org");

      String secretKey = "SDY5TRQSEUSHS7UX26QMNMZ4X543UWZQPJZ7LQQUA3NAKDFVYTAWAB74";
      KeyPair sourceKeypair = KeyPair.fromSecretSeed(secretKey);
      AccountResponse sourceAccount = server.accounts().account(sourceKeypair.getAccountId());

      Transaction.Builder transactionBuilder1 = new Transaction.Builder(sourceAccount, Network.TESTNET)
          .setBaseFee(100)
          .setTimeout(30);

      Transaction.Builder transactionBuilder2 = new Transaction.Builder(sourceAccount, Network.TESTNET)
          .setBaseFee(100)
          .setTimeout(30);

      // Initialize arrays of 200 recipient public keys
      List<String> first100Users = List.of(...);
      List<String> second100Users = List.of(...);

      // Attempting to send 200 operations at once from a single source
      for (int n = 0; n < 100; n++) {
        transactionBuilder1.addOperation(new PaymentOperation.Builder(first100Users.get(n), AssetTypeNative.INSTANCE, "10").build());
        transactionBuilder2.addOperation(new PaymentOperation.Builder(second100Users.get(n), AssetTypeNative.INSTANCE, "10").build());
      }

      Transaction transaction1 = transactionBuilder1.build();
      transaction1.sign(sourceKeypair);

      Transaction transaction2 = transactionBuilder2.build();
      transaction2.sign(sourceKeypair);

      // Submit transactions
      server.submitTransaction(transaction1);
      // Add a delay or confirmation check for transaction1 here or face conflicts
      server.submitTransaction(transaction2);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

```go
package main

import (
  "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/protocols/horizon"
  "github.com/stellar/go/txnbuild"
)

func main() {
  client := horizonclient.DefaultTestNetClient

  secretKey := "SDY5TRQSEUSHS7UX26QMNMZ4X543UWZQPJZ7LQQUA3NAKDFVYTAWAB74"
  sourceKeypair, _ := keypair.ParseFull(secretKey)
  sourceAccount, _ := client.AccountDetail(horizonclient.AccountRequest{
    AccountID: sourceKeypair.Address(),
  })

  txParams := txnbuild.TransactionParams{
    SourceAccount:        &sourceAccount,
    IncrementSequenceNum: true,
    BaseFee:              txnbuild.MinBaseFee,
    Timebounds:           txnbuild.NewTimeout(30),
    Network:              network.TestNetworkPassphrase,
  }

  transaction1, _ := txnbuild.NewTransaction(txParams)
  transaction2, _ := txnbuild.NewTransaction(txParams)

  // Initialize arrays of 200 recipient public keys
  first100Users := []string{...}
  second100Users := []string{...}

  // Attempting to send 200 operations at once from a single source
  for n := 0; n < 100; n++ {
    paymentOp1 := txnbuild.Payment{
      Destination: first100Users[n],
      Amount:      "10",
      Asset:       txnbuild.NativeAsset{},
    }
    transaction1.Operations = append(transaction1.Operations, &paymentOp1)

    paymentOp2 := txnbuild.Payment{
      Destination: second100Users[n],
      Amount:      "10",
      Asset:       txnbuild.NativeAsset{},
    }
    transaction2.Operations = append(transaction2.Operations, &paymentOp2)
  }

  tx1, _ := transaction1.BuildSignEncode(sourceKeypair)
  tx2, _ := transaction2.BuildSignEncode(sourceKeypair)

  // Submit transactions
  client.SubmitTransactionXDR(tx1)
  // Add a delay or confirmation check for tx1 here or face conflicts
  client.SubmitTransactionXDR(tx2)
}
```
</CodeExample>

### Account Seperation

By distributing transactions across multiple channel accounts, you can achieve high transaction rates without sequence number conflicts. Each channel account can handle [up to 100 operations](../../fundamentals/transactions/operations-and-transactions.mdx#transactions) per transaction.

Using multiple accounts allows you to bypass the limitation of one transaction per ledger for each source account. This is particularly useful for applications that require high-frequency transactions. Here's how it works:

1. **Primary Account ($A_P$)**: Holds the main balance of Lumens (or any asset) and is responsible for authorizing operations. This account doesn't directly submit transactions but instead delegates this task to channel accounts.
2. **Channel Accounts ($A_{C_{1\text{--}5}}$)**: Act as intermediaries that submit transactions on behalf of the primary account. Each channel account has its own sequence number, allowing multiple transactions to be submitted in parallel without conflicts.
3. **Multisig Signers ($A_{MPC}$)**: Support operations by providing additional layers of authorization. Multiple signers can be required to approve a transaction, enhancing security by ensuring that no single account has unilateral control over the assets.

![Seperated Isolation](/assets/channel-accounts/segregation.png)

Imagine you need to send payments to 500 different recipients rapidly. Instead of trying to send all these payments from a single account (which would be rate-limited and prone to sequence number errors), you can use five channel accounts. Each channel account submits transactions containing 100 payment operations.

:::info

This approach ensures that the channel accounts only perform the necessary network submissions, while the primary account retains control and security over the assets.

:::

<CodeExample>

```python
# Using seperate accounts intro
```

```js

```

```java

```

```go

```

</CodeExample>

### Principle of Least Trust

In the custody chain for channels, assets primarily leave the base account. Only transaction fees and current sequence numbers are consumed by the channel account. By separating transaction approvals from network submissions, you can manage business logic offline, signing more securely.

This separation of duties allows you to manage approvals and business logic offline, reducing the risk of exposing your primary account to the network. You can send the transaction envelope to channel accounts after confirming your operations and signing. This leaves you protected even if an attacker uncovers the hot keys for $A_{C_{1\text{--}5}}$.

![Key Relationship](/assets/channel-accounts/signers.png)

:::note

Channel accounts should have no signing authority over the primary account.

:::

By design, you can submit a transaction with operations originating from any account. This flexibility allows you to encode different sources in various parts of the transaction:

- **Transaction Envelope**: Specify the source account for the entire transaction [transaction envelope](SRC_TX_ENV_SRC).
- **Individual Operations**: Set different source accounts for specific operations within the transaction [individual operations](SRC_OPERATION_SOURCE_TAG__PAYMENT_AS_EX).
- **Wrapping Context**: Use fee-bump transactions to wrap and adjust transaction fees and sources [wrapping context](SRC_FEE_BUMP_TX).

[footnote ** contract deployments etc here? **]

:::info

The network only accepts the final transaction once it is wholy constructed and signed by all required accounts, but [not more](https://github.com/stellar/stellar-docs/issues/773).

:::

## Configuration Requirements

Channel accounts let you reliably send transactions without waiting for submission acknowledgments. While this greatly increases your potential transaction rate, channel accounts also introduce operational requirements. These considerations keep your operations in sync with Stellar Core while maintaining high throughput.

Channel accounts allow you to manage the transaction flow efficiently by separating the transaction approvals from the network submissions. This separation ensures that $A_P$ maintains internal security and control over assets while delegating the submission tasks to channel accounts.

In some cases, you may need to set [minimum sequence number preconditions](../../fundamentals/transactions/operations-and-transactions.mdx#minimum-sequence-number) for transactions. This ensures that transactions are processed in the correct order, even if submitted by different channel accounts. Setting these preconditions helps maintain the integrity of the transaction sequence, especially in high-frequency environments.

### Necessary Signers

To avoid sequence number issues, create separate channel accounts and use them as the source accounts for transactions, while the base account holds the assets. These channel accounts need to be funded with enough XLM to cover transaction fees.

::: danger TODO

Make this into image // incorporate into initial declaration of accounts, do the signer security part here // funding Lumens info:

1. **Main Account (_A_P_)**: The primary account that holds the main balance of Lumens (or any asset). This account is responsible for authorizing operations but does not directly submit transactions.

   - **Funding**: Ensure the main account has sufficient Lumens to fund the channel accounts and cover the transaction amounts.
   - **Security**: The main account retains control over the assets, reducing exposure to potential network vulnerabilities.

2. **Channel Accounts (_A_C_{1–5}\_)**: These accounts act as intermediaries that submit transactions on behalf of the main account. Each channel account has its own sequence number, allowing multiple transactions to be submitted in parallel without conflicts.
   - **Funding**: Each channel account needs to be funded with enough XLM to cover transaction fees.
   - **Operations**: Channel accounts handle the transaction submission, consuming their own sequence numbers and transaction fees.

:::

<CodeExample>

```python

# emphasize main acc v children accs

#1. **Generate and Fund Channel Accounts**:
#    - Generate unique key pairs for each channel account.
#    - Fund each channel account with a sufficient starting balance to cover transaction fees.

#2. **Authorize Transactions**:
#    - Use the main account to authorize operations.
#    - Ensure the channel accounts are authorized to submit transactions by adding the necessary signers.

```

```js
const StellarSdk = require("stellar-sdk");

// Generate channel accounts and keys
const channelAccounts = [];
const channelKeys = [];
const numberOfChannels = 5;
for (let i = 0; i < numberOfChannels; i++) {
  const keypair = StellarSdk.Keypair.random();
  channelAccounts.push(keypair.publicKey());
  channelKeys.push(keypair.secret());
}
```

```java

```

```go

```

</CodeExample>

### State Rotation

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Effective state rotation involves maintaining a pool of channel accounts that can be dynamically assigned to handle transaction submissions. Here's how you can manage the states:

1. **In Use / Submitting**: These are channel accounts currently engaged in submitting transactions. They are temporarily locked until their transactions are confirmed.

   - **Locking Mechanism**: Once a transaction is built and submitted by a channel account, that account should be marked as "in use" and should not be assigned new transactions until the current ones are confirmed or dropped.
   - **Monitoring**: Continuously monitor the status of these transactions to determine when the channel accounts become available again.

2. **Available**: These are channel accounts that are ready to be assigned new transactions. They have either completed their previous transactions or are idle.
   - **Assignment**: Distribute new transactions to these available accounts to maintain high throughput and avoid delays.

<CodeExample>

```python

```

```js
// Function to find an available channel account
function getAvailableChannelAccount() {
  return channelAccounts.find((account) => account.state === "available");
}

// Function to mark channel account as in use
function markChannelAccountInUse(channelAccount) {
  channelAccount.state = "in use";
}

// Function to mark channel account as available
function markChannelAccountAvailable(channelAccount) {
  channelAccount.state = "available";
}

// Send payments using channel accounts with state rotation
(async () => {
  const server = new StellarSdk.Server("https://horizon-testnet.stellar.org");
  const sourceKeypair = StellarSdk.Keypair.fromSecret(
    "SDZ4Z5K7UQW4RQD5K6ZP3W6ZKHME4GSS2BGSRWLU3AFB4MPRU5Q5MRBJ",
  );
  const sourceAccount = await server.loadAccount(sourceKeypair.publicKey());

  let n = 0; // Transaction increment counter
  for (let i = 0; i < recipientKeys.length; i += 100) {
    const channelAccount = getAvailableChannelAccount();
    if (!channelAccount) {
      console.log(
        "No available channel account found. Waiting for one to become available...",
      );
      await new Promise((resolve) => setTimeout(resolve, 1000));
      i -= 100; // Retry this batch
      continue;
    }

    markChannelAccountInUse(channelAccount);
    const channelKeypair = StellarSdk.Keypair.fromSecret(channelAccount.secret);
    const channelAccountInfo = await server.loadAccount(
      channelAccount.publicKey,
    );

    let transaction = new StellarSdk.TransactionBuilder(channelAccountInfo, {
      fee: StellarSdk.BASE_FEE,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    });

    for (let j = 0; j < 100 && n < recipientKeys.length; j++) {
      transaction = transaction.addOperation(
        StellarSdk.Operation.payment({
          source: sourceKeypair.publicKey(),
          destination: recipientKeys[n],
          asset: StellarSdk.Asset.native(),
          amount: "1", // sending 1 XLM to each recipient
        }),
      );
      n++;
    }

    transaction = transaction.setTimeout(180).build();
    transaction.sign(sourceKeypair);
    transaction.sign(channelKeypair);

    server
      .submitTransaction(transaction)
      .then((result) => {
        console.log(
          `Transaction from channel ${channelAccount.publicKey} submitted:`,
          result,
        );
        markChannelAccountAvailable(channelAccount);
      })
      .catch((error) => {
        console.error(
          `Transaction from channel ${channelAccount.publicKey} failed:`,
          error,
        );
        markChannelAccountAvailable(channelAccount);
      });
  }
})();
```

```java

```

```go

```

</CodeExample>

### Bundle Size

Introduce high-freq batching through example of streaming payments

:::danger TODO - Scaling conisideration

Image showing approx map how much your'd want, insert PNG of rate with ceiling of max ledger operations

:::

explain maximization curve supply/demand img between size and speed

## Implementation Considerations

See above for scaling concerns

### Security

You will, of course, have to sign the transaction with both the base account key and the channel account key.

:::caution

Consider security practices around hot keys, signature weights, and access rotations. ### expand

:::

### Receiving Node

Decide whether to use your own transaction set or public nodes, considering rate limits.

your own txn set v public (rate limited)

### Fee Sponsorships

In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account.

Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Granting funds to children account, trsutlines

## Example Summary

<CodeExample>

```python
# channelAccounts[] is an array of accountIDs, one for each channel
# channelKeys[] is an array of secret keys, one for each channel
# channelIndex is the channel you want to send this transaction over

transaction = (
    TransactionBuilder(
      source_account = channelAccounts[channelIndex],
      network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee = base_fee,
    )
    .append_payment_op(
      source = baseAccount.public_key,
      destination = userAddress,
      asset = Asset.native(),
      amount = amountToSend,
    )
    .set_timeout(180) # Wait a maximum of three minutes for the transaction
    .build()
)

# base account must sign to approve the payment
transaction.sign(baseAccountKey)

# channel must sign to approve it being the source of the transaction
transaction.sign(channelKeys[channelIndex])
```

```js
// channelAccounts[] is an array of accountIDs, one for each channel
// channelKeys[] is an array of secret keys, one for each channel
// channelIndex is the channel you want to send this transaction over

// create payment from baseAccount to userAddress
var transaction = new StellarSdk.TransactionBuilder(
  channelAccounts[channelIndex],
  {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  },
)
  .addOperation(
    StellarSdk.Operation.payment({
      source: baseAccount.address(),
      destination: userAddress,
      asset: StellarSdk.Asset.native(),
      amount: amountToSend,
    }),
  )
  .setTimeout(180) // Wait a maximum of three minutes for the transaction
  .build();

// base account must sign to approve the payment
transaction.sign(baseAccountKey);

// channel must sign to approve it being the source of the transaction
transaction.sign(channelKeys[channelIndex]);
```

```java

```

```go

```

</CodeExample>
