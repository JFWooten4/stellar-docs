---
title: Channel Accounts
sidebar_position: 10
---

import { CodeExample } from "@site/src/components/CodeExample";

Channel accounts are a design pattern for submitting transactions to the network in bursts. Channel accounts are not what might comes to mind in terms of layer-2 channels. Rather, they are specialized accounts that act as proxies to submit transactions at a high rate.

:::caution

Submitting transactions quickly [often requires](potential_source_here_if_any_docs_on_channels_or_SEP6_signers_gone_awry) hot signing keys. It is best practice to extensively test your systems on [the testnet](SRC_TESTNET_INFO) before deploying production systems. Moreover, you may consider using hardware security modules or [multisignature MPC wallets](SRC_MUSTISIG_W_THRES) to secure your source and channel accounts.

:::

## Background

Channel accounts take advantage of the fact that the source account of a transaction can be different than the source account of the operations inside a transaction. This guide walks through an example using channels to send 500 payment operations in a ledger. It uses a primary account to hold Lumens and five channel accounts for transaction submissions.

:::note

You can make as many channel accounts as you need to maintain your desired transaction rate. However, one ledger [can only contain](SRC_MAX_OPS_LEDGER) 1,000 operations from all peers. To keep [fees](SRC_TXN_FEES) within reason, it is best practice to limit your app to 300 operations per ledger to minimize congestion. For extremely high throughput in non-emergency applications, consider using other scaling solutions like [Starlight](SRC_XLM_STARLIGHT_L2).

:::

### Motivation

#### Sequence Numbers

The network will reject [sequence numbers](SRC_SEQUENCE_NUMS) that are not contiguous (TODO: monotonically increasing?) for an account. Previously, if you sent even just two transactions in the same ledger, there was a reasonable chance they would arrive [out of sequence](src_out_of_sequence_community_example_orbitlens_or_overcat__or_lumenauts_post). Accordingly, the network [now allows](SRC_PROTOCOL_20_UPGRADE_TXN_LIM) only one transaction per ledger per source account.

#### Account Seperation

Stellar validators and their Horizon instances are spread across the globe. Since signals can take [up to 200ms](SRC_VITALIK_TRANSMISSIONS) to reach them, you cannot generally control network delays for one transaction packet over another without sequencing your own validator. To avoid sequence number issues, you can create separate channel accounts that can be used as the source account for the transaction while the account holding the assets serves as the source account for the individual operations.

<CodeExample>

```js

```

```python
# Example sending 200 ops at once from single source, failing
# While you might know where this Horizon instance should be,
# You'd need to manually delay transmission to control order.
```

```java

```

```go

```

</CodeExample>

Sending at high throughput, with more than 100 operations per transaction, can lead to fragmentation with different execution fees.

the lack of control over their order of arrival -- SPECIFICALLY DISCUSS 200ms rule by Vitalik

To avoid sequence number issues, you can create separate channel accounts that can be used as the source account for the transaction and use the account holding the assets as the base account or the source account for the individual operations in the transaction. In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account."""

Sending at high throughput, >100 ops per tx (or fragmenting large instances with different execution fees e.g.)

#### Principle of Least Trust

The transaction sequence numberss need only be sequential relative to the account that is submitting it, but the operations contained within those transactions can originate from any account.

By distributing transactions across multiple channel accounts, you can achieve high transaction rates without sequence number conflicts. Each channel account can handle [up to 100 operations](SRC_MAX_OPS_TXN) per transaction, optimizing throughput while adhering to the one-transaction-per-ledger rule.

isging away master assets v smaller approval flows :::info

Any account can transact operations on behalf of another.

:::

####

xyz

### Design Limits

While we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

wwhilst we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

### Codified Restrictions

To prevent failures, the network restricts each source account to submit no more than one transaction per ledger.

1 op per account per source, motivation to stop failures

restricts each source account to submit no more than one transaction per ledger

## Configuration

Channels use a collection of temporary accounts as proxies, each transacting operations on behalf of a primary account concurrently. This setup helps maintain high throughput without sequence number conflicts.

Channels use a collection of temporary accounts act as proxies, each transacting operations on behalf of a primary account concurrently.

intro own infrastruct, best practices for your use case (?)

### Required Accounts

To avoid sequence number issues, create separate channel accounts and use them as the source accounts for transactions, while the base account holds the assets. These channel accounts need to be funded with enough XLM to cover transaction fees.

Create multiple channel accounts funded with enough XLM to cover transaction fees.

Src v children

<CodeExample>

```js
const StellarSdk = require("stellar-sdk");

// Generate channel accounts and keys
const channelAccounts = [];
const channelKeys = [];
const numberOfChannels = 5;
for (let i = 0; i < numberOfChannels; i++) {
  const keypair = StellarSdk.Keypair.random();
  channelAccounts.push(keypair.publicKey());
  channelKeys.push(keypair.secret());
}
```

```python

```

```java

```

```go

```

</CodeExample>

### State Rotation

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Distribute transaction submissions evenly across these channel accounts to maximize throughput.

In use / submitting v. avaliable

<CodeExample>

```js

```

```python

```

```java

```

```go

```

</CodeExample>

### Bundle Size

Approx map how much your'd want insert PNG of rate with ceiling of max ledger operations

## Implementation Considerations

### Security

You will, of course, have to sign the transaction with both the base account key and the channel account key.

:::caution

Consider security practices around hot keys, signature weights, and access rotations. ### expand

:::

### Receiving Node

Decide whether to use your own transaction set or public nodes, considering rate limits.

your own txn set v public (rate limited)

### Fee Sponsorships

In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account.

Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Granting funds to children account, trsutlines

## Legacy Example

<CodeExample>

```js
// channelAccounts[] is an array of accountIDs, one for each channel
// channelKeys[] is an array of secret keys, one for each channel
// channelIndex is the channel you want to send this transaction over

// create payment from baseAccount to customerAddress
var transaction = new StellarSdk.TransactionBuilder(
  channelAccounts[channelIndex],
  {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  },
)
  .addOperation(
    StellarSdk.Operation.payment({
      source: baseAccount.address(),
      destination: customerAddress,
      asset: StellarSdk.Asset.native(),
      amount: amountToSend,
    }),
  )
  // Wait a maximum of three minutes for the transaction
  .setTimeout(180)
  .build();

transaction.sign(baseAccountKey); // base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]); // channel must sign to approve it being the source of the transaction
```

```python
# channelAccounts[] is an array of accountIDs, one for each channel
# channelKeys[] is an array of secret keys, one for each channel
# channelIndex is the channel you want to send this transaction over

transaction = (
    TransactionBuilder(
      source_account=channelAccounts[channelIndex],
      network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee=base_fee,
    )
    .append_payment_op(
      source=baseAccount.public_key,
      destination=customerAddress,
      asset=Asset.native(),
      amount=amountToSend,
    )
    .set_timeout(180) # Wait a maximum of three minutes for the transaction
    .build()
)

transaction.sign(baseAccountKey) # base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]) # channel must sign to approve it being the source of the transaction
```

```java
N/A
```

```go
N/A
```

</CodeExample>
