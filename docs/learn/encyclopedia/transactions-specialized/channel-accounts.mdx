---
title: Channel Accounts
sidebar_position: 10
---

import { CodeExample } from "@site/src/components/CodeExample";

Channel accounts provide a method for submitting transactions to the network at a high rate. The channel design pattern is not what normally comes to mind in terms of a layer-2 channel. Rather, they take advantage of the fact that the source account of a transaction can be different than the source account of the operations inside the transaction.

Channel accounts are specialized accounts that act as proxies to submit transactions on behalf of a primary account. By distributing transactions across multiple channel accounts, you can achieve high transaction rates without sequence number conflicts. Each channel account can handle up to 100 operations in a single transaction, optimizing throughput while adhering to the one-transaction-per-ledger rule.

As an example, this guide walks through an example of creating channels to send 500 payment operations in the same ledger.

:::info

Any account can transact operations on behalf of another. The issued transactions need only be sequential relative to the account that is submitting it, but the operations contained within those transactions can originate from any account.

:::

## Background

Channels take advantage of the fact that the source account of a transaction can be different than the source account of the operations inside the transaction. With this setup, you can make as many channels as you need to maintain your desired transaction rate.

### Motivation

Previously, if you sent even just two transactions in the same ledger, there was a reasonable chance they would arrive out of sequence. This is a problem because the network will reject sequence numbers that are not contiguous for an account.

The lack of control over their order of arrival can be problematic, as noted by Vitalik Buterin's 200ms rule, which discusses the challenges of transaction propagation delays. To avoid sequence number issues, you can create separate channel accounts that can be used as the source account for the transaction while the account holding the assets serves as the source account for the individual operations.

Sending at high throughput, with more than 100 operations per transaction, can lead to fragmentation with different execution fees.

previously, If you send even just two transactions in the same ledger, there’s a reasonable chance they will arrive out of sequence. This is a problem because the network will reject sequence numbers that are not contiguous for an account.

the lack of control over their order of arrival -- SPECIFICALLY DISCUSS 200ms rule by Vitalik

To avoid sequence number issues, you can create separate channel accounts that can be used as the source account for the transaction and use the account holding the assets as the base account or the source account for the individual operations in the transaction. In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account."""

Sending at high throughput, >100 ops per tx (or fragmenting large instances with different execution fees e.g.)

### Design Limits

While we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

wwhilst we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

### Codified Restrictions

To prevent failures, the network restricts each source account to submit no more than one transaction per ledger.

1 op per account per source, motivation to stop failures

restricts each source account to submit no more than one transaction per ledger

## Configuration

Channels use a collection of temporary accounts as proxies, each transacting operations on behalf of a primary account concurrently. This setup helps maintain high throughput without sequence number conflicts.

Channels use a collection of temporary accounts act as proxies, each transacting operations on behalf of a primary account concurrently.

intro own infrastruct, best practices for your use case (?)

### Required Accounts

To avoid sequence number issues, create separate channel accounts and use them as the source accounts for transactions, while the base account holds the assets. These channel accounts need to be funded with enough XLM to cover transaction fees.

Create multiple channel accounts funded with enough XLM to cover transaction fees.

Src v children

<CodeExample>

```js
const StellarSdk = require("stellar-sdk");

// Generate channel accounts and keys
const channelAccounts = [];
const channelKeys = [];
const numberOfChannels = 5;
for (let i = 0; i < numberOfChannels; i++) {
  const keypair = StellarSdk.Keypair.random();
  channelAccounts.push(keypair.publicKey());
  channelKeys.push(keypair.secret());
}
```

```python

```

```java

```

```go

```

</CodeExample>

### State Rotation

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Distribute transaction submissions evenly across these channel accounts to maximize throughput.

In use / submitting v. avaliable

<CodeExample>

```js

```

```python

```

```java

```

```go

```

</CodeExample>

### Bundle Size

Approx map how much your'd want insert PNG of rate with ceiling of max ledger operations

## Implementation Considerations

### Security

You will, of course, have to sign the transaction with both the base account key and the channel account key.

:::caution

Consider security practices around hot keys, signature weights, and access rotations. ### expand

:::

### Receiving Node

Decide whether to use your own transaction set or public nodes, considering rate limits.

your own txn set v public (rate limited)

### Fee Sponsorships

In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account.

Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Granting funds to children account, trsutlines

## Legacy Example

<CodeExample>

```js
// channelAccounts[] is an array of accountIDs, one for each channel
// channelKeys[] is an array of secret keys, one for each channel
// channelIndex is the channel you want to send this transaction over

// create payment from baseAccount to customerAddress
var transaction = new StellarSdk.TransactionBuilder(
  channelAccounts[channelIndex],
  {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  },
)
  .addOperation(
    StellarSdk.Operation.payment({
      source: baseAccount.address(),
      destination: customerAddress,
      asset: StellarSdk.Asset.native(),
      amount: amountToSend,
    }),
  )
  // Wait a maximum of three minutes for the transaction
  .setTimeout(180)
  .build();

transaction.sign(baseAccountKey); // base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]); // channel must sign to approve it being the source of the transaction
```

```python
# channelAccounts[] is an array of accountIDs, one for each channel
# channelKeys[] is an array of secret keys, one for each channel
# channelIndex is the channel you want to send this transaction over

transaction = (
    TransactionBuilder(
      source_account=channelAccounts[channelIndex],
      network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee=base_fee,
    )
    .append_payment_op(
      source=baseAccount.public_key,
      destination=customerAddress,
      asset=Asset.native(),
      amount=amountToSend,
    )
    .set_timeout(180) # Wait a maximum of three minutes for the transaction
    .build()
)

transaction.sign(baseAccountKey) # base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]) # channel must sign to approve it being the source of the transaction
```

```java
N/A
```

```go
N/A
```

</CodeExample>
