---
title: Channel Accounts
sidebar_position: 10
---

import { CodeExample } from "@site/src/components/CodeExample";

Channel accounts are a design pattern for submitting transactions to the network in bursts. Channel accounts are not what might come to mind in terms of layer-2 channels. Rather, they are a set specialized accounts that act as proxies to submit transactions quickly.

:::caution

Submitting transactions quickly [often requires](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0006.md) hot signing keys. It is best practice to extensively test your systems on [the testnet](../../fundamentals/networks.mdx#testnet) before deploying in high-speed production. Moreover, you may consider using hardware security modules or [multisignature MPC wallets](../security/signatures-multisig.mdx#thresholds) to secure your source and channel accounts.

:::

## Background Motivation

Channel accounts take advantage of the fact that the source account of a transaction ($S_T$) can be different than the source account of the operations inside a transaction ($S_O$).

:::danger TODO

Draw image: show exterior transaction signed by Alice source with interior operations signed by Bob source, all submitted to Horizon sun

:::

This guide walks through an example using channel accounts to send 500 payment operations in close ledgers. It uses a primary account ($A_P$) to hold Lumens and five channel accounts for submitting transactions ($A_{C_{1\text{--}5}}$).

:::danger TODO

Draw image: Main account w holdings, seperate cannels with own op files

:::

:::note Block Size

You can create as many channel accounts as needed to maintain your desired transaction rate. However, one ledger [can fit up to](https://stellar.expert/explorer/public/protocol-history) 1,000 operations from all peers. To keep [fees](../../fundamentals/fees-resource-limits-metering.mdx#inclusion-fee) within reason and minimize congestion, it is best practice to limit yourself to 300 operations per ledger. For extremely high throughput in non-emergency applications, consider using other scaling solutions like [Starlight](../../glossary.mdx#starlight).

:::

### Sequence Numbers

The network rejects transactions with [sequence numbers](../../glossary.mdx#sequence-number) that are not strictly increasing. Previously, if you sent even just two transactions in the same ledger, there was a [reasonable chance](https://stellar.stackexchange.com/questions/1675/channel-concept-in-stellar) they would arrive out of sequence. Accordingly, to prevent failures, the network [now restricts](SRC_PROTOCOL_20_UPGRADE_SOROBAN_SINGLE_TXN_LIM_get_from_Tyler_per_Discord_discussion) each source account to submit no more than one transaction per ledger.

:::info Packet Propogation

Stellar validators are spread across the globe, making it challenging to garauntee immediate order of arrival from one source. Only by sequencing [a validator](../../../validators/README.mdx) can you control physical network delays for your transactions, especially since signals vary in [travel time](SRC_VITALIK_TRANSMISSIONS) to reach [other nodes](../../../data/horizon/admin-guide/ingestion.mdx). Accordingly, channel accounts are the only way to garuntee many transactions submitted close to each other will settle on layer 1.

:::

<CodeExample>

```js

```

```python
# Example sending 200 ops at once from single source, failing

trasnaction = xxx

signed = for 100 in payments for each

submit (trxn1)
submit (txn2) # in the same ledger, this could hit in the wrong order fragmentation, misordered sequence number, and different execution fees.


# While you might know where this Horizon instance should be,
# You'd need to manually delay transmission to control order.
```

```java

```

```go

```

</CodeExample>

### Account Seperation

By distributing transactions across multiple channel accounts, you can achieve high transaction rates without sequence number conflicts. Each channel account can handle [up to 100 operations](../../fundamentals/transactions/operations-and-transactions.mdx#transactions) per transaction.

Using multiple accounts allows you to bypass the limitation of one transaction per ledger for each source account. This is particularly useful for applications that require high-frequency transactions. Here's how it works:

1. **Primary Account ($A_P$)**: Holds the main balance of Lumens (or any asset) and is responsible for authorizing operations. This account doesn't directly submit transactions but instead delegates this task to channel accounts.
2. **Channel Accounts ($A_{C_{1\text{--}5}}$)**: Act as intermediaries that submit transactions on behalf of the primary account. Each channel account has its own sequence number, allowing multiple transactions to be submitted in parallel without conflicts.
3. **Multisign Signers ($A_{MPC}$)**: Support operations by providing additional layers of authorization. Multiple signers can be required to approve a transaction, enhancing security by ensuring that no single account has unilateral control over the assets.

![Seperated Isolation](/assets/channel-accounts/segregation.png)

Imagine you need to send payments to 500 different recipients rapidly. Instead of trying to send all these payments from a single account (which would be rate-limited and prone to sequence number errors), you can use five channel accounts. Each channel account submits transactions containing 100 payment operations.

:::info

This approach ensures that the channel accounts only perform the necessary network submissions, while the primary account retains control and security over the assets.

:::

<CodeExample>

```js

```

```python
# Using seperate accounts intro
```

```java

```

```go

```

</CodeExample>

### Principle of Least Trust

In the custody chain for channels, assets primarily leave the base account. Only transaction fees and current sequence numbers are consumed by the channel account. By separating transaction approvals from network submissions, you can manage business logic offline, signing more securely.

This separation of duties allows you to manage approvals and business logic offline, reducing the risk of exposing your primary account to the network. The channel accounts should have no signing authority over the base account. This leaves you protected even if an attacker uncovers the hot keys for $A_{C_{1\text{--}5}}$.

:::danger TODO

Draw image: _A_Cs_ have no signing authority on _A_P_ - shown with lock icon, security arrows (demonstrating small approval relatinoships)

:::

By design, you can submit a transaction with operations originating from any account. This flexibility allows you to encode different sources in various parts of the transaction:

- **Transaction Envelope**: Specify the source account for the entire transaction [transaction envelope](SRC_TX_ENV_SRC).
- **Individual Operations**: Set different source accounts for specific operations within the transaction [individual operations](SRC_OPERATION_SOURCE_TAG__PAYMENT_AS_EX).
- **Wrapping Context**: Use fee-bump transactions to wrap and adjust transaction fees and sources [wrapping context](SRC_FEE_BUMP_TX).

[footnote ** contract deployments etc here? **]

:::info

The network only accepts the final transaction once it is wholy constructed and signed by all required accounts, but [not more](SRC_NO_EXTRA_TX_SIGS).

:::

## Configuration Requirements

Channel accounts let you reliably send transactions without waiting for submission acknowledgments. While this greatly increases your potential transaction rate, channels also introduce operational requirements. These considerations keep your operations in sync with Stellar Core while maintaining high throughput.

Channel accounts allow you to manage the transaction flow efficiently by separating the transaction approvals from the network submissions. This separation ensures that $A_P$ maintains internal security and control over assets while delegating the submission tasks to channel accounts.

In some cases, you may need to set [minimum sequence number preconditions](../../fundamentals/transactions/operations-and-transactions.mdx#minimum-sequence-number) for transactions. This ensures that transactions are processed in the correct order, even if submitted by different channel accounts. Setting these preconditions helps maintain the integrity of the transaction sequence, especially in high-frequency environments.

### Necessary Signers

To avoid sequence number issues, create separate channel accounts and use them as the source accounts for transactions, while the base account holds the assets. These channel accounts need to be funded with enough XLM to cover transaction fees.

::: danger TODO

Make this into image // incorporate into initial declaration of accounts, do the signer security part here // funding Lumens info:

1. **Main Account (_A_P_)**: The primary account that holds the main balance of Lumens (or any asset). This account is responsible for authorizing operations but does not directly submit transactions.

   - **Funding**: Ensure the main account has sufficient Lumens to fund the channel accounts and cover the transaction amounts.
   - **Security**: The main account retains control over the assets, reducing exposure to potential network vulnerabilities.

2. **Channel Accounts (_A_C_{1â€“5}\_)**: These accounts act as intermediaries that submit transactions on behalf of the main account. Each channel account has its own sequence number, allowing multiple transactions to be submitted in parallel without conflicts.
   - **Funding**: Each channel account needs to be funded with enough XLM to cover transaction fees.
   - **Operations**: Channel accounts handle the transaction submission, consuming their own sequence numbers and transaction fees.

:::

<CodeExample>

```js
const StellarSdk = require("stellar-sdk");

// Generate channel accounts and keys
const channelAccounts = [];
const channelKeys = [];
const numberOfChannels = 5;
for (let i = 0; i < numberOfChannels; i++) {
  const keypair = StellarSdk.Keypair.random();
  channelAccounts.push(keypair.publicKey());
  channelKeys.push(keypair.secret());
}
```

```python

# emphasize main acc v children accs

#1. **Generate and Fund Channel Accounts**:
#    - Generate unique key pairs for each channel account.
#    - Fund each channel account with a sufficient starting balance to cover transaction fees.

#2. **Authorize Transactions**:
#    - Use the main account to authorize operations.
#    - Ensure the channel accounts are authorized to submit transactions by adding the necessary signers.

```

```java

```

```go

```

</CodeExample>

### State Rotation

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Effective state rotation involves maintaining a pool of channel accounts that can be dynamically assigned to handle transaction submissions. Here's how you can manage the states:

1. **In Use / Submitting**: These are channel accounts currently engaged in submitting transactions. They are temporarily locked until their transactions are confirmed.

   - **Locking Mechanism**: Once a transaction is built and submitted by a channel account, that account should be marked as "in use" and should not be assigned new transactions until the current ones are confirmed or dropped.
   - **Monitoring**: Continuously monitor the status of these transactions to determine when the channel accounts become available again.

2. **Available**: These are channel accounts that are ready to be assigned new transactions. They have either completed their previous transactions or are idle.
   - **Assignment**: Distribute new transactions to these available accounts to maintain high throughput and avoid delays.

<CodeExample>

```js
// Function to find an available channel account
function getAvailableChannelAccount() {
  return channelAccounts.find((account) => account.state === "available");
}

// Function to mark channel account as in use
function markChannelAccountInUse(channelAccount) {
  channelAccount.state = "in use";
}

// Function to mark channel account as available
function markChannelAccountAvailable(channelAccount) {
  channelAccount.state = "available";
}

// Send payments using channel accounts with state rotation
(async () => {
  const server = new StellarSdk.Server("https://horizon-testnet.stellar.org");
  const sourceKeypair = StellarSdk.Keypair.fromSecret(
    "SDZ4Z5K7UQW4RQD5K6ZP3W6ZKHME4GSS2BGSRWLU3AFB4MPRU5Q5MRBJ",
  );
  const sourceAccount = await server.loadAccount(sourceKeypair.publicKey());

  let n = 0; // Transaction increment counter
  for (let i = 0; i < recipientKeys.length; i += 100) {
    const channelAccount = getAvailableChannelAccount();
    if (!channelAccount) {
      console.log(
        "No available channel account found. Waiting for one to become available...",
      );
      await new Promise((resolve) => setTimeout(resolve, 1000));
      i -= 100; // Retry this batch
      continue;
    }

    markChannelAccountInUse(channelAccount);
    const channelKeypair = StellarSdk.Keypair.fromSecret(channelAccount.secret);
    const channelAccountInfo = await server.loadAccount(
      channelAccount.publicKey,
    );

    let transaction = new StellarSdk.TransactionBuilder(channelAccountInfo, {
      fee: StellarSdk.BASE_FEE,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    });

    for (let j = 0; j < 100 && n < recipientKeys.length; j++) {
      transaction = transaction.addOperation(
        StellarSdk.Operation.payment({
          source: sourceKeypair.publicKey(),
          destination: recipientKeys[n],
          asset: StellarSdk.Asset.native(),
          amount: "1", // sending 1 XLM to each recipient
        }),
      );
      n++;
    }

    transaction = transaction.setTimeout(180).build();
    transaction.sign(sourceKeypair);
    transaction.sign(channelKeypair);

    server
      .submitTransaction(transaction)
      .then((result) => {
        console.log(
          `Transaction from channel ${channelAccount.publicKey} submitted:`,
          result,
        );
        markChannelAccountAvailable(channelAccount);
      })
      .catch((error) => {
        console.error(
          `Transaction from channel ${channelAccount.publicKey} failed:`,
          error,
        );
        markChannelAccountAvailable(channelAccount);
      });
  }
})();
```

```python

```

```java

```

```go

```

</CodeExample>

### Bundle Size

Introduce high-freq batching through example of streaming payments

:::danger TODO - Scaling conisideration

Image showing approx map how much your'd want, insert PNG of rate with ceiling of max ledger operations

:::

explain maximization curve supply/demand img between size and speed

## Implementation Considerations

See above for scaling concerns

### Security

You will, of course, have to sign the transaction with both the base account key and the channel account key.

:::caution

Consider security practices around hot keys, signature weights, and access rotations. ### expand

:::

### Receiving Node

Decide whether to use your own transaction set or public nodes, considering rate limits.

your own txn set v public (rate limited)

### Fee Sponsorships

In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account.

Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Granting funds to children account, trsutlines

## Example Summary

<CodeExample>

```js
// channelAccounts[] is an array of accountIDs, one for each channel
// channelKeys[] is an array of secret keys, one for each channel
// channelIndex is the channel you want to send this transaction over

// create payment from baseAccount to customerAddress
var transaction = new StellarSdk.TransactionBuilder(
  channelAccounts[channelIndex],
  {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  },
)
  .addOperation(
    StellarSdk.Operation.payment({
      source: baseAccount.address(),
      destination: customerAddress,
      asset: StellarSdk.Asset.native(),
      amount: amountToSend,
    }),
  )
  // Wait a maximum of three minutes for the transaction
  .setTimeout(180)
  .build();

transaction.sign(baseAccountKey); // base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]); // channel must sign to approve it being the source of the transaction
```

```python
# channelAccounts[] is an array of accountIDs, one for each channel
# channelKeys[] is an array of secret keys, one for each channel
# channelIndex is the channel you want to send this transaction over

transaction = (
    TransactionBuilder(
      source_account=channelAccounts[channelIndex],
      network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee=base_fee,
    )
    .append_payment_op(
      source=baseAccount.public_key,
      destination=customerAddress,
      asset=Asset.native(),
      amount=amountToSend,
    )
    .set_timeout(180) # Wait a maximum of three minutes for the transaction
    .build()
)

transaction.sign(baseAccountKey) # base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]) # channel must sign to approve it being the source of the transaction
```

```java
N/A
```

```go
N/A
```

</CodeExample>
