---
title: Channel Accounts
sidebar_position: 10
---

import { CodeExample } from "@site/src/components/CodeExample";

Channel accounts are a design pattern for submitting transactions to the network in bursts. Channel accounts are not what might come to mind in terms of layer-2 channels. Rather, they are a set specialized accounts that act as proxies to submit transactions quickly.

:::caution

Submitting transactions quickly [often requires](potential_source_here_if_any_docs_on_channels_or_SEP6_signers_gone_awry) hot signing keys. It is best practice to extensively test your systems on [the testnet](SRC_TESTNET_INFO) before deploying in high-speed production. Moreover, you may consider using hardware security modules or [multisignature MPC wallets](SRC_MUSTISIG_W_THRES) to secure your source and channel accounts.

:::

## Background

Channel accounts take advantage of the fact that the source account of a transaction (_S_T_) can be different than the source account of the operations inside a transaction (_S_O_).

:::danger TODO Draw image: show exterior transaction signed by Alice source with interior operations signed by Bob source, all submitted to Horizon sun :::

This guide walks through an example using channels to send 500 payment operations in close ledgers. It uses a primary account (_A_P_) to hold Lumens and five channel accounts for submitting transactions (_A_C\_{1&ndash;5}_).

:::danger TODO Draw image: Main account w holdings, seperate cannels with own op files :::

:::note Block Size

You can make as many channel accounts as needed to maintain your desired transaction rate. However, one ledger [can fit up to](SRC_MAX_OPS_LEDGER) 1,000 operations from all peers. To keep [fees](SRC_TXN_FEES) within reason, it is best practice to limit yourself to 300 operations per ledger to minimize congestion. For extremely high throughput in non-emergency applications, consider using other scaling solutions like [Starlight](SRC_XLM_STARLIGHT_L2).

:::

### Motivation

#### Sequence Numbers

The network rejects transactions with [sequence numbers](SRC_SEQUENCE_NUMS) that are not monotonically increasing. Previously, if you sent even just two transactions in the same ledger, there was a reasonable chance they would arrive [out of sequence](src_out_of_sequence_community_example_orbitlens_or_overcat__or_lumenauts_post). Accordingly, the network [now only allows](SRC_PROTOCOL_20_UPGRADE_TXN_LIM) one transaction per source account per ledger.

:::info Packet Propogation

Stellar validators are spread across the globe, making it challenging to garauntee immediate order of arrival from one source. Only by sequencing [a validator](SRC_RUNNING_VALIDATOR_NODE) can you control physical network delays for your transactions, especially since signals can take [up to 200ms](SRC_VITALIK_TRANSMISSIONS) to reach [other nodes](SRC_HOW_HORIZON_RECEIVES_TX_or_stellarInfoNetwork). Accordingly, channel accounts are the only way to garuntee many transactions submitted close to each other will settle on layer 1.

:::

<CodeExample>

```js

```

```python
# Example sending 200 ops at once from single source, failing

trasnaction = xxx

signed = for 100 in payments for each

submit (trxn1)
submit (txn2) # in the same ledger, this could hit in the wrong order fragmentation, misordered sequence number, and different execution fees.


# While you might know where this Horizon instance should be,
# You'd need to manually delay transmission to control order.
```

```java

```

```go

```

</CodeExample>

#### Account Seperation

By distributing transactions across multiple channel accounts, you can achieve high transaction rates without sequence number conflicts. Each channel account can handle [up to 100 operations](SRC_MAX_OPS_TXN) per transaction.

<CodeExample>

```js

```

```python
# Using seperate accounts intro
```

```java

```

```go

```

</CodeExample>

#### Principle of Least Trust

In the custody chain for channels, assets principally leave the base account. Only transaction fees and current sequence numbers get consumed by the channel account. By separating transaction approvals from network submissions, you can manage business logic offline, signing more securely.

:::danger TODO Draw image: _A_Cs_ have no signing authority on _A_P_ - shown with lock icon, security arrows (demonstrating small approval relatinoships) :::

:::info

By design, you can submit a transaction with operations originating from any account. You might encode different sources in the [transaction envelope](SRC_TX_ENV_SRC), [individual operations](SRC_OPERATION_SOURCE_TAG__PAYMENT_AS_EX), or [wrapping context](SRC_FEE_BUMP_TX). [footnote ** contract deployments etc here? **] The final transaction is valid onced signed by all accounts.

:::

### Design Limits

Transaction sequence numbers need only be sequential relative to the account that is submitting it, but the operations contained within those transactions can originate from any account.

To avoid sequence number issues, you can create separate channel accounts that can be used as the source account for the transaction, while the account holding the assets serves as the source individual operations.

While we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

wwhilst we can enjoy very fast clearing times, it seems the only way to ensure transactions are not rejected for being out of sequence is to wait for an acknowledgment before sending the next. This severely limits our potential transaction rate.

An account’s transactions always need to be submitted to the network in increments of one sequence number (unless minimum sequence number preconditions are set). This can cause problems if you are submitting transactions at a high rate, as they can potentially reach Stellar Core out of order and will then bounce with a bad sequence error.

### Codified Restrictions

To prevent failures, the network restricts each source account to submit no more than one transaction per ledger.

1 op per account per source, motivation to stop failures

restricts each source account to submit no more than one transaction per ledger

## Configuration

Channels use a collection of temporary accounts as proxies, each transacting operations on behalf of a primary account concurrently. This setup helps maintain high throughput without sequence number conflicts.

Channels use a collection of temporary accounts act as proxies, each transacting operations on behalf of a primary account concurrently.

intro own infrastruct, best practices for your use case (?)

### Required Accounts

To avoid sequence number issues, create separate channel accounts and use them as the source accounts for transactions, while the base account holds the assets. These channel accounts need to be funded with enough XLM to cover transaction fees.

Create multiple channel accounts funded with enough XLM to cover transaction fees.

Src v children

<CodeExample>

```js
const StellarSdk = require("stellar-sdk");

// Generate channel accounts and keys
const channelAccounts = [];
const channelKeys = [];
const numberOfChannels = 5;
for (let i = 0; i < numberOfChannels; i++) {
  const keypair = StellarSdk.Keypair.random();
  channelAccounts.push(keypair.publicKey());
  channelKeys.push(keypair.secret());
}
```

```python

```

```java

```

```go

```

</CodeExample>

### State Rotation

Distribute transaction submissions evenly across channel accounts to maximize throughput. Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Distribute transaction submissions evenly across these channel accounts to maximize throughput.

In use / submitting v. avaliable

<CodeExample>

```js

```

```python

```

```java

```

```go

```

</CodeExample>

### Bundle Size

Approx map how much your'd want insert PNG of rate with ceiling of max ledger operations

## Implementation Considerations

### Security

You will, of course, have to sign the transaction with both the base account key and the channel account key.

:::caution

Consider security practices around hot keys, signature weights, and access rotations. ### expand

:::

### Receiving Node

Decide whether to use your own transaction set or public nodes, considering rate limits.

your own txn set v public (rate limited)

### Fee Sponsorships

In this scenario, the assets will come out of the base account, and the sequence number and fees will be consumed by the channel account.

Monitor and manage the lifecycle of channel accounts, including funding, transaction submission, and merging back unused funds to the primary account.

Granting funds to children account, trsutlines

## Example Summary

<CodeExample>

```js
// channelAccounts[] is an array of accountIDs, one for each channel
// channelKeys[] is an array of secret keys, one for each channel
// channelIndex is the channel you want to send this transaction over

// create payment from baseAccount to customerAddress
var transaction = new StellarSdk.TransactionBuilder(
  channelAccounts[channelIndex],
  {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  },
)
  .addOperation(
    StellarSdk.Operation.payment({
      source: baseAccount.address(),
      destination: customerAddress,
      asset: StellarSdk.Asset.native(),
      amount: amountToSend,
    }),
  )
  // Wait a maximum of three minutes for the transaction
  .setTimeout(180)
  .build();

transaction.sign(baseAccountKey); // base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]); // channel must sign to approve it being the source of the transaction
```

```python
# channelAccounts[] is an array of accountIDs, one for each channel
# channelKeys[] is an array of secret keys, one for each channel
# channelIndex is the channel you want to send this transaction over

transaction = (
    TransactionBuilder(
      source_account=channelAccounts[channelIndex],
      network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee=base_fee,
    )
    .append_payment_op(
      source=baseAccount.public_key,
      destination=customerAddress,
      asset=Asset.native(),
      amount=amountToSend,
    )
    .set_timeout(180) # Wait a maximum of three minutes for the transaction
    .build()
)

transaction.sign(baseAccountKey) # base account must sign to approve the payment
transaction.sign(channelKeys[channelIndex]) # channel must sign to approve it being the source of the transaction
```

```java
N/A
```

```go
N/A
```

</CodeExample>
