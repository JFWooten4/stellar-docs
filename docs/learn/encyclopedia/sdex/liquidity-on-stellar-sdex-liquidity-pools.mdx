---
title: "Liquidity on Stellar: the SDEX and Liquidity Pools"
---

import { CodeExample } from "@site/src/components/CodeExample";
import YouTube from "@site/src/components/YouTube";

<YouTube ID="YFca255hXj8" />

The SDEX is (would be a horrible intransitive sentence, but let's keep that ethos)

The Stellar network acts as a decentralized distributed exchange that allows users to trade and convert assets with the [Manage Buy Offer](../../../data/horizon/api-reference/resources/operations/object/buy-offer.mdx) and [Manage Sell Offer](../../../data/horizon/api-reference/resources/operations/object/sell-offer.mdx) operations. The Stellar ledger stores both the balances held by user accounts and orders that user accounts make to buy or sell assets.

Financial markets thrive because of liquidity. It's the grease in the wheels, so to speak, of a global payments system. Stellar is one of the very few platforms that accounts for liquidity at scale with no centralized party.

links note migrated:

- https://stellar.org/blog/foundation-news/introducing-stellar (prolly a fnote)
- https://wikipedia.org/wiki/Order_book (i think this is mentioned but idk it'd be nice to simplify for new users, prolly outside scope re https://github.com/JFWooten4/JFWooten4/blob/main/decisions/core-723-fn.md)
- validators](https://stellarbeat.io/

When you convert one currency to another in traditional financial markets, your trade happens because of limit orders. These orders specify how much someone will pay for a certain amount of any asset. Thus, when you need to convert your dollars to yen, e.g., their order to sell yen for dollars counteracts and "fulfills" your trade.

/P1

/P2

<!--- begin \mathcal{f} --->

## Reading Prices

This section covers querying the live order book and accessing price data. By interacting with the SDEX's public [Horizon endpoints](SRC_API), you can obtain real-time market data and make informed trading decisions. While Stellar provides transparent access to price information, external oracles can also be used when integrating with other systems or when off-chain data is required.

:::note

This section is scoped specifically to liquidity regarding the Stellar Decentralized Exchange ("SDEX") and Automated Market Makers ("AMMs") built into the Stellar protocol. It does not include information regarding smart contracts. Rather, it explains the network's native layer-1 atomic swap infrastructure.

:::

The Stellar network takes a crowdsourced approach to liquidity. Namely, Stellar's DEX gives all users equal access to a global decentralized order book. Since launching with the genesis of `stellar-core` in 2014, the SDEX has processed over 4.2 billion trades worth upwards of \$23,560,000,000.

Users can trade assets across the Stellar network using [priced orders](../../fundamentals/transactions/list-of-operations.mdx#manage-sell-offer), [path payments](../transactions-specialized/path-payments.mdx), and [native AMMs](#liquidity-pools-amm). These features leverage Stellar’s decentralized exchange, which has existed since the launch of the network, and liquidity pools, introduced in Protocol 18.

In this section, we will talk about the SDEX and liquidity pools. To learn about how these work together to execute transactions, see our [Path Payments Encyclopedia Entry](../transactions-specialized/path-payments.mdx). _Id._

## Protocol

The Stellar protocol facilitates cross-border payments and asset transfers by leveraging its decentralized exchange (DEX). The DEX allows for the seamless exchange of assets, enabling generalized token settlement across different currencies and asset types.

typedef f :::danger

<CodeExample>

```python
from stellar_sdk import Keypair, Server, TransactionBuilder, Network, Asset

privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB"
publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2"

astroDollar = Asset("AstroDollar", "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7")
astroPeso = Asset("AstroPeso", "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5")

server = Server("https://horizon-testnet.stellar.org")
account = server.load_account(publicKey)

transaction = TransactionBuilder(
  source_account = account,
  network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
  base_fee = 100
).append_manage_sell_offer_op(
  selling = astroPeso,
  buying = astroDollar,
  amount = "1000",
  price = "20.0" # 20 Pesos per Dollar
).set_timeout(360).build()

keypair = Keypair.from_secret(privateKey)
transaction.sign(keypair)

response = server.submit_transaction(transaction)
print(f"Transaction successful: {response['successful']}")
print(f"Transaction hash: {response['hash']}")
print(f"Offer ID: {response['result_xdr']}")
```

```js
const {
  Keypair,
  Server,
  TransactionBuilder,
  Asset,
  Networks,
} = require("stellar-sdk");

const privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB";
const publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2";

const astroDollar = new Asset(
  "AstroDollar",
  "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7",
);
const astroPeso = new Asset(
  "AstroPeso",
  "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5",
);

const server = new Server("https://horizon-testnet.stellar.org");

(async function () {
  const account = await server.loadAccount(publicKey);

  const transaction = new TransactionBuilder(account, {
    fee: 100,
    networkPassphrase: Networks.TESTNET,
  })
    .addOperation({
      type: "manageSellOffer",
      selling: astroPeso,
      buying: astroDollar,
      amount: "1000",
      price: "20.0", // 20 Pesos per Dollar
    })
    .setTimeout(360)
    .build();

  const keypair = Keypair.fromSecret(privateKey);
  transaction.sign(keypair);

  try {
    const response = await server.submitTransaction(transaction);
    console.log(`Transaction successful: ${response.successful}`);
    console.log(`Transaction hash: ${response.hash}`);
    console.log(`Offer ID: ${response.result_xdr}`);
  } catch (e) {
    console.error(e);
  }
})();
```

```java
import org.stellar.sdk.*;
import org.stellar.sdk.responses.SubmitTransactionResponse;

public static void main(String[] args) throws Exception {
  String privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB";
  String publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2";

  Asset astroDollar = new AssetTypeCreditAlphaNum4(
    "AstroDollar", "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7"
  );
  Asset astroPeso = new AssetTypeCreditAlphaNum4(
    "AstroPeso", "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5"
  );

  Server server = new Server("https://horizon-testnet.stellar.org");
  AccountResponse account = server.accounts().account(publicKey);

  Transaction transaction = new TransactionBuilder(account, Network.TESTNET)
    .setBaseFee(Transaction.MIN_BASE_FEE)
    .addOperation(new ManageSellOfferOperation.Builder(
      astroPeso,
      astroDollar,
      "1000", // Sell 1000 Pesos
      "20.0" // 20 Pesos per Dollar
    ).build())
    .setTimeout(360)
    .build();

  KeyPair keypair = KeyPair.fromSecretSeed(privateKey);
  transaction.sign(keypair);

  SubmitTransactionResponse response = server.submitTransaction(transaction);
  System.out.println("Transaction successful: " + response.isSuccessful());
  System.out.println("Transaction hash: " + response.getHash());
  System.out.println("Offer ID: " + response.getExtras().getResultXdr());
}
```

```go
package main

import (
  "fmt"
  "github.com/stellar/go/build"
  "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/protocols/horizon"
  "github.com/stellar/go/txnbuild"
)

func main() {
  privateKey := "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB"
  publicKey := "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2"

  astroDollar := txnbuild.CreditAsset{
    Code:   "AstroDollar",
    Issuer: "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7",
  }
  astroPeso := txnbuild.CreditAsset{
    Code:   "AstroPeso",
    Issuer: "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5",
  }

  server := horizonclient.DefaultTestNetClient
  request := horizonclient.AccountRequest{AccountID: publicKey}
  account, err := server.AccountDetail(request)
  check(err)

  transaction, err := txnbuild.NewTransaction(
    txnbuild.TransactionParams{
      SourceAccount:        &account,
      IncrementSequenceNum: true,
      BaseFee:              txnbuild.MinBaseFee,
      Operations: []txnbuild.Operation{
        &txnbuild.ManageSellOffer{
          Selling: astroPeso,
          Buying:  astroDollar,
          Amount:  "1000",
          Price:   "20.0", // 20 Pesos per Dollar
        },
      },
      Timebounds: txnbuild.NewTimebounds(0, 360),
    },
  )
  check(err)
  kp, err := keypair.ParseFull(privateKey)
  check(err)
  signedTx, err := transaction.Sign(network.TestNetworkPassphrase, kp)
  check(err)

  resp, err := server.SubmitTransaction(signedTx)
  check(err)
  fmt.Printf("Transaction successful: %v\n", resp.Successful)
  fmt.Printf("Transaction hash: %s\n", resp.Hash)
  fmt.Printf("Offer ID: %s\n", resp.ResultXdr)
}
```

</CodeExample>

The price returned is quoted based on the response `base` asset, which is `AstroDollar` in this example. That means the default value will show XLM/AstroDollar for an `amount` of XLM. However, you can use `price_r` from the [query response](../../../data/horizon/api-reference/retrieve-an-order-book.api.mdx) to invert into a `counter` asset or get an exact ratio. Now that we know the live market rate, we can update our offer to use a competative exchange price rather than a flat `20` pesos/dollar ratio.

Relevantly, this exmaple code querys the [Horizon instance](../../../data/horizon/README.mdx) of the [SDF](../../glossary.mdx#stellar-development-foundation-sdf)'s testnet. Howver, in production, you would replace this server with the validating entity ou mst trust. This is because you want to align your view of the network with the entrypoint which you send any order to.

Along those lines, it's also worth noting again the difference in functinal control levels regauding teh SDEX. While you can read and submit transactions through public Horizon interfaces, validators themselves form transactions sets and reach consenssus in accordance with the underlying protocol rules governing core SCP. This means that your trade to convery currencies always exectued in equal preference ot other pending orders as long as the Horizon entrypoint operator includes your [operation](../../../data/horizon/api-reference/resources/operations/object/sell-offer.mdx) in their [transaction set](../../fundamentals/stellar-consensus-protocol.mdx#nomination-protocol) per their [reputation](../../fundamentals/stellar-consensus-protocol.mdx#quorum-set).

If you'd like to keep your view of the order book up to date, you can [stream](../../data/horizon/api-reference/structure/streaming) the information.

:::

<!--- end \mathcal{f} --->

### Custody

On Stellar, users maintain custody of their assets at all times. The network's design ensures that asset transfers and conversions happen without the need for intermediaries to hold or control user funds. Path payments allow users to send one asset and have the recipient receive another, all while maintaining custody and security.

### Intermediaries

Stellar eliminates unnecessary intermediaries by enabling direct asset exchange between users. This reduces costs and increases efficiency in cross-border transactions.

:::danger

href scp which requisites the scp vid embed

should be ```mdx import YouTube from "@site/src/components/YouTube";

<YouTube ID="aU08km2xrz0" />
```

:::

(fn3) Regulation [^regs]

While Stellar provides a decentralized infrastructure, it supports compliance with regulatory requirements. Issuers can enforce authorization and compliance controls on their assets as needed.

[The document continues with detailed explanations of the SDEX, liquidity pools, operations, and code examples.]

/P3

## Minting Functionality

In addition to trading existing assets, Stellar allows issuers to create new assets directly on the network. A sell offer from the issuer account will generate new assets by decree. This functionality enables the issuance of tokens representing fiat currencies, commodities, or any other assets, providing a versatile platform for asset digitization.

## Authorization

Stellar supports flexible authorization mechanisms, allowing issuers to control the use of their assets. This includes options like requiring authorization before holding an asset and revoking authorization to prevent an account from holding or trading the asset further.

:::danger

[incl. authorizations table here] as purchasing aquisitors

:::

<CodeExample title="listing depth">

```python

```

```js

```

```java

```

```go

```

</CodeExample>

/P4

## Liquidity

### Market Depth

The more orders available to transact against, the more currency you can convert at any time without moving the market. Stellar stores these open orders as `offer` [objects](https://developers.stellar.org/docs/data/horizon/api-reference/resources/offers/object) directly on chain. XYZ_ONE_SENT_HERE_WITH_HREF_ON_TRADING—maybe SpeedEx post.

Stellar stores these open orders as `offer` [objects](https://developers.stellar.org/docs/data/horizon/api-reference/resources/offers/object) directly on-chain. This transparency allows anyone to analyze the order book and understand the trading activity for any asset pair.

### Fill Prices

The network and by extension its [validators](https://stellarbeat.io/) match orders based on the protocol rules of [Stellar Core](https://github.com/stellar/stellar-core/blob/fbb53d8ad42dcc12a046c9be949d654821a24d38/src/transactions/OfferExchange.cpp#L227-L550). Orders are filled at the same price or better than specified, ensuring fair execution. This means you receive the best possible price available in the market at that moment.(#ref-more-later-on-per-ledger-match-matching).

## Submitting Trades

Let's pretend you just got paid in Mexican Pesos, but you'd prefer to hold your savings in U.S. Dollars. After querying the [exchange rate](#reading-prices), we can send a new offer to the network, swapping Pesos for Dollars at our desired rate. By submitting a sell offer that matches the current market price, we can ensure our pesos are converted to dollars promptly.—probably something along the lines of using a taker offer to guarantee fill price.

<CodeExample>

```python
should be implemented already ###
```

</CodeExample>

# Uniform Standard

:::danger remove_me

Since any account can send an order to the SDEX, its order book is uniquely egalitarian in that all market participants follow the same rules, treatment, and pricing. You receive the same exchange rate whether you are a major European bank or a rural Kenyan farmer. Indeed, the throughput enabled by [SCP](https://www.stellar.org/developers/guides/concepts/scp.html) means you can specify exactly how much you pay for conversions.

:::

means you can specify exactly how much you pay for conversions.

## Source of Truth

Now that we know how to submit an order to the SDEX, let's walk through reading the current order book. This entails collecting all the buyers for a specific currency pair and comparing this demand to all the sellers of that pair. We'll stick with our pesos-dollars example and ignore potential [passive offers](#passive-order) for the time being.

<CodeExample>

```python
orderBook = server.orderbook(
  selling = astroPeso,
  buying = astroDollar
).call()

print("Bids:")
for bid in orderBook['bids']:
  print(f"Price: {bid['price']}, Amount: {bid['amount']}")

print("\nAsks:")
for ask in orderBook['asks']:
  print(f"Price: {ask['price']}, Amount: {ask['amount']}")
```

```js
const orderBook = await server.orderbook(astroPeso, astroDollar).call();

console.log("Bids:");
orderBook.bids.forEach((bid) => {
  console.log(`Price: ${bid.price}, Amount: ${bid.amount}`);
});

console.log("\nAsks:");
orderBook.asks.forEach((ask) => {
  console.log(`Price: ${ask.price}, Amount: ${ask.amount}`);
});
```

```java
import java.util.List;

public static void main(String[] args) throws Exception {
  OrderBookResponse orderBook = server.orderBook(astroPeso, astroDollar).execute();

  System.out.println("Bids:");
  List<OrderBookResponse.Row> bids = orderBook.getBids();
  for (OrderBookResponse.Row bid : bids) {
    System.out.println("Price: " + bid.getPrice() + ", Amount: " + bid.getAmount());
  }

  System.out.println("\nAsks:");
  List<OrderBookResponse.Row> asks = orderBook.getAsks();
  for (OrderBookResponse.Row ask : asks) {
    System.out.println("Price: " + ask.getPrice() + ", Amount: " + ask.getAmount());
  }
}
```

```go
func main() {
  orderBook, err := server.OrderBook(horizonclient.OrderBookRequest{
    Selling: astroPeso,
    Buying:  astroDollar,
  })
  check(err)

  fmt.Println("Bids:")
  for _, bid := range orderBook.Bids {
    fmt.Printf("Price: %s, Amount: %s\n", bid.Price, bid.Amount)
  }

  fmt.Println("\nAsks:")
  for _, ask := range orderBook.Asks {
    fmt.Printf("Price: %s, Amount: %s\n", ask.Price, ask.Amount)
  }
}
```

</CodeExample>

The price returned is quoted based on the response `base` asset, which is `AstroDollar` in this example. That means the default value will show `AstroPeso`/`AstroDollar` for an `amount` of AstroPeso. However, you can use `price_r` from the [query response](https://developers.stellar.org/api/aggregations/order-books) to invert into a `counter` asset or get an exact ratio. Now that we know the live market rate, we can update our offer to use a competitive exchange price rather than a flat `20` pesos/dollar ratio.

Relevantly, this example code queries the [Horizon instance](https://developers.stellar.org/api/horizon/) of the [SDF](SDF_GLOSSARY_ITEM)'s testnet. However, in production, you would replace this server with the validating entity you trust. This is because you want to align your view of the network with the entry point through which you send any order. (less/imph on this, at least within this scope)

Along those lines, it's also worth noting again the difference in functional control levels regarding the SDEX. While you can read and submit transactions through public Horizon interfaces, validators themselves form transaction sets and reach consensus in accordance with the underlying protocol rules governing core SCP. This means that your trade to convert currencies is always executed in equal preference to other pending orders as long as the Horizon entry point operator includes your [operation](https://developers.stellar.org/docs/start/list-of-operations/#manage-sell-offer) in their transaction set, per their role in the consensus process. ^actual href at the README

If you'd like to keep your view of the order book up to date, you can [stream](https://developers.stellar.org/docs/data-and-protocols/streaming) the information.

When performing this analysis on live [mainnet](https://developers.stellar.org/docs/run-api/horizon/tutorials/quickstart#using-the-public-network) data, you will likely see a combination of trading taking place on top of the SDEX. The first, most basic option, is when a new order crosses the price set by an outstanding order. The two instantly cross once the new order gets accepted, and the transaction generates a taker `contraID` rather than an `offerID` for the "buyer" of the existing liquidity.

The other two options are exchanges made using [path payments](https://developers.stellar.org/docs/encyclopedia/path-payments) or [liquidity pools](https://developers.stellar.org/docs/encyclopedia/liquidity-on-stellar). Both path payments and liquidity pools are constantly interacting with the SDEX. Indeed, every new path payment and liquidity pool operation can only happen because of existing order book offers or new user [swap requests](https://developers.stellar.org/docs/start/list-of-operations/#manage-sell-offer).

## Singel Exercution point

streamling also works for trading-history data, among other ledger updates. markets good xyz some industries,

Since all oreders for a currency pari fall into the same SDEX order book, you cna know that you're getting the best exchange rate between two explicit assets. Accordingly, you can analyze the past valuation of a currency by reading its exchanged trades feed. We'll continue our exmaple and set up a recent trading price query:

EX for the price query (getting best ex impl, see L72 at 9bc3c637047c8d1b010228d29876f2b92783074b):

<CodeExample>

```python
response = server.trades().for_asset_pair(astroPeso, astroDollar).call()

for trade in response['_embedded']['records']:
    price = int(trade['price_r']['n']) / int(trade['price_r']['d'])
    print(f"Trade ID: {trade['id']}, Price: {price}, Amount: {trade['base_amount']}")

```

```js
(async function () {
  const response = await server
    .trades()
    .forAssetPair(astroPeso, astroDollar)
    .call();

  response.records.forEach((trade) => {
    const price = parseInt(trade.price_r.n) / parseInt(trade.price_r.d);
    console.log(
      `Trade ID: ${trade.id}, Price: ${price}, Amount: ${trade.base_amount}`,
    );
  });
})();
```

```java
public static void main(String[] args) throws Exception {
  Page<TradeResponse> trades = server.trades()
    .forAssetPair(astroPeso, astroDollar)
    .execute();

  for (TradeResponse trade : trades.getRecords()) {
    double price = (double) trade.getPrice().getN() / trade.getPrice().getD();
    System.out.println("Trade ID: " + trade.getId() + ", Price: " + price + ", Amount: " + trade.getBaseAmount());
  }
}

```

```go
func main() {
  trades, err := server.Trades(horizonclient.TradeRequest{
    BaseAsset:    astroPeso,
    CounterAsset: astroDollar,
  })
  check(err)

  for _, trade := range trades.Embedded.Records {
    price := float64(trade.PriceR.N) / float64(trade.PriceR.D)
    fmt.Printf("Trade ID: %s, Price: %f, Amount: %s\n", trade.ID, price, trade.BaseAmount)
  }
}
```

</CodeExample>

When perfoming this anaylsis on live [mainnet](SRC_HRED_DOCS_MAONTEST,TESTNET agian i think) data, you will in all ikelihood see a combination of trading take place on top of the SDEX. The first, mst basic option, is when one new order crosses the price set by an outstanding order. The two instantly cross once the new order gets accepted, and the transaction generatesa taker `contraID` rather than an `offerID` for the "buyer" of othe existing liquditiy.

The other two optiosn are exchanges made using [path paymnets](SRC_PATHPATYMETS) or [liquidity tpools](SRC_LIQ_POOLS##). Both path payments and liqudiity pool s are consatntly interacting with the SDEX. Indeed, every new path payment and liquifity pool operation can only happen because of exiting order book offers or new user [swap requests](SRC_CREAte-SELL_OFF-liekly/). <!--- prob_move_todo --->

/P5

## Commingling and Interoperability

The SDEX facilitates seamless interoperability between different assets by combining orders in a unified order book. This design ensures that liquidity is concentrated, reducing spreads and improving execution for all participants.

(fn) Historical Performance [^hist-perf]

The SDEX has processed billions of trades across a dynamic range of assets, demonstrating its robustness and efficiency in facilitating decentralized trading. Its historical performance showcases the scalability and reliability of the Stellar network in handling large volumes of transactions.

## Access

### Order books

Stellar uses order books to operate its decentralized exchange.

An order book is a record of outstanding orders on a network, and each record sits between two assets (wheat and sheep, for example). The order book for this asset pair records every account wanting to sell wheat for sheep and every account wanting to sell sheep for wheat. In traditional finance, buying is expressed as a “bid” order, and selling is expressed as an “ask” order (ask orders are also called offers).

A couple of notes on order books on Stellar:

- The term “offers” usually refers specifically to ask orders. In Stellar, however, all orders are stored as selling&mdash;i.e., the system automatically converts bids to asks. Because of this, the terms “offer” and “order” are used interchangeably in the Stellar ecosystem.[^buys]
- Order books contain all orders that are acceptable to parties on either side to make a trade.
- Some assets will have a small or nonexistent order book between them. In these cases, Stellar facilitates path payments, which we’ll discuss later.

[^buys]: When you create a buy offer using the [`createBuyOffer`](../../../data/horizon/api-reference/resources/operations/object/buy-offer.mdx) operation, it is internally converted and stored as a sell offer.

To view an order book chart, see the [Order Book Wikipedia Page](https://en.wikipedia.org/wiki/Order_book). In addition, there are also plenty of video tutorials and articles out there that can help you understand how order books work in greater detail.

### Viewing Activity

#### Liquidity Pools

You can access the transactions, operations, and effects related to a liquidity pool if you want to track its activity. Let’s see how we can track the latest deposits in a pool (suppose `poolId` is defined as before):

<CodeExample>

```python
def watch_liquidity_pool_activity():
    for op in (
        server.operations()
        .for_liquidity_pool(liquidity_pool_id=pool_id)
        .cursor("now")
        .stream()
    ):
        if op["type"] == "liquidity_pool_deposit":
            print("Reserves deposited:")
            for r in op["reserves_deposited"]:
                print(f"    {r['amount']} of {r['asset']}")
            print(f"    for pool shares: {op['shares_received']}")
        # ...
```

```js
server
  .operations()
  .forLiquidityPool(poolId)
  .call()
  .then((ops) => {
    ops.records
      .filter((op) => op.type == "liquidity_pool_deposit")
      .forEach((op) => {
        console.log("Reserves deposited:");
        op.reserves_deposited.forEach((r) =>
          console.log(`    ${r.amount} of ${r.asset}`),
        );
        console.log("  for pool shares: ", op.shares_received);
      });
  });
```

```java

```

```go

```

</CodeExample>

### Orders (as offers... I recall some talk in a `go` thread about the syntax here in re simplification)

An account can create orders to buy or sell assets using the Manage Buy Offer, Manage Sell Offer, or Passive Order operations. The account must hold the asset it wants to exchange, and it must trust the issuer of the asset it is trying to buy.

Orders in Stellar behave like limit orders in traditional markets. When an account initiates an order, it is checked against the existing orderbook for that asset pair. If the submitted order is a marketable order (for a marketable buy limit order, the limit price is at or above the ask price; for a marketable sell limit order, the limit price is at or below the bid price), it is filled at the existing order price for the available quantity at that price. If the order is not marketable (i.e., does not cross an existing order), the order is saved on the orderbook until it is either consumed by another order, consumed by a path payment, or canceled by the account that created the order.

Each order constitutes a selling obligation for the selling asset and buying obligation for the buying asset. These obligations are stored in the account (for lumens) or trustline (for other assets) owned by the account creating the order. Any operation that would cause an account to be unable to satisfy its obligations — such as sending away too much balance — will fail. This guarantees that any order in the orderbook can be executed entirely.

Orders are executed on a price-time priority, meaning orders will be executed based first on price; for orders placed at the same price, the order that was entered earlier is given priority and is executed before the newer one.

#### Purchase Assets (Manage Buy Offer)

When creating a buy order in Stellar via the Manage Buy Offer operation, the price is specified as 1 unit of the base currency (the asset being bought), in terms of the quote asset (the asset that is being sold). For example, if you’re buying 100 XLM in exchange for 20 USD, you would specify the price as {20, 100}, which would be the equivalent of 5 XLM for 1 USD (or \$.20 per XLM).

#### Manage Sell Offer

When creating a sell order in Stellar via the Manage Sell Offer operation, the price is specified as 1 unit of base currency (the asset being sold), in terms of the quote asset (the asset that is being bought). For example, if you’re selling 100 XLM in exchange for 40 USD, you would specify the price as {40, 100}, which would be the equivalent of 2.5 XLM for 1 USD (or \$.40 per XLM).

#### Passive Order

Passive orders allow markets to have zero spread. If you want to exchange USD from anchor A for USD from anchor B at a 1:1 price, you can create two passive orders so the two orders don’t fill each other.

A passive order is an order that does not execute against a marketable counter order with the same price. It will only fill if the prices are not equal. For example, if the best order to buy BTC for XLM has a price of 100 XLM/BTC, and you make a passive offer to sell BTC at 100 XLM/BTC, your passive offer does not take that existing offer. If you instead make a passive offer to sell BTC at 99 XLM/BTC it would cross the existing offer and fill at 100 XLM/BTC. -tra->ast-

An account can place a passive sell order via the Create Passive Sell Offer operation.

### Price and operations

Each order in Stellar is quoted with an associated price and is represented as a ratio of the two assets in the order, one being the “quote asset” and the other being the “base asset”. This is to ensure there is no loss of precision when representing the price of the order (as opposed to storing the fraction as a floating-point number).

Prices are specified as a {`numerator`, `denominator`} pair with both components of the fraction represented as 32-bit signed integers. The numerator is considered the base asset, and the denominator is considered the quote asset. When expressing a price of “Asset A in terms of Asset B”, the amount of B is the denominator (and therefore the quote asset), and A is the numerator (and therefore the base asset). As a good rule of thumb, it’s generally correct to be thinking about the base asset that is being bought/sold (in terms of the quote asset).

(fn) Fees [^tx-stroop] ^works in core execution transaction uimopplementation

The order price you set is independent of the fee you pay for submitting that order in a transaction. Fees are always paid in XLM, and you specify them as a separate parameter when submitting the order to the network.

To learn more about transaction fees, see our section on [Fees section](../../fundamentals/fees-resource-limits-metering.mdx).

### Authorization

this lays it out for AMMs, but we need to first establish the secondary trading table for the SDEX intrxctions

Pool share trustlines cannot be authorized or de-authorized independently. Instead, the authorization of a pool share trustline is derived from the trustlines for the assets in the liquidity pool. This design is necessary because a liquidity pool may contain assets from two different issuers, and both issuers should have a say in whether the pool share trustline is authorized.

There are a few possibilities with regard to authorization. The behavior of the A-B pool share trustline is determined according to the following table:

:::danger duple/mv later

| SCENARIO | BEHAVIOR |
| --- | --- |
| Trustlines for A and B are fully authorized | No restrictions on deposit and withdrawal |
| Trustline for A is fully authorized but trustline for B is authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustline for B is fully authorized but trustline for A is authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustlines for A and B are authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustline for A is not authorized or doesn’t exist | Pool share trustline does not exist |
| Trustline for B is not authorized or doesn’t exist | Pool share trustline does not exist |

:::

If the issuer of A or B revokes authorization, then the account will automatically withdraw from every liquidity pool containing that asset and those pool share trustlines will be deleted. We say that these pool shares have been redeemed. For example, if the account participates in the A-B, A-C, and B-C liquidity pools and the issuer of A revokes authorization then the account will redeem from A-B and A-C but not B-C. For each redeemed pool share trustline, a Claimable Balance will be created for each asset contained in the pool if there is a balance being withdrawn and the redeemer is not the issuer of that asset. The claimant of the Claimable Balance will be the owner of the deleted pool share trustline, and the sponsor of the Claimable Balance will be the sponsor of the deleted pool share trustline. The BalanceID of each Claimable Balance is the SHA-256 hash of the `revokeID`.

### Operations

There are two operations that facilitate participation in a liquidity pool: `LiquidityPoolDeposit` and `LiquidityPoolWithdraw`. Use `LiquidityPoolDeposit` to start providing liquidity to the market. Use `LiquidityPoolWithdraw` to stop providing liquidity to the market.

However, users don’t need to participate in the pool to take advantage of what it’s offering: an easy way to exchange two assets. For that, just use `PathPaymentStrictReceive` or `PathPaymentStrictSend`. If your application is already using path payments, then you don’t need to change anything for users to take advantage of the prices available in liquidity pools.

### Order Book (prob earlier bnut need to handle auth 1st)

You can view trades occuring in the vanilla order book through a traditional [`time and sales`](https://remove-simplify.co) report.

<CodeExample>

```python

```

```js

```

```java

```

```go

```

</CodeExample>

/P6

/P7

## ~~Liquidity pools as AMMs~~

Liquidity pools enable automated market making on the Stellar network. Liquidity refers to how easily and cost-effectively one asset can be converted to another.

/P8

### Deterministic Pricing

Instead of relying on the buy and sell orders of decentralized exchanges, AMMs keep assets in an ecosystem liquid 24/7 using liquidity pools.

AMMs provide liquidity using a mathematical equation. AMMs hold two different assets in a liquidity pool, and the quantities of those assets (or reserves) are inputs for that equation (Asset A \* Asset B = k). If an AMM holds more of the reserve assets, the asset prices move less in response to a trade.

#### AMM pricing

AMMs are willing to make some trades and unwilling to make others. For example, if 1 EUR = 1.17 USD, then the AMM might be willing to sell 1 EUR for 1.18 USD and unwilling to sell 1 EUR for 1.16 USD. To determine what trades are acceptable, the AMM enforces an invariant. There are many possible invariants, and Stellar enforces a constant product invariant and so is known as a constant product market maker. This means that AMMs on Stellar must never allow the product of the reserves to decrease.

For example, suppose the current reserves in the liquidity pool are 1000 EUR and 1170 USD which implies a product of 1,170,000. Selling 1 EUR for 1.18 USD would be acceptable because that would leave reserves of 999 EUR and 1171.18 USD, which implies a product of 1,170,008.82. But selling 1 EUR for 1.16 USD would not be acceptable because that would leave reserves of 999 EUR and 1171.16 USD, which implies a product of 1,169,988.84.

AMMs decide exchange rates based on the ratio of reserves in the liquidity pool. If this ratio is different than the true exchange rate, arbitrageurs will come in and trade with the AMM at a favorable price. This arbitrage trade moves the ratio of the reserves back toward the true exchange rate.

AMMs charge fees on every trade, which is a fixed percentage of the amount bought by the AMM. For example, if an automated market maker sells 100 EUR for 118 USD then the fee is charged on the USD. The fee is 0.30%. If you actually wanted to make this trade, you would need to pay about 118.355 USD for 100 EUR. The automated market maker factors the fees into the constant product invariant, so in reality, the product of the reserves grows after every trade.

### Liquidity pool participation

Any eligible participant can deposit assets into a liquidity pool, and in return, receive pool shares representing their ownership of that asset. If there are 150 total pool shares and one user owns 30, they are entitled to withdraw 20% of the liquidity pool asset at any time.

Pool shares are similar to other assets on Stellar but they cannot be transferred. You can only increase the number of pool shares you hold by depositing into a liquidity pool with the `LiquidityPoolDespositOp` and decrease the number of pool shares you hold by withdrawing from a liquidity pool with `LiquidityPoolWithdrawOp`.

A pool share has two representations. The full representation is used with `ChangeTrustOp`, and the hashed representation is used in all other cases. When constructing the asset representation of a pool share, the assets must be in lexicographical order. For example, A-B is in the correct order but B-A is not. This results in a canonical representation of a pool share.

AMMs charge a fee on all trades and the participants in the liquidity pool receive a share of the fee proportional to their share of the assets in the liquidity pool. Participants collect these fees when they withdraw their assets from the pool. The [communitee agreed](https://groups.google.com/g/stellar-dev/c/Ofb2KXwzva0/m/kyYI8Es9AQAJ) on the current fixed rate of 0.30%, the fee used in UniswapV2. These charges are completely separate from the network fees.

### Trustlines

Users need to establish trustlines to three different assets to participate in a liquidity pool: both the reserve assets (unless one of them is XLM) and the pool share itself.

An account needs a trustline for every pool share it wants to own. It is not possible to deposit into a liquidity pool without a trustline for the corresponding pool share. Pool share trustlines differ from trustlines for other assets in a few ways:

1. A pool share trustline cannot be created unless the account already has trustlines that are authorized or authorized to maintain liabilities for the assets in the liquidity pool. See below for more information about how authorization impacts pool share trustlines.
2. A pool share trustline requires 2 base reserves instead of 1. For example, an account (2 base reserves) with a trustline for asset A (1 base reserve), a trustline for asset B (1 base reserve), and a trustline for the A-B pool share (2 base reserves) would have a reserve requirement of 6 base reserves.

## Preamble

Here we will cover basic liquidity pool participation and querying.

For all of the following examples, we’ll be working with three funded Testnet accounts. If you’d like to follow along, generate some keypairs and fund them via the friendbot.

The following code sets up the accounts and defines some helper functions. These should be familiar if you’ve played around with other examples like clawbacks.[^revoking]

[^revoking]: an asset trust line has its authorization revoked -> forces a redemption of all referenced pool trust lines //todo

<CodeExample>

```js
const sdk = require("stellar-sdk");
const BigNumber = require("bignumber.js");

let server = new sdk.Server("https://horizon-testnet.stellar.org");

/// Helps simplify creating & signing a transaction.
function buildTx(source, signer, ...ops) {
  let tx = new sdk.TransactionBuilder(source, {
    fee: sdk.BASE_FEE,
    networkPassphrase: sdk.Networks.TESTNET,
  });
  ops.forEach((op) => tx.addOperation(op));
  tx = tx.setTimeout(30).build();
  tx.sign(signer);
  return tx;
}

/// Returns the given asset pair in "protocol order."
function orderAssets(A, B) {
  return sdk.Asset.compare(A, B) <= 0 ? [A, B] : [B, A];
}

/// Returns all of the accounts we'll be using.
function getAccounts() {
  return Promise.all(kps.map((kp) => server.loadAccount(kp.publicKey())));
}

const kps = [
  "SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
  "SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
  "SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P",
].map((s) => sdk.Keypair.fromSecret(s));

// kp0 issues the assets
const kp0 = kps[0];
const [A, B] = orderAssets(
  ...[new sdk.Asset("A", kp0.publicKey()), new sdk.Asset("B", kp0.publicKey())],
);

/// Establishes trustlines and funds `recipientKps` for all `assets`.
function distributeAssets(issuerKp, recipientKps, ...assets) {
  return server.loadAccount(issuerKp.publicKey()).then((issuer) => {
    const ops = recipientKps
      .map((recipientKp) =>
        assets.map((asset) => [
          sdk.Operation.changeTrust({
            source: recipientKp.publicKey(),
            limit: "100000",
            asset: asset,
          }),
          sdk.Operation.payment({
            source: issuerKp.publicKey(),
            destination: recipientKp.publicKey(),
            amount: "100000",
            asset: asset,
          }),
        ]),
      )
      .flat(2);

    let tx = buildTx(issuer, issuerKp, ...ops);
    tx.sign(...recipientKps);
    return server.submitTransaction(tx);
  });
}

function preamble() {
  return distributeAssets(kp0, [kps[1], kps[2]], A, B);
}
```

```python
from decimal import Decimal
from typing import List, Any, Dict

from stellar_sdk import *

server = Server("https://horizon-testnet.stellar.org")


# quite rough draft here
def new_tx_builder(source: str) -> TransactionBuilder:
    network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE
    base_fee = 100
    source_account = server.load_account(source)
    builder = TransactionBuilder(
        source_account=source_account, network_passphrase=network_passphrase, base_fee=base_fee
    ).set_timeout(30)
    return builder


# Returns the given asset pair in "protocol order."
def order_asset(a: Asset, b: Asset) -> List[Asset]:
    return [a, b] if LiquidityPoolAsset.is_valid_lexicographic_order(a, b) else [b, a]


secrets = [
    "SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
    "SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
    "SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P",
]
kps = [Keypair.from_secret(secret=secret) for secret in secrets]

# kp0 issues the assets
kp0 = kps[0]
asset_a, asset_b = order_asset(Asset("A", kp0.public_key), Asset("B", kp0.public_key))


def distribute_assets(
        issuer_kp: Keypair, recipient_kp: Keypair, assets: List[Asset]
) -> Dict[str, Any]:
    builder = new_tx_builder(issuer_kp.public_key)
    for asset in assets:
        builder.append_change_trust_op(
            asset=asset, limit="100000", source=recipient_kp.public_key
        ).append_payment_op(
            destination=recipient_kp.public_key,
            asset=asset,
            amount="100000",
            source=issuer_kp.public_key,
        )

    tx = builder.build()
    tx.sign(issuer_kp)
    tx.sign(recipient_kp)
    resp = server.submit_transaction(tx)
    return resp


def preamble() -> None:
    resp1 = distribute_assets(kp0, kps[1], [asset_a, asset_b])
    resp2 = distribute_assets(kp0, kps[2], [asset_a, asset_b])
    # ...
```

</CodeExample>

Here, we use `distributeAssets()` to establish trustlines and set up initial balances of two custom assets (`A` and `B`, issued by `kp0`) for two accounts (`kp2` and `kp3`). For someone to participate in the pool, they must establish trustlines to each of the asset issuers and to the pool share asset (explained below).

:::danger TODO

Case when buying asset an asset, amount aquired > existing trustline amount.

:::

Note the `orderAssets()` helper here. Operations related to liquidity pools refer to the asset pair arbitrarily as `A` and `B`; however, they must be “ordered” such that `A` < `B`. This ordering is defined by the protocol, but its details should not be relevant (if you’re curious, it’s essentially lexicographically ordered by asset type, code, then issuer). We can use the comparison methods built into the SDKs (like `Asset.compare`) to ensure we pass them in the right order and avoid errors.

### AMMs

#### Participant Creation

First, let's create a liquidity pool for the asset pair defined in the preamble. This involves establishing a trustline to the pool itself:

<CodeExample>

```python
pool_share_asset = LiquidityPoolAsset(asset_a=asset_a, asset_b=asset_b)


def establish_pool_trustline(source: Keypair, pool_asset: LiquidityPoolAsset) -> Dict[str, Any]:
    tx = (
        new_tx_builder(source.public_key)
            .append_change_trust_op(asset=pool_asset, limit="100000")
            .build()
    )
    tx.sign(source)
    return server.submit_transaction(tx)
```

```js
const poolShareAsset = new sdk.LiquidityPoolAsset(
  A,
  B,
  sdk.LiquidityPoolFeeV18,
);

function establishPoolTrustline(account, keypair, poolAsset) {
  return server.submitTransaction(
    buildTx(
      account,
      keypair,
      sdk.Operation.changeTrust({
        asset: poolAsset,
        limit: "100000",
      }),
    ),
  );
}
```

```java

```

```go

```

</CodeExample>

This lets the participants hold pool shares, which means now they can perform deposits and withdrawals.

#### Participant Deposits

To work with a liquidity pool, you need to know its ID beforehand. It’s a deterministic value, and only a single liquidity pool can exist for a particular asset pair, so you can calculate it locally from the pool parameters.

<CodeExample>

```python
pool_id = pool_share_asset.liquidity_pool_id


def add_liquidity(
        source: Keypair,
        pool_id: str,
        max_reserve_a: Decimal,
        max_reserve_b: Decimal,
) -> dict[str, Any]:
    exact_price = max_reserve_a / max_reserve_b
    min_price = exact_price - exact_price * Decimal("0.1")
    max_price = exact_price + exact_price * Decimal("0.1")
    tx = (
        new_tx_builder(source.public_key)
            .append_liquidity_pool_deposit_op(
            liquidity_pool_id=pool_id,
            max_amount_a=f"{max_reserve_a:.7f}",
            max_amount_b=f"{max_reserve_b:.7f}",
            min_price=min_price,
            max_price=max_price,
        )
            .build()
    )
    tx.sign(source)
    return server.submit_transaction(tx)
```

```js
const poolId = sdk
  .getLiquidityPoolId(
    "constant_product",
    poolShareAsset.getLiquidityPoolParameters(),
  )
  .toString("hex");

function addLiquidity(source, signer, poolId, maxReserveA, maxReserveB) {
  const exactPrice = maxReserveA / maxReserveB;
  const minPrice = exactPrice - exactPrice * 0.1;
  const maxPrice = exactPrice + exactPrice * 0.1;

  return server.submitTransaction(
    buildTx(
      source,
      signer,
      sdk.Operation.liquidityPoolDeposit({
        liquidityPoolId: poolId,
        maxAmountA: maxReserveA,
        maxAmountB: maxReserveB,
        minPrice: minPrice.toFixed(7),
        maxPrice: maxPrice.toFixed(7),
      }),
    ),
  );
}
```

```java

```

```go

```

</CodeExample>

When depositing assets into a liquidity pool, you need to define your acceptable price bounds. In the above function, we allow for a +/-10% margin of error from the “spot price”. This margin is by no means a recommendation and is chosen just for demonstration.

Notice that we also specify the maximum amount of each reserve we’re willing to deposit. This, alongside the minimum and maximum prices, helps define boundaries for the deposit, since there can always be a change in the exchange rate between submitting the operation and it getting accepted by the network.

#### Calculating Price

:::danger TODO

Price improvement Only for initial placement Bias towards makers when best ex

:::

While the network automatically calulates the AMM price product, this does not show up in the order book itself per se. Rather, your order will execute strictly at the best avaliable limit offer or AMM rate. While limit orders specify volume, AMM prices actually vary in real time based on the pool size, which we can find:

<CodeExample>

```python

This proposal only introduces a constant product liquidity pool.
The invariant for such a liquidity pool is (X + x - Fx) (Y - y) >= XY

X and Y are the initial reserves of the liquidity pool
F is the fee charged by the liquidity pool
x is the amount received by the liquidity pool
y is the amount disbursed by the liquidity pool

import requests

def fetch_amm_pool_data(asset_1, asset_2):
    """
    Fetches AMM pool data from the Stellar Horizon API for a given asset pair.

    :param asset_1: The first asset (e.g., XLM).
    :param asset_2: The second asset (e.g., USD stablecoin).

    :return: Reserves of asset_1 and asset_2 in the AMM pool.
    """
    url = f"https://horizon.stellar.org/liquidity_pools?reserves={asset_1},{asset_2}"

    response = requests.get(url)
    if response.status_code != 200:
        raise Exception("Error fetching data from Horizon API")

    data = response.json()

    # Assuming we want the first AMM pool found
    pool_data = data['_embedded']['records'][0]

    # Extract reserves
    reserve_xlm = float(pool_data['reserves'][0]['amount'])  # XLM reserves
    reserve_usd = float(pool_data['reserves'][1]['amount'])  # USD reserves

    return reserve_xlm, reserve_usd

def amm_price_xlm_usd(reserve_xlm, reserve_usd, trade_usd, xlm_price_usd):
    """
    Calculate the price impact of a trade worth $100 of XLM using an AMM's constant product formula.

    :param reserve_xlm: Reserve of XLM in the pool.
    :param reserve_usd: Reserve of the other token (e.g., USD stablecoin) in the pool.
    :param trade_usd: The amount of USD equivalent to be traded.
    :param xlm_price_usd: Current price of XLM in USD (e.g., 0.12 for $0.12/XLM).

    :return: The price for the $100 trade in XLM.
    """
    # Convert the trade amount in USD to XLM based on the current market price
    dx = trade_usd / xlm_price_usd  # Amount of XLM to trade

    # Constant product invariant (x * y = k)
    k = reserve_xlm * reserve_usd

    # New XLM reserve after the trade
    new_reserve_xlm = reserve_xlm + dx

    # Calculate the new reserve of USD after the trade
    new_reserve_usd = k / new_reserve_xlm

    # Amount of USD received (dy)
    dy = reserve_usd - new_reserve_usd

    # Price of the trade in terms of USD received per XLM traded
    price = dy / dx

    return price

# Example: Fetch reserves and calculate price impact for $100 worth of XLM
if __name__ == "__main__":
    asset_1 = "XLM"  # Asset 1 (XLM)
    asset_2 = "USD"  # Asset 2 (USD stablecoin)

    # Fetch AMM pool reserves from Stellar Horizon API
    reserve_xlm, reserve_usd = fetch_amm_pool_data(asset_1, asset_2)

    # Define trade and market parameters
    trade_usd = 100       # Amount of USD equivalent to trade
    xlm_price_usd = 0.12  # Current price of XLM in USD

    # Calculate price impact for $100 worth of XLM
    price_impact = amm_price_xlm_usd(reserve_xlm, reserve_usd, trade_usd, xlm_price_usd)

    print(f"Reserves: {reserve_xlm} XLM, {reserve_usd} USD")
    print(f"Price for trading $100 worth of XLM is: {price_impact} USD per XLM")
```

```js

```

```java

```

```go

```

</CodeExample>

#### Participant Withdrawals

If you own shares of a particular pool, you can withdraw reserves from it. The operation structure mirrors the deposit closely:

<CodeExample>

```python
def remove_liquidity(
        source: Keypair, pool_id: str, shares_amount: Decimal
) -> dict[str, Any]:
    pool_info = server.liquidity_pools().liquidity_pool(pool_id).call()
    total_shares = Decimal(pool_info["total_shares"])
    min_reserve_a = (
            shares_amount
            / total_shares
            * Decimal(pool_info["reserves"][0]["amount"])
            * Decimal("0.95")
    ) #
    min_reserve_b = (
            shares_amount
            / total_shares
            * Decimal(pool_info["reserves"][1]["amount"])
            * Decimal("0.95")
    )
    tx = (
        new_tx_builder(source.public_key)
            .append_liquidity_pool_withdraw_op(
            liquidity_pool_id=pool_id,
            amount=f"{shares_amount:.7f}",
            min_amount_a=f"{min_reserve_a:.7f}",
            min_amount_b=f"{min_reserve_b:.7f}",
        )
            .build()
    )
    tx.sign(source)
    return server.submit_transaction(tx)
```

```js
function removeLiquidity(source, signer, poolId, sharesAmount) {
  return server
    .liquidityPools()
    .liquidityPoolId(poolId)
    .call()
    .then((poolInfo) => {
      let totalShares = poolInfo.total_shares;
      let minReserveA =
        (sharesAmount / totalShares) * poolInfo.reserves[0].amount * 0.95;
      let minReserveB =
        (sharesAmount / totalShares) * poolInfo.reserves[1].amount * 0.95;

      return server.submitTransaction(
        buildTx(
          source,
          signer,
          sdk.Operation.liquidityPoolWithdraw({
            liquidityPoolId: poolId,
            amount: sharesAmount,
            minAmountA: minReserveA.toFixed(7),
            minAmountB: minReserveB.toFixed(7),
          }),
        ),
      );
    });
}
```

```java

```

```go

```

</CodeExample>

Notice here that we specify the minimum amount. Much like with a strict-receive path payment, we’re specifying that we’re not willing to receive less than this amount of each asset from the pool. This effectively defines a minimum withdrawal price.

#### Putting it all together

Finally, we can combine these pieces together to simulate some participation in a liquidity pool. We’ll have everyone deposit increasing amounts into the pool, then one participant withdraws their shares. Between each step, we’ll retrieve the spot price.

<CodeExample>

```python
def main():
    deposit_a = Decimal(1000)
    deposit_b = Decimal(3000)  # maintain a 1:3 ratio
    establish_pool_trustline(kps[1], pool_share_asset)
    add_liquidity(kps[1], pool_id, deposit_a, deposit_b)
    get_spot_price()

    deposit_a = Decimal(2000)
    deposit_b = Decimal(6000)  # maintain a 1:3 ratio
    establish_pool_trustline(kps[2], pool_share_asset)
    add_liquidity(kps[2], pool_id, deposit_a, deposit_b)
    get_spot_price()

    # kp1 takes all his/her shares out
    balance = 0
    for b in server.accounts().account_id(kps[1].public_key).call()["balances"]:
        if (
                b["asset_type"] == "liquidity_pool_shares"
                and b["liquidity_pool_id"] == pool_id
        ):
            balance = Decimal(b["balance"])
            break
    if not balance:
        raise
    remove_liquidity(kps[1], pool_id, balance)
    get_spot_price()

def get_spot_price():
    resp = server.liquidity_pools().liquidity_pool(pool_id).call()
    amount_a = resp["reserves"][0]["amount"]
    amount_b = resp["reserves"][1]["amount"]
    spot_price = Decimal(amount_a) / Decimal(amount_b)
    print(f"Price: {amount_a}/{amount_b} = {spot_price:.7f}")

if __name__ == '__main__':
    preamble()
    main()
```

```js
function main() {
  return getAccounts()
    .then((accounts) => {
      return Promise.all(
        kps.map((kp, i) => {
          const acc = accounts[i];
          const depositA = ((i + 1) * 1000).toString();
          const depositB = ((i + 1) * 3000).toString(); // maintain a 1:3 ratio

          return establishPoolTrustline(acc, kp, poolShareAsset)
            .then(() => addLiquidity(acc, kp, poolId, depositA, depositB))
            .then(() => getSpotPrice());
        }),
      ).then(() => accounts);
    })
    .then((accounts) => {
      // kp1 takes all his/her shares out
      return server
        .accounts()
        .accountId(kps[1].publicKey())
        .call()
        .then(({ balances }) => {
          let balance = 0;
          balances.every((bal) => {
            if (
              bal.asset_type === "liquidity_pool_shares" &&
              bal.liquidity_pool_id === poolId
            ) {
              balance = bal.balance;
              return false;
            }
            return true;
          });
          return balance;
        })
        .then((balance) =>
          removeLiquidity(accounts[1], kps[1], poolId, balance),
        );
    })
    .then(() => getSpotPrice());
}

function getSpotPrice() {
  return server
    .liquidityPools()
    .liquidityPoolId(poolId)
    .call()
    .then((pool) => {
      const [a, b] = pool.reserves.map((r) => r.amount);
      const spotPrice = new BigNumber(a).div(b);
      console.log(`Price: ${a}/${b} = ${spotPrice.toFormat(2)}`);
    });
}

preamble().then(main);
```

```java

```

```go

```

</CodeExample>

:::info (mv) Background spread accumulation

Minor context around shared distrubtions, href to xdr but on the horizon side would prob be best for simplcity

:::

/P9

/P10

:::note Interleaved Execution

move this whle thing into a sentence or two very lightly implicating 1558

generally assign the cap 38 conductive proof https://github.com/stellar/stellar-protocol/blob/d9828da15348d5b997ede8bca5f13d2c1f518247/core/cap-0038.md?plain=1#L1334

Both the order book and AMMs coexist, providing multiple avenues for liquidity. both the traditional order book (with limit orders) and the AMMs work together seamlessly. When a trade is initiated, instead of having to choose whether to go through the order book or an AMM, the system would automatically check both sources of liquidity and execute the trade using whichever offers the best rate.

:::

### Others starting at required preamble from L587 in 9bc3c637047c8d1b010228d29876f2b92783074b

implicate base fee re `std` syntax

:::danger

requisites standardizing the fee treatment in #1044

:::
