WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
All right. I'll get started. I welcome everyone to today's protocol meeting where we'll be discussing some recent changes to two core advancement proposals cap 63 and 67. So first I'll start with some se several cap 67 updates. the first one is that we emit the set authorized event to give the unified events parody with the Stellar asset contract. there's also a change specified that the inflation operation will emit a mint event for each each payout. there's also a change to prohibit mox source accounts and memos for Soroban transactions and the this is because like so the the mox source is because like so the mox source we're prohibiting the mox source to avoid any confusion confusion on events avoid any confusion on events and that along with the memos are not signed in the o payload. So we're just prohibiting them altogether. there's also a change to have all diagnostics live in the single transaction level

00:01:00.000 --> 00:01:59.999 align:start position:0%
vector and remove the operation specific diagnostics vector that cap 67 originally originally implemented. and we also added the emu account support that we discussed at the last protocol meeting and all these changes can be in the cap 67 link can be seen in the cap 67 link that I shared below. and the last change is that it's not a change, it's more of a detail that we will discuss in this meeting which is that there's no specific event for fee refunds. and this it's conflated to the fee event. And And this is related to the cap 63 change that I I'll discuss in a moment. But before I move on, does anyone have any questions? All right. Then then I'll move on to the the cap 63 change. One move on to the cap 63 change. One sec. Can can everyone hear

00:02:00.000 --> 00:02:59.999 align:start position:0%
me? Okay. Yeah. Then yeah, I'll move on to the cap 63 change. which is the a change to apply the fee refunds after all Soroban transactions have been applied instead of after each transaction like it is today. so we this this was done because the fee source is not part of the footprint and this is an issue because it's possible for that same account to be used in a Soroban transaction. So if you apply transactions in parallel you would need to make sure that the fee source doesn't conflict the the the refund doesn't conflict with a different doesn't conflict with a different transaction that modifies the ex the native excellent balance of an account. so we had two options here. You would either need to make the fee source an implicit number of the read-write footprint or we just changed how refunds are are applied and apply them refunds are applied and apply them after all store run transactions have been applied and we decided that applying the refunds later made more

00:03:00.000 --> 00:03:59.999 align:start position:0%
sense. That's what cap 67 cap 63 went with. And the relevant cap 67 topic to discuss here is that the refund is conflated into the fee event. So this is fine if the goal is to just track balances at the end of every ledger. But if a user wants to infer anything related to balances in a ledger or in a transaction then this can be an issue. because imagine that you have a contract as a example Lee mentioned. you have a contract where it the contract does an action based off an account falling below a certain balance because the fee was charged to that account. but if we emit the the fee account. but if we emit the fee as the fee plus refund when you look at the events later on like for example if you're doing an audit you will never see that the account dropped below that balance that the account triggered on

00:04:00.000 --> 00:04:59.999 align:start position:0%
that the contract triggered on. so this is an edge case and I'm not sure if this like something we can discuss is if this use case actually matters. but the alternative would be to maybe emit a a separate refund event. But we emit a separate refund event. But we actually open up another can of worms here which is that if you're the fees are applied all fees are applied before are charged before the the operations are charged before the operations are applied. So you would need to make convey the information about the ordering in which the balances change in the events and currently the events are just a transaction level vector and an operation level vector but we would need to we might need to make some changes where the structure that's in TX meta which is you have the you have everything that happens pre-apply everything that happens during transaction application and everything that happens post transaction application. we need to convey that same information in the events and we should and if we do need this

00:05:00.000 --> 00:05:59.999 align:start position:0%
granularity that might be the path to take. so so yeah if does anyone take. so yeah if does anyone have any questions about this or or have have any questions about this or have any input? what I wanted to tell is that like we don't have many people today. and we also don't have Lee and we don't have Nico and others. So I mean you definitely could listen to what folks who are present think but yeah sounds like I can afford just yeah exactly yeah I'm inclined myself to just not do anything and just clarify in the cap that events should not be used for modeling the exact balances during the ledger application time because fees are in general charged at different points in time.

00:06:00.000 --> 00:06:59.999 align:start position:0%
, okay. Here's Nicholas. Nicholas., yeah, it seems to me like that's the thing to do here and if someone has objections, you can discuss them async. yeah because otherwise we would introduce a lot of structural complexity in meta for meta in events and we wanted events to be rather simple to consume and hopefully the consumers of events not worry about just reor operation but yeah that's my take on this Yeah. Yeah. I agree. I the use cases we've Yeah. I agree. I the use cases we've discussed with rel in relation to cap 67 tend to be for just tracking balances

00:07:00.000 --> 00:07:59.999 align:start position:0%
which seems like you know tracking you updating your balance at the end of every ledger is what what the end of every ledger is what this was designed for. And if you this was designed for. And if you want to use this for if you when you do anything related to like audits or anything more granular, I feel like TX meta should be enough. and making this system more complicated to handle those use cases doesn't seem to to be those use cases doesn't seem to be the right right move here. So I the right move here. So I agree with you. Yeah. Yeah. Exactly. And agree with you. Yeah. Exactly. And I guess the bottom line here is that like even though the effects are when the ledger has been applied, you still get the correct value for transaction. It just applied at different points in time, but then when you're looking at transaction events, you'll still get the correct key charge that corresponds to what happened in reality., you just don't know the exact details when exactly has been charged. So,, hopefully for most intense purposes, please. So yeah, I I

00:08:00.000 --> 00:08:59.999 align:start position:0%
intense purposes, please. So yeah, I guess we can write this up and update the cap and yeah, we can update the cap and respond in that thread. Okay. Does anyone else have any Okay. Does anyone else have any input? We have a small group today. so unless anyone has any any other so unless anyone has any other questions, we can probably call it early. All right. Well, it was a quick one today. Thank you for joining and yeah, thanks Nemo for your input. All right. See you.