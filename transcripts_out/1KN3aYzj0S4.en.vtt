WEBVTT
Kind: captions
Language: en

00:00:01.800 --> 00:00:05.090 align:start position:0%
okay I think we have like a couple of things on the agenda so

00:00:05.100 --> 00:00:05.690 align:start position:0%
things on the agenda so

00:00:09.000 --> 00:00:10.190 align:start position:0%
I think the first one was around

00:00:10.200 --> 00:00:11.450 align:start position:0%
around please

00:00:11.460 --> 00:00:14.089 align:start position:0%
please to kind of give a quick update of on

00:00:14.099 --> 00:00:16.369 align:start position:0%
to kind of give a quick update of on where we are and then

00:00:16.379 --> 00:00:19.370 align:start position:0%
where we are and then and then like we have a follow-up

00:00:19.380 --> 00:00:20.029 align:start position:0%
and then like we have a follow-up

00:00:23.939 --> 00:00:28.550 align:start position:0%
discussions on the archiving work that Garen has been working on

00:00:31.560 --> 00:00:35.030 align:start position:0%
maybe I can start with yeah face given that this is like a quick thing

00:00:37.440 --> 00:00:40.310 align:start position:0%
so yeah so like we have we started to kind of go back to the that fee

00:00:40.320 --> 00:00:42.830 align:start position:0%
to kind of go back to the that fee cap that I was looking at the draft

00:00:42.840 --> 00:00:45.110 align:start position:0%
cap that I was looking at the draft it was first put together end of June

00:00:45.120 --> 00:00:47.690 align:start position:0%
it was first put together end of June last year so it has been sitting

00:00:47.700 --> 00:00:51.950 align:start position:0%
last year so it has been sitting accumulating dust for a long time and

00:00:51.960 --> 00:00:53.990 align:start position:0%
accumulating dust for a long time and yeah so we're actually like looking into

00:00:54.000 --> 00:00:55.790 align:start position:0%
yeah so we're actually like looking into this again

00:00:55.800 --> 00:00:58.270 align:start position:0%
this again we started a

00:00:58.280 --> 00:01:02.270 align:start position:0%
we started a by doing a couple things so first one

00:01:02.280 --> 00:01:03.580 align:start position:0%
by doing a couple things so first one was around

00:01:03.590 --> 00:01:03.950 align:start position:0%
was around [Music]

00:01:03.960 --> 00:01:04.810 align:start position:0%
[Music]

00:01:07.920 --> 00:01:10.070 align:start position:0%
refreshing the the cap to reflect as much as possible where we left it

00:01:10.080 --> 00:01:12.170 align:start position:0%
as much as possible where we left it where it left things off in the on the

00:01:12.180 --> 00:01:13.730 align:start position:0%
where it left things off in the on the mailing list

00:01:13.740 --> 00:01:16.789 align:start position:0%
mailing list there's plenty of still of open

00:01:16.799 --> 00:01:18.109 align:start position:0%
there's plenty of still of open questions

00:01:18.119 --> 00:01:21.649 align:start position:0%
questions and yeah we're going to go over that

00:01:21.659 --> 00:01:24.770 align:start position:0%
and yeah we're going to go over that I think the other thing was that we

00:01:24.780 --> 00:01:30.170 align:start position:0%
I think the other thing was that we started a thread on this code on the

00:01:30.180 --> 00:01:32.149 align:start position:0%
started a thread on this code on the channels

00:01:32.159 --> 00:01:33.710 align:start position:0%
channels so

00:01:33.720 --> 00:01:35.569 align:start position:0%
so yeah at this point it's more like yeah

00:01:35.579 --> 00:01:37.130 align:start position:0%
yeah at this point it's more like yeah we need to go through

00:01:37.140 --> 00:01:39.830 align:start position:0%
we need to go through and iterate on this before we can

00:01:39.840 --> 00:01:43.490 align:start position:0%
and iterate on this before we can give more updates on on what's going to

00:01:43.500 --> 00:01:46.010 align:start position:0%
give more updates on on what's going to be next on the on the feed front and

00:01:46.020 --> 00:01:47.870 align:start position:0%
be next on the on the feed front and basically like the yeah what we're

00:01:47.880 --> 00:01:49.730 align:start position:0%
basically like the yeah what we're realizing is that there are a lot of

00:01:49.740 --> 00:01:51.230 align:start position:0%
realizing is that there are a lot of things that we didn't incorporate yet

00:01:51.240 --> 00:01:52.789 align:start position:0%
things that we didn't incorporate yet like there are

00:01:52.799 --> 00:01:55.130 align:start position:0%
like there are you know this was written before we had

00:01:55.140 --> 00:01:57.530 align:start position:0%
you know this was written before we had for example the pre-flight

00:01:57.540 --> 00:02:01.429 align:start position:0%
for example the pre-flight in the picture things like that so

00:02:01.439 --> 00:02:03.530 align:start position:0%
in the picture things like that so yeah there will be a

00:02:03.540 --> 00:02:05.630 align:start position:0%
yeah there will be a for sure a little more a few more

00:02:05.640 --> 00:02:08.029 align:start position:0%
for sure a little more a few more changes that need to have to be done

00:02:08.039 --> 00:02:10.969 align:start position:0%
changes that need to have to be done but that's kind of what we are with

00:02:10.979 --> 00:02:13.369 align:start position:0%
but that's kind of what we are with this not everyone to kind of spend

00:02:13.379 --> 00:02:16.250 align:start position:0%
this not everyone to kind of spend more time on this just like you know

00:02:16.260 --> 00:02:19.550 align:start position:0%
more time on this just like you know I'm inviting people to

00:02:19.560 --> 00:02:21.650 align:start position:0%
I'm inviting people to to kind of follow the conversations

00:02:21.660 --> 00:02:23.630 align:start position:0%
to kind of follow the conversations and

00:02:23.640 --> 00:02:25.010 align:start position:0%
and yeah

00:02:25.020 --> 00:02:27.949 align:start position:0%
yeah talk about and maybe help on you know

00:02:27.959 --> 00:02:31.430 align:start position:0%
talk about and maybe help on you know helping us making decisions on this one

00:02:31.440 --> 00:02:35.690 align:start position:0%
helping us making decisions on this one do we maybe want to keep a free high

00:02:35.700 --> 00:02:38.630 align:start position:0%
do we maybe want to keep a free high level overview of what is there and you

00:02:38.640 --> 00:02:40.970 align:start position:0%
level overview of what is there and you know what are the open questions we are

00:02:40.980 --> 00:02:43.850 align:start position:0%
know what are the open questions we are trying to solve a recent page let's

00:02:43.860 --> 00:02:46.910 align:start position:0%
trying to solve a recent page let's spend more time on the archival

00:02:46.920 --> 00:02:49.970 align:start position:0%
spend more time on the archival proposal

00:02:52.200 --> 00:02:54.530 align:start position:0%
yeah I think that yeah like so I guess yeah good good point like the type of

00:02:54.540 --> 00:02:56.509 align:start position:0%
yeah good good point like the type of things we are trying to

00:02:56.519 --> 00:02:58.190 align:start position:0%
things we are trying to

00:03:00.480 --> 00:03:01.509 align:start position:0%
big issues I would say that we need to

00:03:01.519 --> 00:03:05.750 align:start position:0%
to to kind of converge on on the feed

00:03:05.760 --> 00:03:07.430 align:start position:0%
to kind of converge on on the feed front is

00:03:07.440 --> 00:03:11.690 align:start position:0%
front is on what type of experience we want to

00:03:11.700 --> 00:03:14.330 align:start position:0%
on what type of experience we want to expose to contract developers when it

00:03:14.340 --> 00:03:17.890 align:start position:0%
expose to contract developers when it comes to the different markets that that

00:03:17.900 --> 00:03:20.570 align:start position:0%
comes to the different markets that that exist in the system

00:03:20.580 --> 00:03:23.210 align:start position:0%
exist in the system so we have the different resource

00:03:23.220 --> 00:03:26.330 align:start position:0%
so we have the different resource types we have a

00:03:26.340 --> 00:03:29.750 align:start position:0%
types we have a Ledger space we have a compute so

00:03:29.760 --> 00:03:33.610 align:start position:0%
Ledger space we have a compute so like when when transactions execute

00:03:33.620 --> 00:03:38.270 align:start position:0%
like when when transactions execute we have a network bandwidth and NBS I

00:03:38.280 --> 00:03:39.890 align:start position:0%
we have a network bandwidth and NBS I think in terms of C markets that's

00:03:39.900 --> 00:03:41.930 align:start position:0%
think in terms of C markets that's Canada we have other things that are

00:03:41.940 --> 00:03:44.869 align:start position:0%
Canada we have other things that are related more to external systems so like

00:03:44.879 --> 00:03:48.050 align:start position:0%
related more to external systems so like when people for example

00:03:48.060 --> 00:03:49.850 align:start position:0%
when people for example

00:03:53.400 --> 00:03:57.110 align:start position:0%
produce metadata that then then gets consumed by systems like horizon or

00:03:57.120 --> 00:04:00.530 align:start position:0%
consumed by systems like horizon or sort of an OPC or yeah like still are

00:04:00.540 --> 00:04:03.050 align:start position:0%
sort of an OPC or yeah like still are expert in red like uses this kind of

00:04:03.060 --> 00:04:06.710 align:start position:0%
expert in red like uses this kind of of a data stream so like making it that

00:04:06.720 --> 00:04:09.110 align:start position:0%
of a data stream so like making it that people can just

00:04:09.120 --> 00:04:12.589 align:start position:0%
people can just spam those other systems is is part of

00:04:12.599 --> 00:04:14.990 align:start position:0%
spam those other systems is is part of the you know in school for for the the

00:04:15.000 --> 00:04:17.090 align:start position:0%
the you know in school for for the the fee schedule

00:04:17.100 --> 00:04:19.909 align:start position:0%
fee schedule and then what did I forget oh yeah

00:04:19.919 --> 00:04:22.430 align:start position:0%
and then what did I forget oh yeah we have also archives what has

00:04:22.440 --> 00:04:24.170 align:start position:0%
we have also archives what has basically answered

00:04:24.180 --> 00:04:25.129 align:start position:0%
basically answered

00:04:27.240 --> 00:04:29.150 align:start position:0%
mandatory right like published to those history archives

00:04:29.160 --> 00:04:31.850 align:start position:0%
those history archives so making sure so that people don't use

00:04:31.860 --> 00:04:35.090 align:start position:0%
so making sure so that people don't use that as they are alternative to

00:04:35.100 --> 00:04:37.670 align:start position:0%
that as they are alternative to S3 or you know like

00:04:37.680 --> 00:04:40.070 align:start position:0%
S3 or you know like other places that you know when people

00:04:40.080 --> 00:04:42.050 align:start position:0%
other places that you know when people can store data if they want want to the

00:04:42.060 --> 00:04:43.550 align:start position:0%
can store data if they want want to the difference here is that those history

00:04:43.560 --> 00:04:45.710 align:start position:0%
difference here is that those history archives are

00:04:45.720 --> 00:04:46.550 align:start position:0%
archives are

00:04:49.740 --> 00:04:52.610 align:start position:0%
romantic analysis forever after so there are some constraints there

00:04:52.620 --> 00:04:54.590 align:start position:0%
are some constraints there and yeah so like the type of problems

00:04:54.600 --> 00:04:58.129 align:start position:0%
and yeah so like the type of problems around those this the the model

00:04:58.139 --> 00:05:01.129 align:start position:0%
around those this the the model for fees is how do we make it that we

00:05:01.139 --> 00:05:05.689 align:start position:0%
for fees is how do we make it that we can balance usability so right now you

00:05:05.699 --> 00:05:07.790 align:start position:0%
can balance usability so right now you know people used to do the classic

00:05:07.800 --> 00:05:10.430 align:start position:0%
know people used to do the classic system they have

00:05:10.440 --> 00:05:12.350 align:start position:0%
system they have a very simple way to think about things

00:05:12.360 --> 00:05:15.350 align:start position:0%
a very simple way to think about things basically you have a base fee for one

00:05:15.360 --> 00:05:18.050 align:start position:0%
basically you have a base fee for one operation if your transaction contains

00:05:18.060 --> 00:05:20.689 align:start position:0%
operation if your transaction contains more than one you just multiply and

00:05:20.699 --> 00:05:23.390 align:start position:0%
more than one you just multiply and that's kind of your your base in a way

00:05:23.400 --> 00:05:26.210 align:start position:0%
that's kind of your your base in a way to kind of think think about the you

00:05:26.220 --> 00:05:28.370 align:start position:0%
to kind of think think about the you know in terms of fee and if you want to

00:05:28.380 --> 00:05:30.950 align:start position:0%
know in terms of fee and if you want to get ahead of other transactions on the

00:05:30.960 --> 00:05:32.890 align:start position:0%
get ahead of other transactions on the network for whatever reason

00:05:32.900 --> 00:05:35.570 align:start position:0%
network for whatever reason it just increase your your feeling

00:05:35.580 --> 00:05:37.249 align:start position:0%
it just increase your your feeling that's kind of it right

00:05:37.259 --> 00:05:38.029 align:start position:0%
that's kind of it right

00:05:39.720 --> 00:05:42.350 align:start position:0%
and in soroban like the

00:05:42.360 --> 00:05:44.330 align:start position:0%
in soroban like the because of the competition between those

00:05:44.340 --> 00:05:45.290 align:start position:0%
because of the competition between those different

00:05:45.300 --> 00:05:46.610 align:start position:0%
different

00:05:49.860 --> 00:05:51.670 align:start position:0%
resource types that are open-ended right in terms of

00:05:51.680 --> 00:05:54.590 align:start position:0%
in terms of consumption and competition so

00:05:54.600 --> 00:05:56.749 align:start position:0%
consumption and competition so yeah we're going to need

00:05:56.759 --> 00:05:58.390 align:start position:0%
yeah we're going to need something a little bit better than that

00:05:58.400 --> 00:06:01.550 align:start position:0%
something a little bit better than that I mean like they're they're like in

00:06:01.560 --> 00:06:03.170 align:start position:0%
I mean like they're they're like in places like in

00:06:03.180 --> 00:06:05.990 align:start position:0%
places like in you know Italian they have

00:06:06.000 --> 00:06:08.689 align:start position:0%
you know Italian they have you know a version of what you can do

00:06:08.699 --> 00:06:11.510 align:start position:0%
you know a version of what you can do do with these so this is a

00:06:11.520 --> 00:06:16.490 align:start position:0%
do with these so this is a single fee for for everything

00:06:16.500 --> 00:06:19.070 align:start position:0%
single fee for for everything there are like proposals to make it

00:06:19.080 --> 00:06:22.850 align:start position:0%
there are like proposals to make it maybe okay it comes to

00:06:22.860 --> 00:06:23.749 align:start position:0%
maybe okay it comes to

00:06:27.300 --> 00:06:30.050 align:start position:0%
to different resource types but that's nothing yet in Italian it is implemented

00:06:30.060 --> 00:06:33.890 align:start position:0%
nothing yet in Italian it is implemented in other on cases like polkadot I think

00:06:33.900 --> 00:06:35.090 align:start position:0%
in other on cases like polkadot I think [Music]

00:06:35.100 --> 00:06:37.490 align:start position:0%
[Music] but yeah that's why we are kind of

00:06:37.500 --> 00:06:38.749 align:start position:0%
but yeah that's why we are kind of trying to get

00:06:38.759 --> 00:06:43.010 align:start position:0%
trying to get something usable

00:06:44.100 --> 00:06:44.629 align:start position:0%
okay

00:06:46.620 --> 00:06:48.710 align:start position:0%
I think that's kind of what I wanted to talk about on the feed from just you

00:06:48.720 --> 00:06:51.430 align:start position:0%
talk about on the feed from just you know heads up it's coming

00:06:51.440 --> 00:06:54.409 align:start position:0%
know heads up it's coming let's see and yeah we have the next

00:06:54.419 --> 00:06:56.930 align:start position:0%
let's see and yeah we have the next guarant that I think wanted to give us a

00:06:56.940 --> 00:06:59.150 align:start position:0%
guarant that I think wanted to give us a little more updates on last time there

00:06:59.160 --> 00:07:01.249 align:start position:0%
little more updates on last time there was like we started to talk about the

00:07:01.259 --> 00:07:03.010 align:start position:0%
was like we started to talk about the archive

00:07:03.020 --> 00:07:06.409 align:start position:0%
archive mechanism that allows to to save space

00:07:06.419 --> 00:07:08.870 align:start position:0%
mechanism that allows to to save space on the on the Ledger

00:07:08.880 --> 00:07:11.350 align:start position:0%
on the on the Ledger so that we can keep the network

00:07:11.360 --> 00:07:14.809 align:start position:0%
so that we can keep the network as cheap as as possible

00:07:14.819 --> 00:07:18.650 align:start position:0%
as cheap as as possible and I think there were a few

00:07:18.660 --> 00:07:21.050 align:start position:0%
and I think there were a few interesting follow-up conversations that

00:07:21.060 --> 00:07:24.469 align:start position:0%
interesting follow-up conversations that also happen after that in this Garden

00:07:24.479 --> 00:07:26.689 align:start position:0%
also happen after that in this Garden of this goal so

00:07:26.699 --> 00:07:29.689 align:start position:0%
of this goal so Aaron and give us maybe a

00:07:29.699 --> 00:07:32.570 align:start position:0%
Aaron and give us maybe a little a few updates on what's going on

00:07:32.580 --> 00:07:34.370 align:start position:0%
little a few updates on what's going on there

00:07:34.380 --> 00:07:37.129 align:start position:0%
there yeah so I guess first I want to talk a

00:07:37.139 --> 00:07:38.809 align:start position:0%
yeah so I guess first I want to talk a little or just have some time for

00:07:38.819 --> 00:07:41.150 align:start position:0%
little or just have some time for questions about the interface that we

00:07:41.160 --> 00:07:43.249 align:start position:0%
questions about the interface that we talked about last week and so kind of

00:07:43.259 --> 00:07:44.510 align:start position:0%
talked about last week and so kind of just like a high level summary of what

00:07:44.520 --> 00:07:47.210 align:start position:0%
just like a high level summary of what we went over last time is essentially

00:07:47.220 --> 00:07:51.170 align:start position:0%
we went over last time is essentially all sort of on data has this rent fee

00:07:51.180 --> 00:07:52.670 align:start position:0%
all sort of on data has this rent fee and this rent balance

00:07:52.680 --> 00:07:54.890 align:start position:0%
and this rent balance and so every Ledger or periodically

00:07:54.900 --> 00:07:56.930 align:start position:0%
and so every Ledger or periodically you have to pay rent for keeping an

00:07:56.940 --> 00:07:59.629 align:start position:0%
you have to pay rent for keeping an entry live on The Ledger and then

00:07:59.639 --> 00:08:01.610 align:start position:0%
entry live on The Ledger and then whenever an entry runs out of its rent

00:08:01.620 --> 00:08:03.290 align:start position:0%
whenever an entry runs out of its rent balance it could still be in from The

00:08:03.300 --> 00:08:05.809 align:start position:0%
balance it could still be in from The Ledger and then sent to the archive and

00:08:05.819 --> 00:08:07.969 align:start position:0%
Ledger and then sent to the archive and so with that interface we've kind of

00:08:07.979 --> 00:08:09.710 align:start position:0%
so with that interface we've kind of exposed three different classes of

00:08:09.720 --> 00:08:12.170 align:start position:0%
exposed three different classes of storage these kind of three different

00:08:12.180 --> 00:08:14.749 align:start position:0%
storage these kind of three different types of storage replace today what

00:08:14.759 --> 00:08:16.909 align:start position:0%
types of storage replace today what is currently the storage layer which is

00:08:16.919 --> 00:08:19.070 align:start position:0%
is currently the storage layer which is like end dot storage in your smart

00:08:19.080 --> 00:08:21.230 align:start position:0%
like end dot storage in your smart contract code and so with these three

00:08:21.240 --> 00:08:23.930 align:start position:0%
contract code and so with these three types of storage Ares we have a unique

00:08:23.940 --> 00:08:26.570 align:start position:0%
types of storage Ares we have a unique storage which is there's only ever one

00:08:26.580 --> 00:08:29.029 align:start position:0%
storage which is there's only ever one version of the entry that exists the

00:08:29.039 --> 00:08:30.650 align:start position:0%
version of the entry that exists the entry either exists on the bucket list

00:08:30.660 --> 00:08:32.149 align:start position:0%
entry either exists on the bucket list or there's a single version of that

00:08:32.159 --> 00:08:34.790 align:start position:0%
or there's a single version of that entry on the archive but never both

00:08:34.800 --> 00:08:38.269 align:start position:0%
entry on the archive but never both and this is useful for types of data

00:08:38.279 --> 00:08:40.190 align:start position:0%
and this is useful for types of data that have security concerns such as

00:08:40.200 --> 00:08:42.110 align:start position:0%
that have security concerns such as nonsense or certain types of

00:08:42.120 --> 00:08:44.029 align:start position:0%
nonsense or certain types of authorization where there could be

00:08:44.039 --> 00:08:46.610 align:start position:0%
authorization where there could be security risks and issues if you have

00:08:46.620 --> 00:08:49.610 align:start position:0%
security risks and issues if you have multiple versions of that entry that

00:08:49.620 --> 00:08:52.009 align:start position:0%
multiple versions of that entry that could be restored kind of the the use

00:08:52.019 --> 00:08:54.530 align:start position:0%
could be restored kind of the the use case here is if you could think about

00:08:54.540 --> 00:08:56.150 align:start position:0%
case here is if you could think about Implement a nonce where you didn't

00:08:56.160 --> 00:08:58.370 align:start position:0%
Implement a nonce where you didn't have this unique storage guarantee you

00:08:58.380 --> 00:09:00.470 align:start position:0%
have this unique storage guarantee you could find yourself where you have a

00:09:00.480 --> 00:09:02.210 align:start position:0%
could find yourself where you have a version one of the nonce in the archive

00:09:02.220 --> 00:09:04.370 align:start position:0%
version one of the nonce in the archive of like say value five and then version

00:09:04.380 --> 00:09:06.769 align:start position:0%
of like say value five and then version two of the nonce and the archive with a

00:09:06.779 --> 00:09:08.810 align:start position:0%
two of the nonce and the archive with a different value and then you can imagine

00:09:08.820 --> 00:09:11.030 align:start position:0%
different value and then you can imagine how a malicious user could restore those

00:09:11.040 --> 00:09:12.889 align:start position:0%
how a malicious user could restore those entries in such a way that your knots

00:09:12.899 --> 00:09:14.990 align:start position:0%
entries in such a way that your knots values out of date and not the correct

00:09:15.000 --> 00:09:16.790 align:start position:0%
values out of date and not the correct value that should be so that's unique

00:09:16.800 --> 00:09:18.650 align:start position:0%
value that should be so that's unique data it's more expensive because you

00:09:18.660 --> 00:09:20.269 align:start position:0%
data it's more expensive because you have to prove that something doesn't

00:09:20.279 --> 00:09:21.710 align:start position:0%
have to prove that something doesn't exist in the archive whenever you create

00:09:21.720 --> 00:09:23.150 align:start position:0%
exist in the archive whenever you create something new and so there's a little

00:09:23.160 --> 00:09:24.769 align:start position:0%
something new and so there's a little bit of work that needs to be done so

00:09:24.779 --> 00:09:27.170 align:start position:0%
bit of work that needs to be done so it's the most expensive data type but

00:09:27.180 --> 00:09:28.850 align:start position:0%
it's the most expensive data type but it's reserved for like those security

00:09:28.860 --> 00:09:32.870 align:start position:0%
it's reserved for like those security and high-risk sort of entries and then

00:09:32.880 --> 00:09:35.210 align:start position:0%
and high-risk sort of entries and then after unique storage we have what's

00:09:35.220 --> 00:09:38.329 align:start position:0%
after unique storage we have what's called recreatable storage which is a

00:09:38.339 --> 00:09:39.889 align:start position:0%
called recreatable storage which is a similar in that recreable storage

00:09:39.899 --> 00:09:42.050 align:start position:0%
similar in that recreable storage entries whenever you run out of rent

00:09:42.060 --> 00:09:44.449 align:start position:0%
entries whenever you run out of rent balance also get sent to the archive the

00:09:44.459 --> 00:09:45.769 align:start position:0%
balance also get sent to the archive the only difference is that recreatable

00:09:45.779 --> 00:09:48.829 align:start position:0%
only difference is that recreatable storage might have different versions in

00:09:48.839 --> 00:09:50.090 align:start position:0%
storage might have different versions in the archiver multiple different versions

00:09:50.100 --> 00:09:52.430 align:start position:0%
the archiver multiple different versions exists at the same time the reason for

00:09:52.440 --> 00:09:54.290 align:start position:0%
exists at the same time the reason for this is that whenever you create a

00:09:54.300 --> 00:09:56.449 align:start position:0%
this is that whenever you create a recreatable storage entry you don't

00:09:56.459 --> 00:09:58.009 align:start position:0%
recreatable storage entry you don't check the archive to see if something

00:09:58.019 --> 00:10:00.590 align:start position:0%
check the archive to see if something already exists there and so say you have

00:10:00.600 --> 00:10:01.970 align:start position:0%
already exists there and so say you have something like a balance that got

00:10:01.980 --> 00:10:04.250 align:start position:0%
something like a balance that got archived and then you go to create a new

00:10:04.260 --> 00:10:06.350 align:start position:0%
archived and then you go to create a new version of that after your old key got

00:10:06.360 --> 00:10:08.570 align:start position:0%
version of that after your old key got archived in recreatable storage you

00:10:08.580 --> 00:10:10.130 align:start position:0%
archived in recreatable storage you don't check the archive and so you just

00:10:10.140 --> 00:10:11.810 align:start position:0%
don't check the archive and so you just create a new entry with the exact same

00:10:11.820 --> 00:10:13.870 align:start position:0%
create a new entry with the exact same key and so you have this key collision

00:10:13.880 --> 00:10:16.850 align:start position:0%
key and so you have this key collision and so that's it's a little cheaper

00:10:16.860 --> 00:10:18.889 align:start position:0%
and so that's it's a little cheaper than unique storage because you don't

00:10:18.899 --> 00:10:20.210 align:start position:0%
than unique storage because you don't have to check the archive and actually

00:10:20.220 --> 00:10:22.250 align:start position:0%
have to check the archive and actually show that this entry is unique that

00:10:22.260 --> 00:10:24.710 align:start position:0%
show that this entry is unique that could be multiple versions of it so it's

00:10:24.720 --> 00:10:26.870 align:start position:0%
could be multiple versions of it so it's cheaper but it's not appropriate for

00:10:26.880 --> 00:10:29.329 align:start position:0%
cheaper but it's not appropriate for security types such as like nonsense or

00:10:29.339 --> 00:10:31.190 align:start position:0%
security types such as like nonsense or auth where you don't want multiple

00:10:31.200 --> 00:10:33.290 align:start position:0%
auth where you don't want multiple versions and so that's unique storage

00:10:33.300 --> 00:10:35.630 align:start position:0%
versions and so that's unique storage and recreatable storage both of which

00:10:35.640 --> 00:10:37.970 align:start position:0%
and recreatable storage both of which can be archived and then the final type

00:10:37.980 --> 00:10:39.650 align:start position:0%
can be archived and then the final type of storage is called temporary storage

00:10:39.660 --> 00:10:42.949 align:start position:0%
of storage is called temporary storage and this are for short-lived entries and

00:10:42.959 --> 00:10:45.350 align:start position:0%
and this are for short-lived entries and so whenever a temporary storage entry

00:10:45.360 --> 00:10:47.449 align:start position:0%
so whenever a temporary storage entry runs out of rent it just gets deleted it

00:10:47.459 --> 00:10:49.610 align:start position:0%
runs out of rent it just gets deleted it doesn't get sent to the archive and so

00:10:49.620 --> 00:10:51.290 align:start position:0%
doesn't get sent to the archive and so temporary storage is an appropriate for

00:10:51.300 --> 00:10:52.430 align:start position:0%
temporary storage is an appropriate for sensitive data that you want to keep

00:10:52.440 --> 00:10:55.490 align:start position:0%
sensitive data that you want to keep around like user balances but can be

00:10:55.500 --> 00:10:57.949 align:start position:0%
around like user balances but can be useful for data types that either don't

00:10:57.959 --> 00:10:59.690 align:start position:0%
useful for data types that either don't need to live very often like a

00:10:59.700 --> 00:11:01.370 align:start position:0%
need to live very often like a short-term authorization to let an

00:11:01.380 --> 00:11:03.650 align:start position:0%
short-term authorization to let an address spend your funds for instance or

00:11:03.660 --> 00:11:05.750 align:start position:0%
address spend your funds for instance or for data types that can be easily

00:11:05.760 --> 00:11:07.670 align:start position:0%
for data types that can be easily recreated if they get deleted such as

00:11:07.680 --> 00:11:09.530 align:start position:0%
recreated if they get deleted such as like a payment path or a payment Channel

00:11:09.540 --> 00:11:10.970 align:start position:0%
like a payment path or a payment Channel or something like that

00:11:10.980 --> 00:11:12.650 align:start position:0%
or something like that and so I think

00:11:12.660 --> 00:11:15.170 align:start position:0%
and so I think now even I think first I just want to

00:11:15.180 --> 00:11:17.269 align:start position:0%
now even I think first I just want to open up the floor for questions and to

00:11:17.279 --> 00:11:19.009 align:start position:0%
open up the floor for questions and to talk about this kind of like a interface

00:11:19.019 --> 00:11:20.449 align:start position:0%
talk about this kind of like a interface and in particular talk about this like

00:11:20.459 --> 00:11:22.430 align:start position:0%
and in particular talk about this like three-tiered approach and having three

00:11:22.440 --> 00:11:24.410 align:start position:0%
three-tiered approach and having three different classes of storage because I

00:11:24.420 --> 00:11:25.670 align:start position:0%
different classes of storage because I know that there's a little controversial

00:11:25.680 --> 00:11:27.110 align:start position:0%
know that there's a little controversial and it's definitely a little bit more

00:11:27.120 --> 00:11:28.910 align:start position:0%
and it's definitely a little bit more complex on the current interface just

00:11:28.920 --> 00:11:30.410 align:start position:0%
complex on the current interface just wondering if there are any questions

00:11:30.420 --> 00:11:35.210 align:start position:0%
wondering if there are any questions that

00:11:39.360 --> 00:11:41.030 align:start position:0%
I do I do have a question if if I can go for it

00:11:41.040 --> 00:11:41.810 align:start position:0%
go for it

00:11:45.420 --> 00:11:48.370 align:start position:0%
so this is in in my sense this is actually a very good design I like it

00:11:48.380 --> 00:11:51.170 align:start position:0%
actually a very good design I like it excuse me I'm wondering in terms of

00:11:51.180 --> 00:11:54.829 align:start position:0%
excuse me I'm wondering in terms of staging this work I I it's quite

00:11:54.839 --> 00:11:57.590 align:start position:0%
staging this work I I it's quite complicated and involved in some some

00:11:57.600 --> 00:11:59.449 align:start position:0%
complicated and involved in some some quantity of it is going to depend on

00:11:59.459 --> 00:12:00.069 align:start position:0%
quantity of it is going to depend on

00:12:02.579 --> 00:12:04.370 align:start position:0%
some pretty big components being built out in terms of the archivers

00:12:04.380 --> 00:12:06.230 align:start position:0%
out in terms of the archivers which is fine and and I think we can

00:12:06.240 --> 00:12:09.110 align:start position:0%
which is fine and and I think we can I think we can do some staging I'm

00:12:09.120 --> 00:12:10.130 align:start position:0%
I think we can do some staging I'm I'm

00:12:10.140 --> 00:12:11.930 align:start position:0%
I'm in the sense of you know deploying

00:12:11.940 --> 00:12:14.030 align:start position:0%
in the sense of you know deploying versions of zoroban that have the

00:12:14.040 --> 00:12:16.310 align:start position:0%
versions of zoroban that have the interface but but you know some of it is

00:12:16.320 --> 00:12:17.630 align:start position:0%
interface but but you know some of it is just defined to do nothing at this point

00:12:17.640 --> 00:12:19.370 align:start position:0%
just defined to do nothing at this point or that sort of thing

00:12:19.380 --> 00:12:19.970 align:start position:0%
or that sort of thing

00:12:21.720 --> 00:12:24.110 align:start position:0%
I'm a little bit concerned about the unique storage one because unique

00:12:24.120 --> 00:12:27.590 align:start position:0%
unique storage one because unique right off the bat has to have these

00:12:27.600 --> 00:12:29.750 align:start position:0%
right off the bat has to have these these exclusion proofs in order to do

00:12:29.760 --> 00:12:32.090 align:start position:0%
these exclusion proofs in order to do any rights is that correct

00:12:32.100 --> 00:12:34.490 align:start position:0%
any rights is that correct yes I think what we could do is we can

00:12:34.500 --> 00:12:36.769 align:start position:0%
yes I think what we could do is we can still do a staging process right

00:12:36.779 --> 00:12:38.810 align:start position:0%
still do a staging process right and so I think what this would

00:12:38.820 --> 00:12:40.670 align:start position:0%
and so I think what this would probably look like in practice is

00:12:40.680 --> 00:12:43.490 align:start position:0%
probably look like in practice is whenever we launch sort button we don't

00:12:43.500 --> 00:12:46.790 align:start position:0%
whenever we launch sort button we don't have the archive built out and so kind

00:12:46.800 --> 00:12:49.310 align:start position:0%
have the archive built out and so kind of the current plan for you know v0

00:12:49.320 --> 00:12:52.069 align:start position:0%
of the current plan for you know v0 on launch is to have the interface set

00:12:52.079 --> 00:12:54.530 align:start position:0%
on launch is to have the interface set so to expose the unique recreable and

00:12:54.540 --> 00:12:56.329 align:start position:0%
so to expose the unique recreable and temporary storage entry types to the

00:12:56.339 --> 00:12:59.090 align:start position:0%
temporary storage entry types to the user and then to charge rent

00:12:59.100 --> 00:13:01.730 align:start position:0%
user and then to charge rent and so the the thing that won't be

00:13:01.740 --> 00:13:03.110 align:start position:0%
and so the the thing that won't be there though is that whenever your rent

00:13:03.120 --> 00:13:04.610 align:start position:0%
there though is that whenever your rent balance goes to zero you won't get

00:13:04.620 --> 00:13:05.629 align:start position:0%
balance goes to zero you won't get delayed and you won't get sent to the

00:13:05.639 --> 00:13:07.370 align:start position:0%
delayed and you won't get sent to the archive because the archive won't be

00:13:07.380 --> 00:13:09.829 align:start position:0%
archive because the archive won't be built yet right and so I think for

00:13:09.839 --> 00:13:11.090 align:start position:0%
built yet right and so I think for Unique data in particular what we

00:13:11.100 --> 00:13:13.730 align:start position:0%
Unique data in particular what we probably just want to do is we can still

00:13:13.740 --> 00:13:16.129 align:start position:0%
probably just want to do is we can still I think we still should launch unique

00:13:16.139 --> 00:13:18.170 align:start position:0%
I think we still should launch unique data and recreable storage

00:13:18.180 --> 00:13:19.610 align:start position:0%
data and recreable storage just so that contracts can have the

00:13:19.620 --> 00:13:21.590 align:start position:0%
just so that contracts can have the correct Paradigm written at launch but

00:13:21.600 --> 00:13:22.730 align:start position:0%
correct Paradigm written at launch but what we can do I think at the

00:13:22.740 --> 00:13:25.370 align:start position:0%
what we can do I think at the implementation level is just the four

00:13:25.380 --> 00:13:27.410 align:start position:0%
implementation level is just the four just special cases right so like before

00:13:27.420 --> 00:13:31.430 align:start position:0%
just special cases right so like before we have these proofs we can just say

00:13:31.440 --> 00:13:32.930 align:start position:0%
we have these proofs we can just say essentially like creating unique

00:13:32.940 --> 00:13:34.490 align:start position:0%
essentially like creating unique entries does not require proof of

00:13:34.500 --> 00:13:36.949 align:start position:0%
entries does not require proof of exclusion until we actually provide an

00:13:36.959 --> 00:13:38.870 align:start position:0%
exclusion until we actually provide an interface for those proof of exclusions

00:13:38.880 --> 00:13:40.910 align:start position:0%
interface for those proof of exclusions that's that's exactly the part I was I

00:13:40.920 --> 00:13:43.009 align:start position:0%
that's that's exactly the part I was I was asking about is is do you think we

00:13:43.019 --> 00:13:44.569 align:start position:0%
was asking about is is do you think we would just sort of make it an optional

00:13:44.579 --> 00:13:46.370 align:start position:0%
would just sort of make it an optional field at first and then when we rev the

00:13:46.380 --> 00:13:47.930 align:start position:0%
field at first and then when we rev the protocol the optional field has to have

00:13:47.940 --> 00:13:49.250 align:start position:0%
protocol the optional field has to have a value in it and we'll Define what that

00:13:49.260 --> 00:13:51.650 align:start position:0%
a value in it and we'll Define what that value is in the future well we could do

00:13:51.660 --> 00:13:52.490 align:start position:0%
value is in the future well we could do that we're actually now that I'm

00:13:52.500 --> 00:13:54.350 align:start position:0%
that we're actually now that I'm thinking about it what we could do is

00:13:54.360 --> 00:13:56.870 align:start position:0%
thinking about it what we could do is just zero initialize through cache

00:13:56.880 --> 00:13:59.150 align:start position:0%
just zero initialize through cache and say the root archive hash is null

00:13:59.160 --> 00:14:01.850 align:start position:0%
and say the root archive hash is null and then proof of exclusion become

00:14:01.860 --> 00:14:03.230 align:start position:0%
and then proof of exclusion become trivial right because if your hash is

00:14:03.240 --> 00:14:05.269 align:start position:0%
trivial right because if your hash is null then you're guaranteed that it's

00:14:05.279 --> 00:14:07.129 align:start position:0%
null then you're guaranteed that it's empty and so I actually think we can

00:14:07.139 --> 00:14:11.030 align:start position:0%
empty and so I actually think we can provide proofs of exclusion on day Zero

00:14:11.040 --> 00:14:11.990 align:start position:0%
provide proofs of exclusion on day Zero actually

00:14:12.000 --> 00:14:14.210 align:start position:0%
actually if we just Define the the null hash

00:14:14.220 --> 00:14:16.009 align:start position:0%
if we just Define the the null hash and so the proof will always be null but

00:14:16.019 --> 00:14:17.690 align:start position:0%
and so the proof will always be null but that's about proof if your root hash is

00:14:17.700 --> 00:14:20.030 align:start position:0%
that's about proof if your root hash is null okay the other thing I'm thinking

00:14:20.040 --> 00:14:21.889 align:start position:0%
null okay the other thing I'm thinking is that

00:14:21.899 --> 00:14:24.949 align:start position:0%
is that you want this you want to use uniques

00:14:24.959 --> 00:14:29.629 align:start position:0%
you want this you want to use uniques for nonsense and it seems like we we

00:14:29.639 --> 00:14:31.850 align:start position:0%
for nonsense and it seems like we we update nonsense quite a lot

00:14:31.860 --> 00:14:32.569 align:start position:0%
update nonsense quite a lot

00:14:34.920 --> 00:14:37.850 align:start position:0%
and so I'm a little bit concerned about sort of an expensive

00:14:37.860 --> 00:14:40.610 align:start position:0%
sort of an expensive operation that involves constructing a

00:14:40.620 --> 00:14:42.769 align:start position:0%
operation that involves constructing a proof of exclusion

00:14:42.779 --> 00:14:44.329 align:start position:0%
proof of exclusion has to

00:14:44.339 --> 00:14:46.850 align:start position:0%
has to adhere to every every nonce update

00:14:46.860 --> 00:14:48.889 align:start position:0%
adhere to every every nonce update certainly I I wonder about the nonsense

00:14:48.899 --> 00:14:50.629 align:start position:0%
certainly I I wonder about the nonsense that are maintained by the auth system

00:14:50.639 --> 00:14:52.310 align:start position:0%
that are maintained by the auth system maybe Dima could speak to that I think

00:14:52.320 --> 00:14:54.170 align:start position:0%
maybe Dima could speak to that I think the third yeah I can I'm sorry if you

00:14:54.180 --> 00:14:56.210 align:start position:0%
the third yeah I can I'm sorry if you don't mind current so I think guaranteed

00:14:56.220 --> 00:14:59.870 align:start position:0%
don't mind current so I think guaranteed is using non's example is well just

00:14:59.880 --> 00:15:02.150 align:start position:0%
is using non's example is well just an example of why this problem

00:15:02.160 --> 00:15:05.269 align:start position:0%
an example of why this problem matters for the built-in nonsense at

00:15:05.279 --> 00:15:07.670 align:start position:0%
matters for the built-in nonsense at least we decided to move forward with

00:15:07.680 --> 00:15:11.269 align:start position:0%
least we decided to move forward with a temporary knowns approach or nonsense

00:15:11.279 --> 00:15:13.490 align:start position:0%
a temporary knowns approach or nonsense and signatures basically have some time

00:15:13.500 --> 00:15:16.790 align:start position:0%
and signatures basically have some time boundaries and certain the temporary

00:15:16.800 --> 00:15:20.810 align:start position:0%
boundaries and certain the temporary Ledger entries so they don't even run

00:15:20.820 --> 00:15:22.569 align:start position:0%
Ledger entries so they don't even run again

00:15:22.579 --> 00:15:25.370 align:start position:0%
again and I would say this should be a

00:15:25.380 --> 00:15:27.230 align:start position:0%
and I would say this should be a preferred approach right like I

00:15:27.240 --> 00:15:30.530 align:start position:0%
preferred approach right like I reiterated this several times in the

00:15:30.540 --> 00:15:34.069 align:start position:0%
reiterated this several times in the discussions here on Discord that with

00:15:34.079 --> 00:15:35.990 align:start position:0%
discussions here on Discord that with the existence of temporary storage it's

00:15:36.000 --> 00:15:38.569 align:start position:0%
the existence of temporary storage it's a really good idea to try benefit from

00:15:38.579 --> 00:15:39.910 align:start position:0%
a really good idea to try benefit from it and

00:15:39.920 --> 00:15:42.710 align:start position:0%
it and try to design for it right like in this

00:15:42.720 --> 00:15:44.829 align:start position:0%
try to design for it right like in this case of nonsense right we can have this

00:15:44.839 --> 00:15:47.449 align:start position:0%
case of nonsense right we can have this we need to bump it multiple times and

00:15:47.459 --> 00:15:49.730 align:start position:0%
we need to bump it multiple times and it's not super convenient and stuff and

00:15:49.740 --> 00:15:51.889 align:start position:0%
it's not super convenient and stuff and I I think the main use case for The

00:15:51.899 --> 00:15:55.069 align:start position:0%
I I think the main use case for The Unique storage is really some admin data

00:15:55.079 --> 00:15:58.189 align:start position:0%
Unique storage is really some admin data like you really don't want your admin

00:15:58.199 --> 00:16:00.530 align:start position:0%
like you really don't want your admin entry to be taken over by someone just

00:16:00.540 --> 00:16:02.750 align:start position:0%
entry to be taken over by someone just because it has expired right you have a

00:16:02.760 --> 00:16:05.210 align:start position:0%
because it has expired right you have a token contract that you have insured

00:16:05.220 --> 00:16:06.829 align:start position:0%
token contract that you have insured once a year ago and you have never

00:16:06.839 --> 00:16:08.389 align:start position:0%
once a year ago and you have never touched it but you don't want to wake

00:16:08.399 --> 00:16:10.430 align:start position:0%
touched it but you don't want to wake after a year the rent has expired you

00:16:10.440 --> 00:16:11.870 align:start position:0%
after a year the rent has expired you don't really want someone else to just

00:16:11.880 --> 00:16:13.970 align:start position:0%
don't really want someone else to just re-initialize it because the entry has

00:16:13.980 --> 00:16:15.829 align:start position:0%
re-initialize it because the entry has expired so I feel like this is the main

00:16:15.839 --> 00:16:17.930 align:start position:0%
expired so I feel like this is the main use case and this is a really pretty

00:16:17.940 --> 00:16:19.910 align:start position:0%
use case and this is a really pretty cold entries if you think about it right

00:16:19.920 --> 00:16:22.970 align:start position:0%
cold entries if you think about it right so yeah I think thinking about this a

00:16:22.980 --> 00:16:25.550 align:start position:0%
so yeah I think thinking about this a bit I I I sort of retract my concern

00:16:25.560 --> 00:16:27.650 align:start position:0%
bit I I I sort of retract my concern because I think you're right that if if

00:16:27.660 --> 00:16:30.650 align:start position:0%
because I think you're right that if if the system has a well-defined notion of

00:16:30.660 --> 00:16:32.509 align:start position:0%
the system has a well-defined notion of temporary storage with with time limits

00:16:32.519 --> 00:16:34.490 align:start position:0%
temporary storage with with time limits on it then you just you just time bound

00:16:34.500 --> 00:16:37.189 align:start position:0%
on it then you just you just time bound anything that is that is

00:16:37.199 --> 00:16:39.410 align:start position:0%
anything that is that is you you propagate those time bounds to

00:16:39.420 --> 00:16:41.030 align:start position:0%
you you propagate those time bounds to the things that use that storage such

00:16:41.040 --> 00:16:42.590 align:start position:0%
the things that use that storage such that they they would they would become

00:16:42.600 --> 00:16:45.170 align:start position:0%
that they they would they would become invalid at the same moment so I I can

00:16:45.180 --> 00:16:46.910 align:start position:0%
invalid at the same moment so I I can see that being quite quite a viable

00:16:46.920 --> 00:16:48.290 align:start position:0%
see that being quite quite a viable approach I like that that's good thank

00:16:48.300 --> 00:16:50.870 align:start position:0%
approach I like that that's good thank you I also once make one

00:16:50.880 --> 00:16:52.550 align:start position:0%
you I also once make one additional clarification I think in your

00:16:52.560 --> 00:16:53.870 align:start position:0%
additional clarification I think in your original question you said oh do you

00:16:53.880 --> 00:16:54.769 align:start position:0%
original question you said oh do you have to like provide a proof of

00:16:54.779 --> 00:16:56.749 align:start position:0%
have to like provide a proof of exclusion every time you update it and

00:16:56.759 --> 00:16:58.670 align:start position:0%
exclusion every time you update it and that's not true you only have to

00:16:58.680 --> 00:17:00.829 align:start position:0%
that's not true you only have to provide the proof at creation time

00:17:00.839 --> 00:17:01.850 align:start position:0%
provide the proof at creation time and then of course you have to

00:17:01.860 --> 00:17:03.350 align:start position:0%
and then of course you have to provide proofs if you run out of rent

00:17:03.360 --> 00:17:05.449 align:start position:0%
provide proofs if you run out of rent and then get sent to the archive but

00:17:05.459 --> 00:17:06.829 align:start position:0%
and then get sent to the archive but once it's actually live on the bucket

00:17:06.839 --> 00:17:09.530 align:start position:0%
once it's actually live on the bucket list then it says just as if you're

00:17:09.540 --> 00:17:11.809 align:start position:0%
list then it says just as if you're modifying any other entry the proofs

00:17:11.819 --> 00:17:13.730 align:start position:0%
modifying any other entry the proofs only apply if it's not on the bucket

00:17:13.740 --> 00:17:14.689 align:start position:0%
only apply if it's not on the bucket list or if you're creating something for

00:17:14.699 --> 00:17:16.850 align:start position:0%
list or if you're creating something for the first time and so if it's like

00:17:16.860 --> 00:17:18.350 align:start position:0%
the first time and so if it's like again this is just an example but like

00:17:18.360 --> 00:17:19.789 align:start position:0%
again this is just an example but like if it's a nonsense that's regularly used

00:17:19.799 --> 00:17:21.590 align:start position:0%
if it's a nonsense that's regularly used then it wouldn't matter it would be

00:17:21.600 --> 00:17:23.510 align:start position:0%
then it wouldn't matter it would be very cheap and efficient because it

00:17:23.520 --> 00:17:25.970 align:start position:0%
very cheap and efficient because it would never get to the archive okay

00:17:25.980 --> 00:17:28.189 align:start position:0%
would never get to the archive okay and oh I have one other very minor

00:17:28.199 --> 00:17:30.549 align:start position:0%
and oh I have one other very minor question and this is more of a design

00:17:30.559 --> 00:17:33.409 align:start position:0%
question and this is more of a design like time to hit the thesaurus we

00:17:33.419 --> 00:17:34.250 align:start position:0%
like time to hit the thesaurus we already have something in a system

00:17:34.260 --> 00:17:36.590 align:start position:0%
already have something in a system called an archive I I just feel like

00:17:36.600 --> 00:17:37.730 align:start position:0%
called an archive I I just feel like we gotta use a different word for this

00:17:37.740 --> 00:17:38.870 align:start position:0%
we gotta use a different word for this because it's just gonna it's just gonna

00:17:38.880 --> 00:17:41.630 align:start position:0%
because it's just gonna it's just gonna follow up a lot of things that are

00:17:41.640 --> 00:17:43.430 align:start position:0%
follow up a lot of things that are already referred our guys yeah maybe

00:17:43.440 --> 00:17:45.710 align:start position:0%
already referred our guys yeah maybe like deep State source and like the yeah

00:17:45.720 --> 00:17:46.789 align:start position:0%
like deep State source and like the yeah I don't know what you're gonna call it

00:17:46.799 --> 00:17:48.590 align:start position:0%
I don't know what you're gonna call it but maybe maybe not start with deep

00:17:48.600 --> 00:17:51.890 align:start position:0%
but maybe maybe not start with deep state that might be a tough

00:17:54.780 --> 00:17:56.810 align:start position:0%
a graveyard yeah cool so I guess any other questions

00:17:56.820 --> 00:17:59.330 align:start position:0%
cool so I guess any other questions about specifically the recreatable

00:17:59.340 --> 00:18:00.950 align:start position:0%
about specifically the recreatable temporary and then unique storage

00:18:00.960 --> 00:18:02.690 align:start position:0%
temporary and then unique storage interface before you move on

00:18:02.700 --> 00:18:05.330 align:start position:0%
interface before you move on yes I'd like to ask

00:18:05.340 --> 00:18:07.070 align:start position:0%
yes I'd like to ask why

00:18:07.080 --> 00:18:10.190 align:start position:0%
why like is there any reason why you

00:18:10.200 --> 00:18:13.390 align:start position:0%
like is there any reason why you don't use something like a bloom filter

00:18:13.400 --> 00:18:16.850 align:start position:0%
don't use something like a bloom filter to

00:18:16.860 --> 00:18:20.450 align:start position:0%
to to check whether the entry already

00:18:20.460 --> 00:18:24.770 align:start position:0%
to check whether the entry already exists in the arch Avenue because

00:18:24.780 --> 00:18:28.010 align:start position:0%
exists in the arch Avenue because given given the notion that we have a

00:18:28.020 --> 00:18:31.190 align:start position:0%
given given the notion that we have a bloom filter of all entries in the

00:18:31.200 --> 00:18:33.850 align:start position:0%
bloom filter of all entries in the archive we can probably

00:18:33.860 --> 00:18:38.330 align:start position:0%
archive we can probably avoid having multiple versions of

00:18:38.340 --> 00:18:42.830 align:start position:0%
avoid having multiple versions of archived entries and I think having only

00:18:42.840 --> 00:18:46.090 align:start position:0%
archived entries and I think having only one version in the archive and

00:18:46.100 --> 00:18:49.930 align:start position:0%
one version in the archive and preventing users to recreate

00:18:49.940 --> 00:18:52.730 align:start position:0%
preventing users to recreate some entries that already exist in the

00:18:52.740 --> 00:18:54.490 align:start position:0%
some entries that already exist in the archive

00:18:54.500 --> 00:18:58.909 align:start position:0%
archive makes a lot of sense easier

00:18:58.919 --> 00:19:01.850 align:start position:0%
makes a lot of sense easier yeah so we definitely investigated this

00:19:01.860 --> 00:19:04.310 align:start position:0%
yeah so we definitely investigated this a lot and we tried to find a way if

00:19:04.320 --> 00:19:05.930 align:start position:0%
a lot and we tried to find a way if there is a way for validators to store

00:19:05.940 --> 00:19:07.850 align:start position:0%
there is a way for validators to store keys or to at least have some knowledge

00:19:07.860 --> 00:19:09.650 align:start position:0%
keys or to at least have some knowledge of what's in the archive I think there's

00:19:09.660 --> 00:19:12.169 align:start position:0%
of what's in the archive I think there's a couple issues there so first the

00:19:12.179 --> 00:19:14.990 align:start position:0%
a couple issues there so first the goal of the archival state is to bound

00:19:15.000 --> 00:19:16.730 align:start position:0%
goal of the archival state is to bound the amount of storage that values need

00:19:16.740 --> 00:19:19.010 align:start position:0%
the amount of storage that values need to store and so if they need to store a

00:19:19.020 --> 00:19:20.810 align:start position:0%
to store and so if they need to store a key even though that's you know less

00:19:20.820 --> 00:19:23.330 align:start position:0%
key even though that's you know less than storing the entire data entry

00:19:23.340 --> 00:19:25.130 align:start position:0%
than storing the entire data entry that's still an unbounded storage so

00:19:25.140 --> 00:19:26.750 align:start position:0%
that's still an unbounded storage so that's issue number one but I think in

00:19:26.760 --> 00:19:27.890 align:start position:0%
that's issue number one but I think in particular

00:19:27.900 --> 00:19:30.230 align:start position:0%
particular you'd have to have a set of keys that

00:19:30.240 --> 00:19:31.970 align:start position:0%
you'd have to have a set of keys that grows unbounded and that's not a great

00:19:31.980 --> 00:19:33.950 align:start position:0%
grows unbounded and that's not a great solution because especially for sorbonne

00:19:33.960 --> 00:19:36.350 align:start position:0%
solution because especially for sorbonne data types there's a lot of instances

00:19:36.360 --> 00:19:38.270 align:start position:0%
data types there's a lot of instances where the key is actually as big or

00:19:38.280 --> 00:19:40.010 align:start position:0%
where the key is actually as big or larger than the value because if you can

00:19:40.020 --> 00:19:42.409 align:start position:0%
larger than the value because if you can think like the keys are 32 bytes

00:19:42.419 --> 00:19:44.570 align:start position:0%
think like the keys are 32 bytes and I'm not you know super in depth

00:19:44.580 --> 00:19:45.830 align:start position:0%
and I'm not you know super in depth at the current sort of implementation so

00:19:45.840 --> 00:19:47.570 align:start position:0%
at the current sort of implementation so correct me if I'm wrong my understanding

00:19:47.580 --> 00:19:50.450 align:start position:0%
correct me if I'm wrong my understanding is keys are 32 bytes but the value for

00:19:50.460 --> 00:19:51.710 align:start position:0%
is keys are 32 bytes but the value for instance could be something as small as

00:19:51.720 --> 00:19:53.450 align:start position:0%
instance could be something as small as I can that's only like four bytes or

00:19:53.460 --> 00:19:54.890 align:start position:0%
I can that's only like four bytes or something like that and so I think

00:19:54.900 --> 00:19:57.230 align:start position:0%
something like that and so I think you're not getting as good cost savings

00:19:57.240 --> 00:19:58.850 align:start position:0%
you're not getting as good cost savings as you think if you just store the keys

00:19:58.860 --> 00:20:00.950 align:start position:0%
as you think if you just store the keys business set not to your Bloom filter

00:20:00.960 --> 00:20:02.690 align:start position:0%
business set not to your Bloom filter question or if there's a way to store

00:20:02.700 --> 00:20:05.750 align:start position:0%
question or if there's a way to store the keys in a more efficient manner the

00:20:05.760 --> 00:20:07.310 align:start position:0%
the keys in a more efficient manner the issue with Bloom filters in particular

00:20:07.320 --> 00:20:09.529 align:start position:0%
issue with Bloom filters in particular is that they don't it's very difficult

00:20:09.539 --> 00:20:13.490 align:start position:0%
is that they don't it's very difficult to resize the bloom filter and so if you

00:20:13.500 --> 00:20:16.549 align:start position:0%
to resize the bloom filter and so if you say I have Unbound State and say okay

00:20:16.559 --> 00:20:17.630 align:start position:0%
say I have Unbound State and say okay we're going to pick a bloom filter

00:20:17.640 --> 00:20:19.490 align:start position:0%
we're going to pick a bloom filter that's one gigabyte large

00:20:19.500 --> 00:20:21.230 align:start position:0%
that's one gigabyte large but in 10 years you need a larger

00:20:21.240 --> 00:20:22.610 align:start position:0%
but in 10 years you need a larger Bloom filter because you're getting a

00:20:22.620 --> 00:20:24.710 align:start position:0%
Bloom filter because you're getting a lot of collisions and stuff it's

00:20:24.720 --> 00:20:26.630 align:start position:0%
lot of collisions and stuff it's impossible to just resize that bloom

00:20:26.640 --> 00:20:28.490 align:start position:0%
impossible to just resize that bloom filter without having all the values

00:20:28.500 --> 00:20:30.350 align:start position:0%
filter without having all the values because whenever you change the size of

00:20:30.360 --> 00:20:32.090 align:start position:0%
because whenever you change the size of the bloom filter you have to rehash

00:20:32.100 --> 00:20:33.409 align:start position:0%
the bloom filter you have to rehash everything that you've added to the

00:20:33.419 --> 00:20:34.970 align:start position:0%
everything that you've added to the bloom filter which would not be possible

00:20:34.980 --> 00:20:36.890 align:start position:0%
bloom filter which would not be possible for the validators because they've

00:20:36.900 --> 00:20:38.750 align:start position:0%
for the validators because they've thrown all those values away and so

00:20:38.760 --> 00:20:40.850 align:start position:0%
thrown all those values away and so essentially to resize your Bloom filter

00:20:40.860 --> 00:20:43.010 align:start position:0%
essentially to resize your Bloom filter have to replay history from the

00:20:43.020 --> 00:20:46.310 align:start position:0%
have to replay history from the beginning of time in order to resurface

00:20:46.320 --> 00:20:48.169 align:start position:0%
beginning of time in order to resurface all the values that need to be in that

00:20:48.179 --> 00:20:50.810 align:start position:0%
all the values that need to be in that blend filter and additionally there's

00:20:50.820 --> 00:20:52.310 align:start position:0%
blend filter and additionally there's still issues with Bloom filters because

00:20:52.320 --> 00:20:54.529 align:start position:0%
still issues with Bloom filters because they're probabilistic in nature and so

00:20:54.539 --> 00:20:55.970 align:start position:0%
they're probabilistic in nature and so you would still have key collisions

00:20:55.980 --> 00:20:57.890 align:start position:0%
you would still have key collisions sometimes or I guess

00:20:57.900 --> 00:21:00.529 align:start position:0%
sometimes or I guess or not Keyhole rather because they

00:21:00.539 --> 00:21:02.210 align:start position:0%
or not Keyhole rather because they only return

00:21:02.220 --> 00:21:04.250 align:start position:0%
only return they don't return false Nexus I don't

00:21:04.260 --> 00:21:06.409 align:start position:0%
they don't return false Nexus I don't think but then there'd be certain keys

00:21:06.419 --> 00:21:07.610 align:start position:0%
think but then there'd be certain keys that just based on the probabilistic

00:21:07.620 --> 00:21:10.370 align:start position:0%
that just based on the probabilistic nature of the bloom filter the

00:21:10.380 --> 00:21:11.870 align:start position:0%
nature of the bloom filter the validators would think they're in the

00:21:11.880 --> 00:21:13.669 align:start position:0%
validators would think they're in the archive even though they weren't in the

00:21:13.679 --> 00:21:15.770 align:start position:0%
archive even though they weren't in the archive and so that would also be an

00:21:15.780 --> 00:21:17.810 align:start position:0%
archive and so that would also be an issue where just based on whatever

00:21:17.820 --> 00:21:19.490 align:start position:0%
issue where just based on whatever your hash function is there'd be certain

00:21:19.500 --> 00:21:20.810 align:start position:0%
your hash function is there'd be certain keys that would essentially be

00:21:20.820 --> 00:21:22.730 align:start position:0%
keys that would essentially be impossible to create because the balloon

00:21:22.740 --> 00:21:23.930 align:start position:0%
impossible to create because the balloon filter thinks they already exist when

00:21:23.940 --> 00:21:25.490 align:start position:0%
filter thinks they already exist when they really don't

00:21:25.500 --> 00:21:26.690 align:start position:0%
they really don't so that answers your question about

00:21:26.700 --> 00:21:28.250 align:start position:0%
so that answers your question about the the bloom filter issue in particular

00:21:28.260 --> 00:21:32.470 align:start position:0%
the the bloom filter issue in particular the issue in general as well

00:21:37.380 --> 00:21:42.230 align:start position:0%
I'm not entirely sure that the resizing issue is such a

00:21:42.240 --> 00:21:45.230 align:start position:0%
the resizing issue is such a huge problem because you have an

00:21:45.240 --> 00:21:48.130 align:start position:0%
huge problem because you have an archive where you have all the keys

00:21:48.140 --> 00:21:53.990 align:start position:0%
archive where you have all the keys so once in a let's say 10 years it's

00:21:54.000 --> 00:21:58.909 align:start position:0%
so once in a let's say 10 years it's possible to organize a resizing using

00:21:58.919 --> 00:22:02.649 align:start position:0%
possible to organize a resizing using the archives as a source of all the

00:22:02.659 --> 00:22:05.169 align:start position:0%
the archives as a source of all the existing keys

00:22:05.179 --> 00:22:08.930 align:start position:0%
existing keys and to make like a maintenance for all

00:22:08.940 --> 00:22:10.310 align:start position:0%
and to make like a maintenance for all the validators

00:22:10.320 --> 00:22:12.890 align:start position:0%
the validators as for the size of the bloom filter for

00:22:12.900 --> 00:22:16.430 align:start position:0%
as for the size of the bloom filter for example I just checked and one billion

00:22:16.440 --> 00:22:19.070 align:start position:0%
example I just checked and one billion entries

00:22:19.080 --> 00:22:21.230 align:start position:0%
entries with a reasonable

00:22:21.240 --> 00:22:22.510 align:start position:0%
with a reasonable

00:22:22.520 --> 00:22:27.590 align:start position:0%
false positives like

00:22:29.840 --> 00:22:33.190 align:start position:0%
Point 0.1 percent

00:22:33.200 --> 00:22:36.350 align:start position:0%
0.1 percent probability of false negatives takes

00:22:36.360 --> 00:22:41.570 align:start position:0%
probability of false negatives takes about two and a half gigabytes so it's

00:22:41.580 --> 00:22:44.990 align:start position:0%
about two and a half gigabytes so it's not the clutch and it will be enough for

00:22:45.000 --> 00:22:48.289 align:start position:0%
not the clutch and it will be enough for the first billion entries

00:22:48.299 --> 00:22:51.770 align:start position:0%
the first billion entries I think it's a reasonable trade-off for

00:22:51.780 --> 00:22:53.529 align:start position:0%
I think it's a reasonable trade-off for to avoid

00:22:53.539 --> 00:22:58.430 align:start position:0%
to avoid some other complexities as for the false

00:22:58.440 --> 00:23:03.490 align:start position:0%
some other complexities as for the false positives case I think since you have

00:23:03.500 --> 00:23:07.610 align:start position:0%
positives case I think since you have the vehicle tree or some other structure

00:23:07.620 --> 00:23:11.450 align:start position:0%
the vehicle tree or some other structure if it's not set and so on yet then you

00:23:11.460 --> 00:23:15.049 align:start position:0%
if it's not set and so on yet then you can probably check whether their hive

00:23:15.059 --> 00:23:18.909 align:start position:0%
can probably check whether their hive this is archive contains the given K

00:23:18.919 --> 00:23:22.970 align:start position:0%
this is archive contains the given K give given key if it's

00:23:22.980 --> 00:23:25.070 align:start position:0%
give given key if it's let's say it can be a resurrected or

00:23:25.080 --> 00:23:27.409 align:start position:0%
let's say it can be a resurrected or something like this maybe I'm missing

00:23:27.419 --> 00:23:29.330 align:start position:0%
something like this maybe I'm missing something because I haven't think about

00:23:29.340 --> 00:23:31.130 align:start position:0%
something because I haven't think about this

00:23:31.140 --> 00:23:35.810 align:start position:0%
this for quite a long time but

00:23:39.679 --> 00:23:43.430 align:start position:0%
do you still think that using some Bloom filters other

00:23:43.440 --> 00:23:47.090 align:start position:0%
using some Bloom filters other probabilistic structures won't help to

00:23:47.100 --> 00:23:50.270 align:start position:0%
probabilistic structures won't help to prevent collisions of entries in

00:23:50.280 --> 00:23:52.789 align:start position:0%
prevent collisions of entries in archives like maybe there is some other

00:23:52.799 --> 00:23:53.870 align:start position:0%
archives like maybe there is some other option

00:23:53.880 --> 00:23:58.190 align:start position:0%
option because yeah this point looks like one

00:23:58.200 --> 00:24:01.070 align:start position:0%
because yeah this point looks like one of the most controversial things about

00:24:01.080 --> 00:24:04.130 align:start position:0%
of the most controversial things about the archives to me

00:24:04.140 --> 00:24:06.590 align:start position:0%
the archives to me yeah this is a an interesting idea

00:24:06.600 --> 00:24:08.930 align:start position:0%
yeah this is a an interesting idea actually I think you mentioned that

00:24:08.940 --> 00:24:10.909 align:start position:0%
actually I think you mentioned that perhaps use the bloom filter

00:24:10.919 --> 00:24:12.950 align:start position:0%
perhaps use the bloom filter as like a almost a caching layer for

00:24:12.960 --> 00:24:14.570 align:start position:0%
as like a almost a caching layer for efficiency and then

00:24:14.580 --> 00:24:16.010 align:start position:0%
efficiency and then using the proofs as kind of like a

00:24:16.020 --> 00:24:17.090 align:start position:0%
using the proofs as kind of like a back end in case you get a false

00:24:17.100 --> 00:24:20.510 align:start position:0%
back end in case you get a false positive I'm still not 100 sure if the

00:24:20.520 --> 00:24:22.610 align:start position:0%
positive I'm still not 100 sure if the false positive case can be avoided right

00:24:22.620 --> 00:24:25.070 align:start position:0%
false positive case can be avoided right because say like from this would

00:24:25.080 --> 00:24:26.270 align:start position:0%
because say like from this would be very frustrating from a user

00:24:26.280 --> 00:24:29.090 align:start position:0%
be very frustrating from a user standpoint say I have a key

00:24:29.100 --> 00:24:30.049 align:start position:0%
standpoint say I have a key or like there's some like

00:24:30.059 --> 00:24:31.789 align:start position:0%
or like there's some like deterministic way to like Define cues

00:24:31.799 --> 00:24:34.370 align:start position:0%
deterministic way to like Define cues right so like I give my address

00:24:34.380 --> 00:24:36.049 align:start position:0%
right so like I give my address and then like the address is input

00:24:36.059 --> 00:24:37.310 align:start position:0%
and then like the address is input that generates

00:24:37.320 --> 00:24:39.350 align:start position:0%
that generates the keys for entries associated with

00:24:39.360 --> 00:24:41.029 align:start position:0%
the keys for entries associated with my account right like in a token

00:24:41.039 --> 00:24:41.870 align:start position:0%
my account right like in a token contract

00:24:41.880 --> 00:24:44.330 align:start position:0%
contract if one of those keys is a false positive

00:24:44.340 --> 00:24:46.549 align:start position:0%
if one of those keys is a false positive then you just won't be able to create

00:24:46.559 --> 00:24:50.990 align:start position:0%
then you just won't be able to create any entries based on your

00:24:51.000 --> 00:24:54.590 align:start position:0%
any entries based on your your the invoker address right and so I

00:24:54.600 --> 00:24:56.090 align:start position:0%
your the invoker address right and so I don't know if there's a way if you get a

00:24:56.100 --> 00:24:58.130 align:start position:0%
don't know if there's a way if you get a false positive to somehow track the

00:24:58.140 --> 00:25:00.110 align:start position:0%
false positive to somehow track the archive and say oh actually that wasn't

00:25:00.120 --> 00:25:02.330 align:start position:0%
archive and say oh actually that wasn't a false positive it really is it really

00:25:02.340 --> 00:25:04.310 align:start position:0%
a false positive it really is it really doesn't exist I promise

00:25:04.320 --> 00:25:06.590 align:start position:0%
doesn't exist I promise and so I'm not sure

00:25:06.600 --> 00:25:09.049 align:start position:0%
and so I'm not sure if there is a way to get around that

00:25:09.059 --> 00:25:10.490 align:start position:0%
if there is a way to get around that case because I think like even if you

00:25:10.500 --> 00:25:11.750 align:start position:0%
case because I think like even if you say like a reasonable false positive

00:25:11.760 --> 00:25:14.570 align:start position:0%
say like a reasonable false positive rate like a 0.1 percent that still means

00:25:14.580 --> 00:25:17.630 align:start position:0%
rate like a 0.1 percent that still means that one out of I think a thousand Keys

00:25:17.640 --> 00:25:19.190 align:start position:0%
that one out of I think a thousand Keys or maybe a ten thousand keys I might

00:25:19.200 --> 00:25:20.690 align:start position:0%
or maybe a ten thousand keys I might be off by zero or something there but

00:25:20.700 --> 00:25:21.830 align:start position:0%
be off by zero or something there but essentially like one of the Thousand

00:25:21.840 --> 00:25:23.210 align:start position:0%
essentially like one of the Thousand Keys

00:25:23.220 --> 00:25:25.130 align:start position:0%
Keys you'll think it's in the archive when

00:25:25.140 --> 00:25:27.710 align:start position:0%
you'll think it's in the archive when it really isn't which means that you are

00:25:27.720 --> 00:25:29.149 align:start position:0%
it really isn't which means that you are not allowed to create one of the

00:25:29.159 --> 00:25:30.710 align:start position:0%
not allowed to create one of the thousand one out of a thousand Keys

00:25:30.720 --> 00:25:32.210 align:start position:0%
thousand one out of a thousand Keys which I feel like could be a really

00:25:32.220 --> 00:25:33.590 align:start position:0%
which I feel like could be a really significant issue from the user

00:25:33.600 --> 00:25:36.669 align:start position:0%
significant issue from the user interface perspective

00:25:41.419 --> 00:25:46.070 align:start position:0%
do you think that the time of checking the existence of the key

00:25:46.080 --> 00:25:49.010 align:start position:0%
checking the existence of the key over the Merkel tree or the miracle

00:25:49.020 --> 00:25:52.549 align:start position:0%
over the Merkel tree or the miracle trios or the structure you plan to use

00:25:52.559 --> 00:25:58.549 align:start position:0%
trios or the structure you plan to use for archive proofs it's like

00:25:58.559 --> 00:25:59.330 align:start position:0%
for archive proofs it's like

00:26:03.659 --> 00:26:08.810 align:start position:0%
a really huge time like seconds minutes or even more because if it's

00:26:08.820 --> 00:26:11.769 align:start position:0%
or even more because if it's relatively small then

00:26:11.779 --> 00:26:13.810 align:start position:0%
relatively small then checking

00:26:13.820 --> 00:26:17.029 align:start position:0%
checking checking the existence only for

00:26:17.039 --> 00:26:21.130 align:start position:0%
checking the existence only for conflicting entries and you will be

00:26:21.140 --> 00:26:24.350 align:start position:0%
conflicting entries and you will be checking computer and entries only when

00:26:24.360 --> 00:26:29.049 align:start position:0%
checking computer and entries only when someone tries to create already existing

00:26:29.059 --> 00:26:31.730 align:start position:0%
someone tries to create already existing entry which

00:26:31.740 --> 00:26:36.370 align:start position:0%
entry which actually I shouldn't be as

00:26:43.679 --> 00:26:47.450 align:start position:0%
as often operation so like what are the time requirements for

00:26:47.460 --> 00:26:50.570 align:start position:0%
what are the time requirements for checking against the try

00:26:50.580 --> 00:26:53.330 align:start position:0%
checking against the try also I think one clarification

00:26:53.340 --> 00:26:55.970 align:start position:0%
also I think one clarification here is that you can't just track

00:26:55.980 --> 00:26:58.789 align:start position:0%
here is that you can't just track against the archive directly because the

00:26:58.799 --> 00:27:00.649 align:start position:0%
against the archive directly because the archivers don't participate in consensus

00:27:00.659 --> 00:27:03.230 align:start position:0%
archivers don't participate in consensus and are not validators they are off

00:27:03.240 --> 00:27:05.390 align:start position:0%
and are not validators they are off chain right and so you can't just like

00:27:05.400 --> 00:27:08.090 align:start position:0%
chain right and so you can't just like search through the tree brute force and

00:27:08.100 --> 00:27:10.730 align:start position:0%
search through the tree brute force and trust that the contents are correct so

00:27:10.740 --> 00:27:12.950 align:start position:0%
trust that the contents are correct so there has to be some way for the

00:27:12.960 --> 00:27:16.669 align:start position:0%
there has to be some way for the archivers to give a proof to validators

00:27:16.679 --> 00:27:19.130 align:start position:0%
archivers to give a proof to validators that the validators can then validate

00:27:19.140 --> 00:27:20.750 align:start position:0%
that the validators can then validate themselves and so I think that's why

00:27:20.760 --> 00:27:22.070 align:start position:0%
themselves and so I think that's why part of the reason we're using this try

00:27:22.080 --> 00:27:24.230 align:start position:0%
part of the reason we're using this try model where we can get both proofs of

00:27:24.240 --> 00:27:26.390 align:start position:0%
model where we can get both proofs of explosion pros of inclusion because I

00:27:26.400 --> 00:27:28.549 align:start position:0%
explosion pros of inclusion because I think the difference between this

00:27:28.559 --> 00:27:30.769 align:start position:0%
think the difference between this case and the Ubuntu case is that in the

00:27:30.779 --> 00:27:33.769 align:start position:0%
case and the Ubuntu case is that in the Ubuntu case you can trust the the

00:27:33.779 --> 00:27:35.750 align:start position:0%
Ubuntu case you can trust the the archive in our case we can't trust the

00:27:35.760 --> 00:27:37.490 align:start position:0%
archive in our case we can't trust the archive we have to have some proof via

00:27:37.500 --> 00:27:40.610 align:start position:0%
archive we have to have some proof via like a hash or something and so

00:27:40.620 --> 00:27:43.190 align:start position:0%
like a hash or something and so I'm still I think I think it could be

00:27:43.200 --> 00:27:44.690 align:start position:0%
I'm still I think I think it could be interesting this Bloom filter approach

00:27:44.700 --> 00:27:46.850 align:start position:0%
interesting this Bloom filter approach if we can

00:27:46.860 --> 00:27:49.250 align:start position:0%
if we can do the bloom filter

00:27:49.260 --> 00:27:51.649 align:start position:0%
do the bloom filter and then if there's a collision maybe

00:27:51.659 --> 00:27:53.210 align:start position:0%
and then if there's a collision maybe say even though there's a collision

00:27:53.220 --> 00:27:54.710 align:start position:0%
say even though there's a collision in the bloom filter I'm going to go and

00:27:54.720 --> 00:27:56.630 align:start position:0%
in the bloom filter I'm going to go and get a proof of exclusion

00:27:56.640 --> 00:27:58.610 align:start position:0%
get a proof of exclusion and that would perhaps make it more

00:27:58.620 --> 00:28:01.490 align:start position:0%
and that would perhaps make it more efficient and mean that in most cases

00:28:01.500 --> 00:28:03.230 align:start position:0%
efficient and mean that in most cases you can get away with creating entries

00:28:03.240 --> 00:28:05.510 align:start position:0%
you can get away with creating entries without a perfect exclusion

00:28:05.520 --> 00:28:06.649 align:start position:0%
without a perfect exclusion

00:28:10.020 --> 00:28:11.750 align:start position:0%
but I'm still not sure what that would look like I guess maybe what we could do

00:28:11.760 --> 00:28:13.970 align:start position:0%
look like I guess maybe what we could do is you create your entry you check the

00:28:13.980 --> 00:28:17.210 align:start position:0%
is you create your entry you check the bloom filter and then if you get an

00:28:17.220 --> 00:28:19.730 align:start position:0%
bloom filter and then if you get an error on the bloom filter then you go

00:28:19.740 --> 00:28:22.130 align:start position:0%
error on the bloom filter then you go try to get proof of exclusion and if

00:28:22.140 --> 00:28:23.630 align:start position:0%
try to get proof of exclusion and if there's a valid proof of exclusion on

00:28:23.640 --> 00:28:25.070 align:start position:0%
there's a valid proof of exclusion on chain that can override the bloom filter

00:28:25.080 --> 00:28:26.630 align:start position:0%
chain that can override the bloom filter that might be an interesting

00:28:26.640 --> 00:28:29.029 align:start position:0%
that might be an interesting optimization

00:28:29.039 --> 00:28:31.130 align:start position:0%
optimization but

00:28:31.140 --> 00:28:34.510 align:start position:0%
but I guess that's second point

00:28:34.520 --> 00:28:37.010 align:start position:0%
I guess that's second point for explanation I don't want to steal

00:28:37.020 --> 00:28:41.450 align:start position:0%
for explanation I don't want to steal the time it's definitely

00:28:44.820 --> 00:28:47.390 align:start position:0%
like I I need to make more research on this and probably we should get back

00:28:47.400 --> 00:28:49.549 align:start position:0%
on this and probably we should get back on this in that sales matter to to

00:28:49.559 --> 00:28:51.590 align:start position:0%
on this in that sales matter to to instill the time

00:28:51.600 --> 00:28:54.409 align:start position:0%
instill the time on this question here thanks for the

00:28:54.419 --> 00:28:57.350 align:start position:0%
on this question here thanks for the explanation yeah I think that's a I

00:28:57.360 --> 00:28:58.130 align:start position:0%
explanation yeah I think that's a I think it's definitely an interesting

00:28:58.140 --> 00:28:59.930 align:start position:0%
think it's definitely an interesting idea that's definitely worth pursuing

00:28:59.940 --> 00:29:01.909 align:start position:0%
idea that's definitely worth pursuing I guess one question I would ask is

00:29:01.919 --> 00:29:03.230 align:start position:0%
I guess one question I would ask is under this proposal of the bloom filter

00:29:03.240 --> 00:29:05.330 align:start position:0%
under this proposal of the bloom filter and whatnot this would make all data

00:29:05.340 --> 00:29:07.430 align:start position:0%
and whatnot this would make all data unique data and so I'm wondering if

00:29:07.440 --> 00:29:09.529 align:start position:0%
unique data and so I'm wondering if there are use cases where a user might

00:29:09.539 --> 00:29:11.870 align:start position:0%
there are use cases where a user might actually want data to be recreatable

00:29:11.880 --> 00:29:13.549 align:start position:0%
actually want data to be recreatable so thinking of the balanced use case I'm

00:29:13.559 --> 00:29:15.890 align:start position:0%
so thinking of the balanced use case I'm thinking like is there ever a scenario

00:29:15.900 --> 00:29:17.450 align:start position:0%
thinking like is there ever a scenario where it's actually an advantage to have

00:29:17.460 --> 00:29:19.130 align:start position:0%
where it's actually an advantage to have multiple different versions

00:29:19.140 --> 00:29:21.889 align:start position:0%
multiple different versions as opposed to only having this strict

00:29:21.899 --> 00:29:25.850 align:start position:0%
as opposed to only having this strict one unique key

00:29:25.860 --> 00:29:27.710 align:start position:0%
one unique key per archive per bucket list so I'm

00:29:27.720 --> 00:29:29.630 align:start position:0%
per archive per bucket list so I'm thinking like for instance in the

00:29:29.640 --> 00:29:31.970 align:start position:0%
thinking like for instance in the case of balances where the multiple

00:29:31.980 --> 00:29:33.230 align:start position:0%
case of balances where the multiple different versions of the balance can

00:29:33.240 --> 00:29:34.730 align:start position:0%
different versions of the balance can just be summed together

00:29:34.740 --> 00:29:37.610 align:start position:0%
just be summed together is that a Advantage

00:29:37.620 --> 00:29:39.710 align:start position:0%
is that a Advantage and is there like a do we still want

00:29:39.720 --> 00:29:43.310 align:start position:0%
and is there like a do we still want to expose a repradable storage interface

00:29:43.320 --> 00:29:45.529 align:start position:0%
to expose a repradable storage interface so you can be even faster and I guess

00:29:45.539 --> 00:29:47.090 align:start position:0%
so you can be even faster and I guess like not have to do this like Bloom

00:29:47.100 --> 00:29:48.590 align:start position:0%
like not have to do this like Bloom filter check not because of exclusion

00:29:48.600 --> 00:29:50.870 align:start position:0%
filter check not because of exclusion all that sort of stuff or is like a

00:29:50.880 --> 00:29:54.049 align:start position:0%
all that sort of stuff or is like a strict guarantee one key no collisions

00:29:54.059 --> 00:29:56.269 align:start position:0%
strict guarantee one key no collisions powerful and that we shouldn't expose

00:29:56.279 --> 00:30:00.250 align:start position:0%
powerful and that we shouldn't expose this interface at all

00:30:03.320 --> 00:30:08.870 align:start position:0%
to tell the truth from my experience there is probably a known cases when

00:30:08.880 --> 00:30:11.930 align:start position:0%
there is probably a known cases when you need several versions of the same

00:30:11.940 --> 00:30:13.310 align:start position:0%
you need several versions of the same major entry

00:30:13.320 --> 00:30:17.889 align:start position:0%
major entry in most cases it's even a destructive

00:30:17.899 --> 00:30:20.649 align:start position:0%
in most cases it's even a destructive problem right because

00:30:20.659 --> 00:30:23.510 align:start position:0%
problem right because creating an account or something else

00:30:23.520 --> 00:30:24.680 align:start position:0%
creating an account or something else may

00:30:24.690 --> 00:30:26.149 align:start position:0%
may [Music]

00:30:26.159 --> 00:30:29.090 align:start position:0%
[Music] be a huge problem

00:30:29.100 --> 00:30:32.690 align:start position:0%
be a huge problem I I I'd say that the

00:30:32.700 --> 00:30:35.810 align:start position:0%
I I I'd say that the use case for

00:30:35.820 --> 00:30:39.230 align:start position:0%
use case for like optional recreating

00:30:39.240 --> 00:30:42.350 align:start position:0%
like optional recreating or maintaining several versions of the

00:30:42.360 --> 00:30:48.970 align:start position:0%
or maintaining several versions of the same Ledger entry is a rather

00:30:52.399 --> 00:30:57.169 align:start position:0%
and I haven't seen any use cases for this

00:30:57.179 --> 00:30:59.690 align:start position:0%
seen any use cases for this and just one question that basically

00:30:59.700 --> 00:31:01.730 align:start position:0%
and just one question that basically from the contract

00:31:01.740 --> 00:31:04.070 align:start position:0%
from the contract to host interface tend to point like

00:31:04.080 --> 00:31:08.570 align:start position:0%
to host interface tend to point like there is no version in any Video Edit to

00:31:08.580 --> 00:31:11.090 align:start position:0%
there is no version in any Video Edit to kind of work around some issues in the

00:31:11.100 --> 00:31:14.350 align:start position:0%
kind of work around some issues in the current approach but in general the

00:31:14.360 --> 00:31:16.730 align:start position:0%
current approach but in general the interfaces that like you put something

00:31:16.740 --> 00:31:19.130 align:start position:0%
interfaces that like you put something into storage and it will stay there

00:31:19.140 --> 00:31:21.889 align:start position:0%
into storage and it will stay there quote unquote forever or you know you

00:31:21.899 --> 00:31:24.669 align:start position:0%
quote unquote forever or you know you put it into Temp Storage then it will

00:31:24.679 --> 00:31:27.230 align:start position:0%
put it into Temp Storage then it will be removed after a certain time period

00:31:27.240 --> 00:31:30.110 align:start position:0%
be removed after a certain time period but you know like even from the period

00:31:30.120 --> 00:31:32.750 align:start position:0%
but you know like even from the period is interface standpoint seriously no

00:31:32.760 --> 00:31:35.450 align:start position:0%
is interface standpoint seriously no case for this multiple entry versions

00:31:35.460 --> 00:31:38.269 align:start position:0%
case for this multiple entry versions and I think the main reason they are

00:31:38.279 --> 00:31:41.870 align:start position:0%
and I think the main reason they are thinking of hiding it is just to kind of

00:31:41.880 --> 00:31:46.970 align:start position:0%
thinking of hiding it is just to kind of save some time and cost just to be able

00:31:46.980 --> 00:31:49.909 align:start position:0%
save some time and cost just to be able to quickly create entries without proof

00:31:49.919 --> 00:31:52.010 align:start position:0%
to quickly create entries without proof of Proof Set exclusion but it's more

00:31:52.020 --> 00:31:54.230 align:start position:0%
of Proof Set exclusion but it's more like an implementation detail that

00:31:54.240 --> 00:31:56.330 align:start position:0%
like an implementation detail that unfortunately the contract writers would

00:31:56.340 --> 00:31:58.430 align:start position:0%
unfortunately the contract writers would need to worry about in some cases versus

00:31:58.440 --> 00:32:02.029 align:start position:0%
need to worry about in some cases versus like you know something is there things

00:32:02.039 --> 00:32:05.630 align:start position:0%
like you know something is there things that can be used as a feature or the

00:32:05.640 --> 00:32:08.450 align:start position:0%
that can be used as a feature or the contractor correct like if you need any

00:32:08.460 --> 00:32:11.029 align:start position:0%
contractor correct like if you need any sort of person you can build it yourself

00:32:11.039 --> 00:32:15.289 align:start position:0%
sort of person you can build it yourself using just or as key so what not so I'm

00:32:15.299 --> 00:32:18.110 align:start position:0%
using just or as key so what not so I'm pretty sure there is no legitimate case

00:32:18.120 --> 00:32:21.649 align:start position:0%
pretty sure there is no legitimate case for recreatable storage Beyond it like

00:32:21.659 --> 00:32:26.690 align:start position:0%
for recreatable storage Beyond it like or requirements to the scalability

00:32:26.700 --> 00:32:28.370 align:start position:0%
or requirements to the scalability

00:32:31.399 --> 00:32:33.130 align:start position:0%
yeah yeah like maybe I can add that the reason

00:32:33.140 --> 00:32:36.110 align:start position:0%
the reason right now the the reason we are looking

00:32:36.120 --> 00:32:39.409 align:start position:0%
right now the the reason we are looking at this recruitable storage

00:32:39.419 --> 00:32:40.549 align:start position:0%
at this recruitable storage is

00:32:40.559 --> 00:32:43.310 align:start position:0%
is that we have token balances that are

00:32:43.320 --> 00:32:44.810 align:start position:0%
that we have token balances that are interestingly

00:32:44.820 --> 00:32:48.950 align:start position:0%
interestingly one of the kind of primary use

00:32:48.960 --> 00:32:52.669 align:start position:0%
one of the kind of primary use cases for fast at all right and

00:32:52.679 --> 00:32:55.389 align:start position:0%
cases for fast at all right and if we don't have recreatable

00:32:55.399 --> 00:32:58.310 align:start position:0%
if we don't have recreatable storage we basically have either

00:32:58.320 --> 00:33:01.130 align:start position:0%
storage we basically have either Temporaries right entries which for

00:33:01.140 --> 00:33:03.169 align:start position:0%
Temporaries right entries which for balance is a no-go

00:33:03.179 --> 00:33:06.590 align:start position:0%
balance is a no-go or going with those unique entries

00:33:06.600 --> 00:33:09.409 align:start position:0%
or going with those unique entries and for that you need troops

00:33:09.419 --> 00:33:14.289 align:start position:0%
and for that you need troops to create the balance so the cost of

00:33:14.299 --> 00:33:16.909 align:start position:0%
to create the balance so the cost of an overhead of

00:33:16.919 --> 00:33:19.190 align:start position:0%
an overhead of just kind of setting up your wallet

00:33:19.200 --> 00:33:20.990 align:start position:0%
just kind of setting up your wallet becomes

00:33:21.000 --> 00:33:23.990 align:start position:0%
becomes you know quite quite big for any new

00:33:24.000 --> 00:33:25.430 align:start position:0%
you know quite quite big for any new token that's kind of the the problem

00:33:25.440 --> 00:33:27.590 align:start position:0%
token that's kind of the the problem here is that

00:33:27.600 --> 00:33:30.230 align:start position:0%
here is that I think the overhead of proofs is

00:33:30.240 --> 00:33:32.450 align:start position:0%
I think the overhead of proofs is probably acceptable the first time you

00:33:32.460 --> 00:33:34.009 align:start position:0%
probably acceptable the first time you kind of create your own wallet on your

00:33:34.019 --> 00:33:35.450 align:start position:0%
kind of create your own wallet on your on the network

00:33:35.460 --> 00:33:39.529 align:start position:0%
on the network but anytime you add a balance for any

00:33:39.539 --> 00:33:41.169 align:start position:0%
but anytime you add a balance for any token

00:33:41.179 --> 00:33:43.250 align:start position:0%
token it seems

00:33:43.260 --> 00:33:46.730 align:start position:0%
it seems that having this overhead is kind of

00:33:46.740 --> 00:33:48.769 align:start position:0%
that having this overhead is kind of too much

00:33:48.779 --> 00:33:51.049 align:start position:0%
too much but yeah maybe we that's kind of part

00:33:51.059 --> 00:33:52.970 align:start position:0%
but yeah maybe we that's kind of part of this discussion right to see you know

00:33:52.980 --> 00:33:54.889 align:start position:0%
of this discussion right to see you know are we wrong here

00:33:54.899 --> 00:33:57.409 align:start position:0%
are we wrong here yeah so I guess the the trade-off and

00:33:57.419 --> 00:34:00.590 align:start position:0%
yeah so I guess the the trade-off and with the bloom filter approach where

00:34:00.600 --> 00:34:02.690 align:start position:0%
with the bloom filter approach where you know and let's just put aside like

00:34:02.700 --> 00:34:04.610 align:start position:0%
you know and let's just put aside like the resizing and migration issues for

00:34:04.620 --> 00:34:07.070 align:start position:0%
the resizing and migration issues for now but the bloom filter approach all

00:34:07.080 --> 00:34:08.869 align:start position:0%
now but the bloom filter approach all data is unique

00:34:08.879 --> 00:34:12.829 align:start position:0%
data is unique but the false positive rate is the

00:34:12.839 --> 00:34:14.329 align:start position:0%
but the false positive rate is the percentage of the time that you will

00:34:14.339 --> 00:34:15.770 align:start position:0%
percentage of the time that you will need to provide a proof of exclusion for

00:34:15.780 --> 00:34:18.530 align:start position:0%
need to provide a proof of exclusion for creating new entry and so let's just I

00:34:18.540 --> 00:34:20.270 align:start position:0%
creating new entry and so let's just I guess the trade-off is everything is

00:34:20.280 --> 00:34:22.550 align:start position:0%
guess the trade-off is everything is unique and the interface is easier but

00:34:22.560 --> 00:34:25.250 align:start position:0%
unique and the interface is easier but one out of a thousand Creations are very

00:34:25.260 --> 00:34:26.570 align:start position:0%
one out of a thousand Creations are very slow and require process of create

00:34:26.580 --> 00:34:29.329 align:start position:0%
slow and require process of create precept explosion whereas if we have

00:34:29.339 --> 00:34:32.270 align:start position:0%
precept explosion whereas if we have unique data and recreatable data then

00:34:32.280 --> 00:34:33.889 align:start position:0%
unique data and recreatable data then the unique data is guaranteed to always

00:34:33.899 --> 00:34:35.930 align:start position:0%
the unique data is guaranteed to always be slow but the recreatable data is

00:34:35.940 --> 00:34:38.210 align:start position:0%
be slow but the recreatable data is guaranteed to always be fast and so I

00:34:38.220 --> 00:34:41.510 align:start position:0%
guaranteed to always be fast and so I guess the trade-off is do we want

00:34:41.520 --> 00:34:43.430 align:start position:0%
guess the trade-off is do we want all data to be fast most of the time

00:34:43.440 --> 00:34:45.889 align:start position:0%
all data to be fast most of the time or all data creation to be fast most of

00:34:45.899 --> 00:34:47.329 align:start position:0%
or all data creation to be fast most of the time and sometimes to be really slow

00:34:47.339 --> 00:34:50.089 align:start position:0%
the time and sometimes to be really slow for the easier user interface or have a

00:34:50.099 --> 00:34:52.730 align:start position:0%
for the easier user interface or have a more complex user interface where one

00:34:52.740 --> 00:34:54.409 align:start position:0%
more complex user interface where one type of data is always slow to create

00:34:54.419 --> 00:34:56.210 align:start position:0%
type of data is always slow to create and one type of data is guaranteed

00:34:56.220 --> 00:34:58.190 align:start position:0%
and one type of data is guaranteed always fast to create I guess that's the

00:34:58.200 --> 00:34:59.870 align:start position:0%
always fast to create I guess that's the the fundamental trade-off at least in my

00:34:59.880 --> 00:35:02.270 align:start position:0%
the fundamental trade-off at least in my mind

00:35:03.960 --> 00:35:05.810 align:start position:0%
and that sounds about right like the thing about the blue tilt the other is

00:35:05.820 --> 00:35:07.970 align:start position:0%
thing about the blue tilt the other is that if in the context of like a balance

00:35:07.980 --> 00:35:09.050 align:start position:0%
that if in the context of like a balance right

00:35:09.060 --> 00:35:12.950 align:start position:0%
right the ID the the key right of that balance

00:35:12.960 --> 00:35:15.170 align:start position:0%
the ID the the key right of that balance is actually deterministic

00:35:15.180 --> 00:35:18.710 align:start position:0%
is actually deterministic so as it's deterministic it becomes kind

00:35:18.720 --> 00:35:20.950 align:start position:0%
so as it's deterministic it becomes kind of attackable

00:35:20.960 --> 00:35:23.870 align:start position:0%
of attackable unless we can come up with like a

00:35:23.880 --> 00:35:27.230 align:start position:0%
unless we can come up with like a cryptographic you know Broomfield of

00:35:27.240 --> 00:35:30.650 align:start position:0%
cryptographic you know Broomfield of sorts it's it's very easy to

00:35:30.660 --> 00:35:31.910 align:start position:0%
sorts it's it's very easy to basically

00:35:31.920 --> 00:35:35.569 align:start position:0%
basically you know cause certain keys to be to

00:35:35.579 --> 00:35:37.190 align:start position:0%
you know cause certain keys to be to have complex in the boom filter and then

00:35:37.200 --> 00:35:38.750 align:start position:0%
have complex in the boom filter and then you're kind of back to

00:35:38.760 --> 00:35:40.370 align:start position:0%
you're kind of back to that you know even though it's one in a

00:35:40.380 --> 00:35:42.950 align:start position:0%
that you know even though it's one in a thousand you know if you're the one that

00:35:42.960 --> 00:35:44.690 align:start position:0%
thousand you know if you're the one that is always hit by the

00:35:44.700 --> 00:35:48.790 align:start position:0%
is always hit by the by the one it kind of sucks

00:35:48.800 --> 00:35:54.890 align:start position:0%
by the one it kind of sucks what if we utilize B tree index

00:35:54.900 --> 00:35:58.730 align:start position:0%
what if we utilize B tree index or some other index or like

00:35:58.740 --> 00:36:01.630 align:start position:0%
or some other index or like database actually doing this

00:36:01.640 --> 00:36:06.710 align:start position:0%
database actually doing this and besides that the index itself can

00:36:06.720 --> 00:36:11.470 align:start position:0%
and besides that the index itself can reside on the disk and

00:36:11.480 --> 00:36:16.250 align:start position:0%
reside on the disk and the Fast Cash can be implemented

00:36:16.260 --> 00:36:19.550 align:start position:0%
the Fast Cash can be implemented using the bloom filter and the actual

00:36:19.560 --> 00:36:24.589 align:start position:0%
using the bloom filter and the actual track will be carried over the index for

00:36:24.599 --> 00:36:28.030 align:start position:0%
track will be carried over the index for example B3 index

00:36:31.560 --> 00:36:33.710 align:start position:0%
database handle this I mean the issue with an index is we're

00:36:33.720 --> 00:36:35.270 align:start position:0%
I mean the issue with an index is we're getting to that issue where if we have

00:36:35.280 --> 00:36:37.490 align:start position:0%
getting to that issue where if we have any deterministic index like that we

00:36:37.500 --> 00:36:39.170 align:start position:0%
any deterministic index like that we need to store the keys right

00:36:39.180 --> 00:36:40.490 align:start position:0%
need to store the keys right and then we have that same issue of

00:36:40.500 --> 00:36:42.589 align:start position:0%
and then we have that same issue of unbalanced State growth and especially

00:36:42.599 --> 00:36:44.210 align:start position:0%
unbalanced State growth and especially restore upon data where the keys can

00:36:44.220 --> 00:36:45.770 align:start position:0%
restore upon data where the keys can sometimes be significantly larger to the

00:36:45.780 --> 00:36:46.970 align:start position:0%
sometimes be significantly larger to the value so

00:36:46.980 --> 00:36:50.150 align:start position:0%
value so I think any like deterministic data

00:36:50.160 --> 00:36:51.710 align:start position:0%
I think any like deterministic data structure we can't get back into that

00:36:51.720 --> 00:36:54.050 align:start position:0%
structure we can't get back into that issue of we have unbalanced State versus

00:36:54.060 --> 00:36:55.310 align:start position:0%
issue of we have unbalanced State versus defeats the purpose of the archive in

00:36:55.320 --> 00:36:57.290 align:start position:0%
defeats the purpose of the archive in the first place

00:36:57.300 --> 00:36:59.390 align:start position:0%
the first place yeah I I just want to remind way

00:36:59.400 --> 00:37:01.130 align:start position:0%
yeah I I just want to remind way basically we still need to maintain

00:37:01.140 --> 00:37:03.190 align:start position:0%
basically we still need to maintain consensus and we cannot just like

00:37:03.200 --> 00:37:05.750 align:start position:0%
consensus and we cannot just like randomly update boom shooter for example

00:37:05.760 --> 00:37:08.210 align:start position:0%
randomly update boom shooter for example right it has to be a part of consensus

00:37:08.220 --> 00:37:10.790 align:start position:0%
right it has to be a part of consensus so it would need to come up with some

00:37:10.800 --> 00:37:14.810 align:start position:0%
so it would need to come up with some way to Hash it quickly and add it to the

00:37:14.820 --> 00:37:18.109 align:start position:0%
way to Hash it quickly and add it to the CP values and make sure it's archived

00:37:18.119 --> 00:37:20.530 align:start position:0%
CP values and make sure it's archived properly you know

00:37:20.540 --> 00:37:23.510 align:start position:0%
properly you know significant amount of work and

00:37:23.520 --> 00:37:24.770 align:start position:0%
significant amount of work and I mean

00:37:24.780 --> 00:37:27.530 align:start position:0%
I mean you could say that the keys are stroke

00:37:27.540 --> 00:37:29.630 align:start position:0%
you could say that the keys are stroke in The Ledger forever and then you build

00:37:29.640 --> 00:37:32.569 align:start position:0%
in The Ledger forever and then you build some sort of index on them blockchain

00:37:32.579 --> 00:37:36.050 align:start position:0%
some sort of index on them blockchain but then you know yeah it kind of no

00:37:36.060 --> 00:37:38.150 align:start position:0%
but then you know yeah it kind of no longer fulfills the requirement of

00:37:38.160 --> 00:37:39.190 align:start position:0%
longer fulfills the requirement of having

00:37:39.200 --> 00:37:42.470 align:start position:0%
having limited Venture state cross which we

00:37:42.480 --> 00:37:45.950 align:start position:0%
limited Venture state cross which we wanted to fulfill so it's kind of an

00:37:45.960 --> 00:37:48.589 align:start position:0%
wanted to fulfill so it's kind of an issue and yeah that for what source like

00:37:48.599 --> 00:37:50.870 align:start position:0%
issue and yeah that for what source like it was my first city as well like what

00:37:50.880 --> 00:37:52.670 align:start position:0%
it was my first city as well like what if we just throw keys in The Ledger but

00:37:52.680 --> 00:37:55.250 align:start position:0%
if we just throw keys in The Ledger but yeah that unfortunately kind of doesn't

00:37:55.260 --> 00:37:57.770 align:start position:0%
yeah that unfortunately kind of doesn't scale as well

00:37:57.780 --> 00:38:01.069 align:start position:0%
scale as well yeah so I think I think the Bloom

00:38:01.079 --> 00:38:03.050 align:start position:0%
yeah so I think I think the Bloom filter with a proof of exclusion

00:38:03.060 --> 00:38:05.210 align:start position:0%
filter with a proof of exclusion fallback for false positives it's an

00:38:05.220 --> 00:38:06.890 align:start position:0%
fallback for false positives it's an interesting idea I think we probably

00:38:06.900 --> 00:38:09.410 align:start position:0%
interesting idea I think we probably have some technical homework to do there

00:38:09.420 --> 00:38:10.430 align:start position:0%
have some technical homework to do there so I think it's all right for

00:38:10.440 --> 00:38:12.349 align:start position:0%
so I think it's all right for everyone to move on to the second

00:38:12.359 --> 00:38:15.170 align:start position:0%
everyone to move on to the second topic

00:38:17.040 --> 00:38:19.510 align:start position:0%
I'm not hearing any objection Celtic as yes so kind of slipping away from the

00:38:19.520 --> 00:38:23.150 align:start position:0%
yes so kind of slipping away from the user interface now talking about how the

00:38:23.160 --> 00:38:26.030 align:start position:0%
user interface now talking about how the archiver interface will be set up and so

00:38:26.040 --> 00:38:28.069 align:start position:0%
archiver interface will be set up and so currently

00:38:28.079 --> 00:38:30.349 align:start position:0%
currently there are kind of like two proposals

00:38:30.359 --> 00:38:32.329 align:start position:0%
there are kind of like two proposals one where we have an archive

00:38:32.339 --> 00:38:34.069 align:start position:0%
one where we have an archive interface that's a functions similar to

00:38:34.079 --> 00:38:37.250 align:start position:0%
interface that's a functions similar to capture how Horizon functions now where

00:38:37.260 --> 00:38:40.490 align:start position:0%
capture how Horizon functions now where you go to a specific archiver you have

00:38:40.500 --> 00:38:43.430 align:start position:0%
you go to a specific archiver you have some URL endpoint and then you query

00:38:43.440 --> 00:38:45.770 align:start position:0%
some URL endpoint and then you query that endpoint with the keys you want to

00:38:45.780 --> 00:38:47.390 align:start position:0%
that endpoint with the keys you want to be archived

00:38:47.400 --> 00:38:49.550 align:start position:0%
be archived and so this is like a a model similar

00:38:49.560 --> 00:38:51.589 align:start position:0%
and so this is like a a model similar to what we have today with Verizon some

00:38:51.599 --> 00:38:53.810 align:start position:0%
to what we have today with Verizon some of the pros there's pros and cons

00:38:53.820 --> 00:38:55.190 align:start position:0%
of the pros there's pros and cons what are the cons that you have to have

00:38:55.200 --> 00:38:57.290 align:start position:0%
what are the cons that you have to have like a personal relationship or at least

00:38:57.300 --> 00:38:59.569 align:start position:0%
like a personal relationship or at least know an archiver to go to

00:38:59.579 --> 00:39:02.089 align:start position:0%
know an archiver to go to and then it's not super clear how we

00:39:02.099 --> 00:39:04.609 align:start position:0%
and then it's not super clear how we could incentivize or monetize this sort

00:39:04.619 --> 00:39:06.890 align:start position:0%
could incentivize or monetize this sort of interface perhaps you would have to

00:39:06.900 --> 00:39:08.329 align:start position:0%
of interface perhaps you would have to like pay a monthly subscription to the

00:39:08.339 --> 00:39:10.849 align:start position:0%
like pay a monthly subscription to the archive or perhaps you'd have some

00:39:10.859 --> 00:39:13.190 align:start position:0%
archive or perhaps you'd have some relationship where you like pay your

00:39:13.200 --> 00:39:14.810 align:start position:0%
relationship where you like pay your archive or per entry lookup or something

00:39:14.820 --> 00:39:17.089 align:start position:0%
archive or per entry lookup or something like that but it's not super clear how

00:39:17.099 --> 00:39:19.250 align:start position:0%
like that but it's not super clear how we incentivize people actually brought

00:39:19.260 --> 00:39:22.069 align:start position:0%
we incentivize people actually brought in archivers in this setup so the second

00:39:22.079 --> 00:39:26.030 align:start position:0%
in archivers in this setup so the second scenario is where we have kind of

00:39:26.040 --> 00:39:28.310 align:start position:0%
scenario is where we have kind of what I'm referring to as the archive

00:39:28.320 --> 00:39:31.069 align:start position:0%
what I'm referring to as the archive miners kind of stealing the minor

00:39:31.079 --> 00:39:32.870 align:start position:0%
miners kind of stealing the minor terminology from Bitcoin

00:39:32.880 --> 00:39:34.730 align:start position:0%
terminology from Bitcoin so essentially how this would work

00:39:34.740 --> 00:39:37.010 align:start position:0%
so essentially how this would work is instead of acquiring an archiver

00:39:37.020 --> 00:39:39.890 align:start position:0%
is instead of acquiring an archiver directly whenever you need a proof you

00:39:39.900 --> 00:39:42.230 align:start position:0%
directly whenever you need a proof you submit a proof request

00:39:42.240 --> 00:39:44.690 align:start position:0%
submit a proof request on chain now this could either be

00:39:44.700 --> 00:39:46.370 align:start position:0%
on chain now this could either be implemented at the protocol level where

00:39:46.380 --> 00:39:48.589 align:start position:0%
implemented at the protocol level where proof request is an operation or this

00:39:48.599 --> 00:39:50.450 align:start position:0%
proof request is an operation or this might also be able to be implemented by

00:39:50.460 --> 00:39:52.849 align:start position:0%
might also be able to be implemented by like a first party smart contract but

00:39:52.859 --> 00:39:53.810 align:start position:0%
like a first party smart contract but that's not really important right now

00:39:53.820 --> 00:39:55.910 align:start position:0%
that's not really important right now but essentially you would just submit an

00:39:55.920 --> 00:39:58.250 align:start position:0%
but essentially you would just submit an operation that requests an archival

00:39:58.260 --> 00:40:00.710 align:start position:0%
operation that requests an archival proof and then by submitting this

00:40:00.720 --> 00:40:02.329 align:start position:0%
proof and then by submitting this operation you'd submit meta information

00:40:02.339 --> 00:40:04.849 align:start position:0%
operation you'd submit meta information that archivers could then adjust and

00:40:04.859 --> 00:40:06.230 align:start position:0%
that archivers could then adjust and that's how the archivers would know

00:40:06.240 --> 00:40:08.329 align:start position:0%
that's how the archivers would know about the requests and as part of this

00:40:08.339 --> 00:40:11.270 align:start position:0%
about the requests and as part of this operation you would say the key you want

00:40:11.280 --> 00:40:13.490 align:start position:0%
operation you would say the key you want to be proven the type of proof select

00:40:13.500 --> 00:40:15.470 align:start position:0%
to be proven the type of proof select proof of inclusion proof exclusion and

00:40:15.480 --> 00:40:18.109 align:start position:0%
proof of inclusion proof exclusion and then also a reward and this reward would

00:40:18.119 --> 00:40:21.170 align:start position:0%
then also a reward and this reward would be variable and you would be the

00:40:21.180 --> 00:40:22.970 align:start position:0%
be variable and you would be the would be at the user's discretion as to

00:40:22.980 --> 00:40:25.730 align:start position:0%
would be at the user's discretion as to what to set this reward to and then this

00:40:25.740 --> 00:40:27.650 align:start position:0%
what to set this reward to and then this operation this request would go on chain

00:40:27.660 --> 00:40:30.770 align:start position:0%
operation this request would go on chain and the metal would be a submit and so

00:40:30.780 --> 00:40:33.109 align:start position:0%
and the metal would be a submit and so an archival within Injustice meta and

00:40:33.119 --> 00:40:35.270 align:start position:0%
an archival within Injustice meta and then pick what

00:40:35.280 --> 00:40:38.210 align:start position:0%
then pick what requests they want to service and so

00:40:38.220 --> 00:40:39.950 align:start position:0%
requests they want to service and so they could reservice the request that

00:40:39.960 --> 00:40:42.230 align:start position:0%
they could reservice the request that has the highest reward first

00:40:42.240 --> 00:40:44.690 align:start position:0%
has the highest reward first and then they construct the proof

00:40:44.700 --> 00:40:46.670 align:start position:0%
and then they construct the proof with the information that they store and

00:40:46.680 --> 00:40:47.870 align:start position:0%
with the information that they store and then they submit the proof another

00:40:47.880 --> 00:40:50.990 align:start position:0%
then they submit the proof another operation and then the proof itself

00:40:51.000 --> 00:40:54.109 align:start position:0%
operation and then the proof itself becomes an entry on The Ledger and so

00:40:54.119 --> 00:40:56.089 align:start position:0%
becomes an entry on The Ledger and so once that proof has been submitted and

00:40:56.099 --> 00:40:57.829 align:start position:0%
once that proof has been submitted and validated and the proof is on Ledger

00:40:57.839 --> 00:41:01.609 align:start position:0%
validated and the proof is on Ledger then the proof or the proof request is

00:41:01.619 --> 00:41:04.069 align:start position:0%
then the proof or the proof request is deleted and the reward is given to

00:41:04.079 --> 00:41:07.430 align:start position:0%
deleted and the reward is given to whoever submitted the correct archival

00:41:07.440 --> 00:41:10.310 align:start position:0%
whoever submitted the correct archival proof first and so this is I think a

00:41:10.320 --> 00:41:12.290 align:start position:0%
proof first and so this is I think a better interface because it has a

00:41:12.300 --> 00:41:14.329 align:start position:0%
better interface because it has a clearly defined incentive structure and

00:41:14.339 --> 00:41:16.130 align:start position:0%
clearly defined incentive structure and also doesn't require any personal

00:41:16.140 --> 00:41:18.170 align:start position:0%
also doesn't require any personal relationships with an archiver and so

00:41:18.180 --> 00:41:20.150 align:start position:0%
relationships with an archiver and so you don't have to have a URL that you

00:41:20.160 --> 00:41:21.950 align:start position:0%
you don't have to have a URL that you talk to or you don't have to have a

00:41:21.960 --> 00:41:23.630 align:start position:0%
talk to or you don't have to have a relationship with some company that you

00:41:23.640 --> 00:41:25.310 align:start position:0%
relationship with some company that you pay monthly to pay some subscription fee

00:41:25.320 --> 00:41:28.010 align:start position:0%
pay monthly to pay some subscription fee in order to access the archive it also

00:41:28.020 --> 00:41:30.950 align:start position:0%
in order to access the archive it also allows archivers to freely

00:41:30.960 --> 00:41:33.710 align:start position:0%
allows archivers to freely enter and exit the network as they

00:41:33.720 --> 00:41:36.230 align:start position:0%
enter and exit the network as they please and also by having a variable

00:41:36.240 --> 00:41:39.170 align:start position:0%
please and also by having a variable reward that the user can set you can

00:41:39.180 --> 00:41:41.329 align:start position:0%
reward that the user can set you can also have essentially like a built-in

00:41:41.339 --> 00:41:43.430 align:start position:0%
also have essentially like a built-in supply and demand Dynamics where that

00:41:43.440 --> 00:41:45.410 align:start position:0%
supply and demand Dynamics where that price fluctuates over time depending on

00:41:45.420 --> 00:41:47.950 align:start position:0%
price fluctuates over time depending on how many people want to restore

00:41:47.960 --> 00:41:50.329 align:start position:0%
how many people want to restore archived entries and how many archivers

00:41:50.339 --> 00:41:52.849 align:start position:0%
archived entries and how many archivers want to service archives and so I guess

00:41:52.859 --> 00:41:54.770 align:start position:0%
want to service archives and so I guess generally speaking what are your

00:41:54.780 --> 00:41:56.390 align:start position:0%
generally speaking what are your thoughts on the two approaches and

00:41:56.400 --> 00:41:58.069 align:start position:0%
thoughts on the two approaches and kind of the leading approach being this

00:41:58.079 --> 00:42:01.130 align:start position:0%
kind of the leading approach being this I'm submitting proof request to the

00:42:01.140 --> 00:42:03.710 align:start position:0%
I'm submitting proof request to the chain and then having archivers read

00:42:03.720 --> 00:42:05.870 align:start position:0%
chain and then having archivers read the chain and then submit the proofs

00:42:05.880 --> 00:42:14.990 align:start position:0%
the chain and then submit the proofs how do we feel about that

00:42:17.099 --> 00:42:18.950 align:start position:0%
have you ever speak let's see so like the the thing I'm

00:42:18.960 --> 00:42:22.310 align:start position:0%
let's see so like the the thing I'm thinking of right in terms of like

00:42:22.320 --> 00:42:25.730 align:start position:0%
thinking of right in terms of like meaningful viable product I'm

00:42:25.740 --> 00:42:29.270 align:start position:0%
meaningful viable product I'm thinking the having a way to talk

00:42:29.280 --> 00:42:33.849 align:start position:0%
thinking the having a way to talk directly to archives is is kind of a

00:42:33.859 --> 00:42:37.069 align:start position:0%
directly to archives is is kind of a foolproof

00:42:37.079 --> 00:42:38.270 align:start position:0%
foolproof

00:42:40.980 --> 00:42:42.770 align:start position:0%
the the approach where you use the on-chain state

00:42:42.780 --> 00:42:45.890 align:start position:0%
on-chain state I think I mean it's I think there

00:42:45.900 --> 00:42:47.810 align:start position:0%
I think I mean it's I think there is like good potential there I think

00:42:47.820 --> 00:42:50.030 align:start position:0%
is like good potential there I think it's it's going to be fairly tricky

00:42:50.040 --> 00:42:53.150 align:start position:0%
it's it's going to be fairly tricky to get this right the reason being

00:42:53.160 --> 00:42:56.210 align:start position:0%
to get this right the reason being that basically

00:42:56.220 --> 00:42:56.930 align:start position:0%
that basically

00:42:59.940 --> 00:43:02.329 align:start position:0%
your so you have you're not creating like intrinsic

00:43:02.339 --> 00:43:05.329 align:start position:0%
you're not creating like intrinsic value right to certain transactions

00:43:05.339 --> 00:43:08.510 align:start position:0%
value right to certain transactions that are being published on the

00:43:08.520 --> 00:43:12.020 align:start position:0%
that are being published on the overlay and therefore a

00:43:12.030 --> 00:43:13.309 align:start position:0%
overlay and therefore a [Music]

00:43:13.319 --> 00:43:16.250 align:start position:0%
[Music] like a board of source right can can

00:43:16.260 --> 00:43:19.609 align:start position:0%
like a board of source right can can look at this overlay traffic and

00:43:19.619 --> 00:43:22.250 align:start position:0%
look at this overlay traffic and don't run take the data right that is

00:43:22.260 --> 00:43:24.890 align:start position:0%
don't run take the data right that is the primage right the proof

00:43:24.900 --> 00:43:27.829 align:start position:0%
the primage right the proof and from the the archival that

00:43:27.839 --> 00:43:29.329 align:start position:0%
and from the the archival that actually did the work

00:43:29.339 --> 00:43:31.670 align:start position:0%
actually did the work and benefit from the academy so I think

00:43:31.680 --> 00:43:32.870 align:start position:0%
and benefit from the academy so I think there is like an interesting problem

00:43:32.880 --> 00:43:34.309 align:start position:0%
there is like an interesting problem there to solve

00:43:34.319 --> 00:43:38.349 align:start position:0%
there to solve in terms of like how can you safely

00:43:38.359 --> 00:43:43.130 align:start position:0%
in terms of like how can you safely disclose the the proof to the

00:43:43.140 --> 00:43:48.849 align:start position:0%
disclose the the proof to the network without being from

00:43:50.700 --> 00:43:53.150 align:start position:0%
sinus right interesting some entities that

00:43:53.160 --> 00:43:55.190 align:start position:0%
interesting some entities that can be signing it

00:43:55.200 --> 00:43:57.050 align:start position:0%
can be signing it refining

00:43:57.060 --> 00:43:59.030 align:start position:0%
refining well the issue that was signing is how

00:43:59.040 --> 00:44:01.550 align:start position:0%
well the issue that was signing is how can like like the mental not just

00:44:01.560 --> 00:44:02.930 align:start position:0%
can like like the mental not just like take your proof and then sign with

00:44:02.940 --> 00:44:04.069 align:start position:0%
like take your proof and then sign with its own address

00:44:04.079 --> 00:44:06.650 align:start position:0%
its own address and then submit as if it was the

00:44:06.660 --> 00:44:12.710 align:start position:0%
and then submit as if it was the originator

00:44:12.720 --> 00:44:25.790 align:start position:0%
yeah that's fair I'm not sure

00:44:27.720 --> 00:44:31.309 align:start position:0%
and I think there might be ways to do it right like it's a it's a

00:44:34.859 --> 00:44:36.829 align:start position:0%
maybe what you you you you it's like a multiple multi-step thing right where

00:44:36.839 --> 00:44:39.410 align:start position:0%
multiple multi-step thing right where you you because you were first to

00:44:39.420 --> 00:44:41.450 align:start position:0%
you you because you were first to disclose let's say the harsh of the

00:44:41.460 --> 00:44:42.890 align:start position:0%
disclose let's say the harsh of the proof

00:44:42.900 --> 00:44:44.690 align:start position:0%
proof before you actually disclosure proof

00:44:44.700 --> 00:44:46.730 align:start position:0%
before you actually disclosure proof then you're the one you know if it's a

00:44:46.740 --> 00:44:49.790 align:start position:0%
then you're the one you know if it's a contract that's doing the that work

00:44:49.800 --> 00:44:53.210 align:start position:0%
contract that's doing the that work then we can basically give the

00:44:53.220 --> 00:44:56.150 align:start position:0%
then we can basically give the the first you know first one

00:44:56.160 --> 00:44:58.370 align:start position:0%
the first you know first one the benefit I mean at the same time like

00:44:58.380 --> 00:44:59.750 align:start position:0%
the benefit I mean at the same time like a

00:44:59.760 --> 00:45:02.210 align:start position:0%
a yeah maybe a bot can I mean it becomes

00:45:02.220 --> 00:45:06.589 align:start position:0%
yeah maybe a bot can I mean it becomes kind of a a cat and you know a nice game

00:45:06.599 --> 00:45:09.109 align:start position:0%
kind of a a cat and you know a nice game right like where you

00:45:09.119 --> 00:45:10.730 align:start position:0%
right like where you yeah

00:45:10.740 --> 00:45:13.790 align:start position:0%
yeah how to do this safely

00:45:13.800 --> 00:45:15.950 align:start position:0%
how to do this safely yeah I think in the front room

00:45:15.960 --> 00:45:17.510 align:start position:0%
yeah I think in the front room like because you know yours are like

00:45:17.520 --> 00:45:19.849 align:start position:0%
like because you know yours are like super nice people that maybe on I

00:45:19.859 --> 00:45:23.870 align:start position:0%
super nice people that maybe on I mean not trying to game the system

00:45:26.400 --> 00:45:28.670 align:start position:0%
yeah I I thought like the the front running I did was just to like if

00:45:28.680 --> 00:45:30.290 align:start position:0%
running I did was just to like if they're the same proofs multiple the

00:45:30.300 --> 00:45:32.030 align:start position:0%
they're the same proofs multiple the same proofs in the same block just or

00:45:32.040 --> 00:45:33.770 align:start position:0%
same proofs in the same block just or randomly pick one but I didn't think

00:45:33.780 --> 00:45:36.050 align:start position:0%
randomly pick one but I didn't think about this proof stealing case

00:45:36.060 --> 00:45:38.510 align:start position:0%
about this proof stealing case in front running by stealing proof so

00:45:38.520 --> 00:45:40.430 align:start position:0%
in front running by stealing proof so this is definitely an interesting issue

00:45:40.440 --> 00:45:43.730 align:start position:0%
this is definitely an interesting issue to think about but I still I still like

00:45:43.740 --> 00:45:45.589 align:start position:0%
to think about but I still I still like the model where you don't have to have a

00:45:45.599 --> 00:45:47.210 align:start position:0%
the model where you don't have to have a relationship with the archive for a

00:45:47.220 --> 00:45:49.190 align:start position:0%
relationship with the archive for a couple of reasons so first

00:45:49.200 --> 00:45:51.349 align:start position:0%
couple of reasons so first it's likely that especially you know

00:45:51.359 --> 00:45:53.030 align:start position:0%
it's likely that especially you know if the archive systems run for a long

00:45:53.040 --> 00:45:56.089 align:start position:0%
if the archive systems run for a long time archivers will not store the entire

00:45:56.099 --> 00:45:59.630 align:start position:0%
time archivers will not store the entire archive I think it's a good idea to let

00:45:59.640 --> 00:46:02.150 align:start position:0%
archive I think it's a good idea to let the archive pick and choose how much or

00:46:02.160 --> 00:46:04.010 align:start position:0%
the archive pick and choose how much or how little of his or of the archive

00:46:04.020 --> 00:46:05.870 align:start position:0%
how little of his or of the archive history they want to store and so I can

00:46:05.880 --> 00:46:07.730 align:start position:0%
history they want to store and so I can see an archiver that only stores the

00:46:07.740 --> 00:46:09.410 align:start position:0%
see an archiver that only stores the last five years one that stores the last

00:46:09.420 --> 00:46:11.210 align:start position:0%
last five years one that stores the last 10 years and then one that's like a more

00:46:11.220 --> 00:46:12.650 align:start position:0%
10 years and then one that's like a more expensive on the stores like the last 50

00:46:12.660 --> 00:46:14.870 align:start position:0%
expensive on the stores like the last 50 years for instance I think if you have

00:46:14.880 --> 00:46:17.329 align:start position:0%
years for instance I think if you have to like individually query an archiver

00:46:17.339 --> 00:46:20.150 align:start position:0%
to like individually query an archiver you have this weird interface where for

00:46:20.160 --> 00:46:21.890 align:start position:0%
you have this weird interface where for things that are three years old you can

00:46:21.900 --> 00:46:23.930 align:start position:0%
things that are three years old you can maybe query a cheap archiver and then

00:46:23.940 --> 00:46:25.190 align:start position:0%
maybe query a cheap archiver and then for things that are older you have to

00:46:25.200 --> 00:46:27.050 align:start position:0%
for things that are older you have to change your URL or something like that

00:46:27.060 --> 00:46:28.790 align:start position:0%
change your URL or something like that to Target like a different archive that

00:46:28.800 --> 00:46:30.050 align:start position:0%
to Target like a different archive that has more history state or something like

00:46:30.060 --> 00:46:32.210 align:start position:0%
has more history state or something like that and so I think there's still some

00:46:32.220 --> 00:46:35.210 align:start position:0%
that and so I think there's still some some interface issues with having to

00:46:35.220 --> 00:46:38.089 align:start position:0%
some interface issues with having to talk to the archiver directly but at

00:46:38.099 --> 00:46:39.290 align:start position:0%
talk to the archiver directly but at least on the top of my head I don't have

00:46:39.300 --> 00:46:41.750 align:start position:0%
least on the top of my head I don't have a great solution to the stealing proofs

00:46:41.760 --> 00:46:43.010 align:start position:0%
a great solution to the stealing proofs thing

00:46:43.020 --> 00:46:46.609 align:start position:0%
thing I think that's the challenges

00:46:50.040 --> 00:46:53.630 align:start position:0%
yeah I was going to say like the the I think it's it's a we should definitely

00:46:53.640 --> 00:46:56.030 align:start position:0%
I think it's it's a we should definitely be looking into those mechanisms that

00:46:56.040 --> 00:46:57.950 align:start position:0%
be looking into those mechanisms that are like a little more distributed right

00:46:57.960 --> 00:47:01.430 align:start position:0%
are like a little more distributed right from a you know Discovery Point of View

00:47:01.440 --> 00:47:02.450 align:start position:0%
from a you know Discovery Point of View

00:47:05.940 --> 00:47:07.790 align:start position:0%
I think all it means is that we use

00:47:07.800 --> 00:47:10.970 align:start position:0%
we use we we have the proper semantics on

00:47:10.980 --> 00:47:13.910 align:start position:0%
we we have the proper semantics on network to allow for for doing this so

00:47:13.920 --> 00:47:15.589 align:start position:0%
network to allow for for doing this so like I think for example like the thing

00:47:15.599 --> 00:47:18.130 align:start position:0%
like I think for example like the thing where we have

00:47:18.140 --> 00:47:22.670 align:start position:0%
where we have proofs that are usable independently of

00:47:22.680 --> 00:47:26.329 align:start position:0%
proofs that are usable independently of using you know the entries

00:47:26.339 --> 00:47:29.809 align:start position:0%
using you know the entries yeah I think this is like a a key

00:47:29.819 --> 00:47:31.370 align:start position:0%
yeah I think this is like a a key property that we need to have right

00:47:31.380 --> 00:47:34.309 align:start position:0%
property that we need to have right because I I know like one of the earlier

00:47:34.319 --> 00:47:35.990 align:start position:0%
because I I know like one of the earlier drafts

00:47:36.000 --> 00:47:38.930 align:start position:0%
drafts was requiring people to submit proofs

00:47:38.940 --> 00:47:41.750 align:start position:0%
was requiring people to submit proofs in the same transaction that they

00:47:41.760 --> 00:47:43.910 align:start position:0%
in the same transaction that they were going to use the you know the

00:47:43.920 --> 00:47:45.470 align:start position:0%
were going to use the you know the actual and actually restore the entry

00:47:45.480 --> 00:47:47.990 align:start position:0%
actual and actually restore the entry and obviously this this would not

00:47:48.000 --> 00:47:49.849 align:start position:0%
and obviously this this would not work in you know would not enable the

00:47:49.859 --> 00:47:51.230 align:start position:0%
work in you know would not enable the type of

00:47:51.240 --> 00:47:56.390 align:start position:0%
type of of scenarios

00:47:59.160 --> 00:48:01.130 align:start position:0%
yeah I definitely like having having the or the proofs themselves be Ledger

00:48:01.140 --> 00:48:01.970 align:start position:0%
or the proofs themselves be Ledger entries

00:48:01.980 --> 00:48:03.950 align:start position:0%
entries I just I think we just need to find the

00:48:03.960 --> 00:48:05.510 align:start position:0%
I just I think we just need to find the the best way to

00:48:05.520 --> 00:48:07.790 align:start position:0%
the best way to to make sure the system isn't getting it

00:48:07.800 --> 00:48:12.109 align:start position:0%
to make sure the system isn't getting it or gained

00:48:14.760 --> 00:48:15.950 align:start position:0%
yeah yeah there's a because there's not a clear solution because I mean you

00:48:15.960 --> 00:48:17.510 align:start position:0%
a clear solution because I mean you could submit say like before you submit

00:48:17.520 --> 00:48:19.190 align:start position:0%
could submit say like before you submit the proof If you submit the hash to say

00:48:19.200 --> 00:48:21.109 align:start position:0%
the proof If you submit the hash to say hey I was here first and then submit the

00:48:21.119 --> 00:48:22.730 align:start position:0%
hey I was here first and then submit the proof of the next Ledger but then you

00:48:22.740 --> 00:48:24.349 align:start position:0%
proof of the next Ledger but then you could open yourself up to Dos attacks

00:48:24.359 --> 00:48:26.809 align:start position:0%
could open yourself up to Dos attacks for a malicious user could just generate

00:48:26.819 --> 00:48:28.730 align:start position:0%
for a malicious user could just generate a bunch of dummy proofs and then submit

00:48:28.740 --> 00:48:30.470 align:start position:0%
a bunch of dummy proofs and then submit them for every archive request and then

00:48:30.480 --> 00:48:32.390 align:start position:0%
them for every archive request and then archivers would not want to service

00:48:32.400 --> 00:48:33.470 align:start position:0%
archivers would not want to service those requests because something's

00:48:33.480 --> 00:48:35.510 align:start position:0%
those requests because something's already spoken for it and issues like

00:48:35.520 --> 00:48:37.430 align:start position:0%
already spoken for it and issues like that so

00:48:37.440 --> 00:48:39.290 align:start position:0%
that so so I think we need to think about but I

00:48:39.300 --> 00:48:40.670 align:start position:0%
so I think we need to think about but I definitely like I think we definitely

00:48:40.680 --> 00:48:43.190 align:start position:0%
definitely like I think we definitely should have the proofs on chain like

00:48:43.200 --> 00:48:44.569 align:start position:0%
should have the proofs on chain like you mentioned

00:48:44.579 --> 00:48:45.829 align:start position:0%
you mentioned and we should see if there's a way to

00:48:45.839 --> 00:48:47.270 align:start position:0%
and we should see if there's a way to solve this issue in a way that makes

00:48:47.280 --> 00:48:51.170 align:start position:0%
solve this issue in a way that makes sense

00:48:53.280 --> 00:48:55.190 align:start position:0%
if you have a you know a few more minutes left was there like some

00:48:55.200 --> 00:48:56.510 align:start position:0%
minutes left was there like some other

00:48:56.520 --> 00:48:58.370 align:start position:0%
other topic that you wanted to cover as part

00:48:58.380 --> 00:49:01.010 align:start position:0%
topic that you wanted to cover as part of of this yes I guess one other

00:49:01.020 --> 00:49:02.390 align:start position:0%
of of this yes I guess one other question that's kind of that we don't

00:49:02.400 --> 00:49:03.950 align:start position:0%
question that's kind of that we don't have a great solution for

00:49:03.960 --> 00:49:05.450 align:start position:0%
have a great solution for and this is one that we need to

00:49:05.460 --> 00:49:06.650 align:start position:0%
and this is one that we need to figure out here pretty soon because it's

00:49:06.660 --> 00:49:09.710 align:start position:0%
figure out here pretty soon because it's required to launch for v0 is how to bump

00:49:09.720 --> 00:49:12.050 align:start position:0%
required to launch for v0 is how to bump rent and so right now whenever you

00:49:12.060 --> 00:49:13.370 align:start position:0%
rent and so right now whenever you create an entry

00:49:13.380 --> 00:49:15.050 align:start position:0%
create an entry it's created and initializes rent

00:49:15.060 --> 00:49:17.210 align:start position:0%
it's created and initializes rent balance to some amount but there doesn't

00:49:17.220 --> 00:49:19.430 align:start position:0%
balance to some amount but there doesn't seem to be a great way in order to bump

00:49:19.440 --> 00:49:21.410 align:start position:0%
seem to be a great way in order to bump rent and to actually increase that rent

00:49:21.420 --> 00:49:23.690 align:start position:0%
rent and to actually increase that rent balance and so kind of the initial

00:49:23.700 --> 00:49:25.970 align:start position:0%
balance and so kind of the initial thought was Hey whenever you access

00:49:25.980 --> 00:49:28.490 align:start position:0%
thought was Hey whenever you access something increase the rent

00:49:28.500 --> 00:49:30.109 align:start position:0%
something increase the rent and that's way that the things that

00:49:30.119 --> 00:49:31.790 align:start position:0%
and that's way that the things that are accessed most commonly automatically

00:49:31.800 --> 00:49:33.770 align:start position:0%
are accessed most commonly automatically have their rent increased and so if you

00:49:33.780 --> 00:49:35.329 align:start position:0%
have their rent increased and so if you access something a lot it will most

00:49:35.339 --> 00:49:36.470 align:start position:0%
access something a lot it will most likely be on the buy policy and we'll

00:49:36.480 --> 00:49:38.870 align:start position:0%
likely be on the buy policy and we'll have to unarchive it now for read write

00:49:38.880 --> 00:49:41.510 align:start position:0%
have to unarchive it now for read write items it's easy because you have to

00:49:41.520 --> 00:49:43.069 align:start position:0%
items it's easy because you have to rewrite the entry anyway so you might as

00:49:43.079 --> 00:49:45.829 align:start position:0%
rewrite the entry anyway so you might as well bump the rent however it's not

00:49:45.839 --> 00:49:48.170 align:start position:0%
well bump the rent however it's not clear how to bump rent on read only

00:49:48.180 --> 00:49:50.450 align:start position:0%
clear how to bump rent on read only items so for instance

00:49:50.460 --> 00:49:52.490 align:start position:0%
items so for instance if you have auth

00:49:52.500 --> 00:49:54.170 align:start position:0%
if you have auth say like an auth record that's almost

00:49:54.180 --> 00:49:57.109 align:start position:0%
say like an auth record that's almost never changed but is read often

00:49:57.119 --> 00:49:57.770 align:start position:0%
never changed but is read often

00:50:01.020 --> 00:50:02.870 align:start position:0%
you would want to bump the rent on reads so that you wouldn't have to constantly

00:50:02.880 --> 00:50:05.990 align:start position:0%
so that you wouldn't have to constantly unarchive it the issue is because the

00:50:06.000 --> 00:50:07.370 align:start position:0%
unarchive it the issue is because the way the bucket list is structured

00:50:07.380 --> 00:50:10.670 align:start position:0%
way the bucket list is structured there's no way to bump rent without

00:50:10.680 --> 00:50:13.790 align:start position:0%
there's no way to bump rent without rewriting the entry because

00:50:13.800 --> 00:50:15.349 align:start position:0%
rewriting the entry because essentially the way the bucket list

00:50:15.359 --> 00:50:17.270 align:start position:0%
essentially the way the bucket list is structured entries and buckets are

00:50:17.280 --> 00:50:19.490 align:start position:0%
is structured entries and buckets are immutable and so in order to update an

00:50:19.500 --> 00:50:21.470 align:start position:0%
immutable and so in order to update an entry it's not like SQL you can just go

00:50:21.480 --> 00:50:23.089 align:start position:0%
entry it's not like SQL you can just go to the entry and then change a value you

00:50:23.099 --> 00:50:25.190 align:start position:0%
to the entry and then change a value you have to completely rewrite the entry and

00:50:25.200 --> 00:50:28.250 align:start position:0%
have to completely rewrite the entry and so we wouldn't want to bump rent on

00:50:28.260 --> 00:50:30.530 align:start position:0%
so we wouldn't want to bump rent on every read because then we're implicitly

00:50:30.540 --> 00:50:32.690 align:start position:0%
every read because then we're implicitly at the systems level turning reads into

00:50:32.700 --> 00:50:34.910 align:start position:0%
at the systems level turning reads into read writes which we don't want to do

00:50:34.920 --> 00:50:37.190 align:start position:0%
read writes which we don't want to do and so I guess in the read write case

00:50:37.200 --> 00:50:39.230 align:start position:0%
and so I guess in the read write case we obviously want to bump rent but I was

00:50:39.240 --> 00:50:41.030 align:start position:0%
we obviously want to bump rent but I was wondering if there are any ideas as to

00:50:41.040 --> 00:50:43.309 align:start position:0%
wondering if there are any ideas as to what to do for like read-only data and

00:50:43.319 --> 00:50:54.130 align:start position:0%
what to do for like read-only data and how to handle rent in that regard

00:50:58.260 --> 00:50:59.690 align:start position:0%
well simple way I've been thinking about is

00:50:59.700 --> 00:51:02.690 align:start position:0%
about is well you just said with online but you

00:51:02.700 --> 00:51:04.910 align:start position:0%
well you just said with online but you know I'm exposed just some contract

00:51:04.920 --> 00:51:07.250 align:start position:0%
know I'm exposed just some contract function but that's free tried access to

00:51:07.260 --> 00:51:09.829 align:start position:0%
function but that's free tried access to the entries that you want to bomb

00:51:09.839 --> 00:51:11.690 align:start position:0%
the entries that you want to bomb and nothing else

00:51:11.700 --> 00:51:12.370 align:start position:0%
and nothing else

00:51:14.960 --> 00:51:17.270 align:start position:0%
that will basically you know to call just as any other

00:51:17.280 --> 00:51:20.750 align:start position:0%
you know to call just as any other contract function to bounce around

00:51:20.760 --> 00:51:24.290 align:start position:0%
contract function to bounce around but that maybe can be generalized to

00:51:24.300 --> 00:51:27.710 align:start position:0%
but that maybe can be generalized to you know post functions that allows you

00:51:27.720 --> 00:51:31.370 align:start position:0%
you know post functions that allows you action arbitrary entries without

00:51:31.380 --> 00:51:33.109 align:start position:0%
action arbitrary entries without accessing them so that you know you

00:51:33.119 --> 00:51:35.870 align:start position:0%
accessing them so that you know you don't need to

00:51:35.880 --> 00:51:38.150 align:start position:0%
don't need to maintain any invariants in terms of like

00:51:38.160 --> 00:51:40.430 align:start position:0%
maintain any invariants in terms of like only the contract can modify its own

00:51:40.440 --> 00:51:43.130 align:start position:0%
only the contract can modify its own data I guess they can all agree that one

00:51:43.140 --> 00:51:45.829 align:start position:0%
data I guess they can all agree that one pins or end is always positive right so

00:51:45.839 --> 00:51:48.890 align:start position:0%
pins or end is always positive right so anyone can do that and then you know

00:51:48.900 --> 00:51:50.930 align:start position:0%
anyone can do that and then you know just kind of cost functions it takes a

00:51:50.940 --> 00:51:53.990 align:start position:0%
just kind of cost functions it takes a bunch of majorities catches them at

00:51:54.000 --> 00:51:55.329 align:start position:0%
bunch of majorities catches them at print right

00:51:55.339 --> 00:51:57.650 align:start position:0%
print right supposing pumpkins rent by whatever

00:51:57.660 --> 00:52:00.470 align:start position:0%
supposing pumpkins rent by whatever mechanism they come up this

00:52:00.480 --> 00:52:04.069 align:start position:0%
mechanism they come up this which again is not super pretty but

00:52:04.079 --> 00:52:07.849 align:start position:0%
which again is not super pretty but that makes it possible to do the pump

00:52:07.859 --> 00:52:11.990 align:start position:0%
that makes it possible to do the pump without touching the contract code and

00:52:12.000 --> 00:52:16.010 align:start position:0%
without touching the contract code and increasing inside guys and so on so

00:52:16.020 --> 00:52:19.370 align:start position:0%
increasing inside guys and so on so you know it's a basically a generic way

00:52:19.380 --> 00:52:21.829 align:start position:0%
you know it's a basically a generic way to maintain your contracts I think it's

00:52:21.839 --> 00:52:23.630 align:start position:0%
to maintain your contracts I think it's maybe viable

00:52:23.640 --> 00:52:26.150 align:start position:0%
maybe viable yeah I think the host function could be

00:52:26.160 --> 00:52:28.010 align:start position:0%
yeah I think the host function could be good I think the only issue with that is

00:52:28.020 --> 00:52:30.890 align:start position:0%
good I think the only issue with that is key Discovery is still an issue

00:52:30.900 --> 00:52:32.270 align:start position:0%
key Discovery is still an issue and then it might be difficult to

00:52:32.280 --> 00:52:34.490 align:start position:0%
and then it might be difficult to determine what keys you need to bump

00:52:34.500 --> 00:52:37.309 align:start position:0%
determine what keys you need to bump around for in the host function

00:52:37.319 --> 00:52:39.589 align:start position:0%
around for in the host function but perhaps one another thing is we

00:52:39.599 --> 00:52:40.630 align:start position:0%
but perhaps one another thing is we could

00:52:40.640 --> 00:52:46.010 align:start position:0%
could expose a explicit rent bump

00:52:46.020 --> 00:52:49.250 align:start position:0%
expose a explicit rent bump at like the storage interface

00:52:49.260 --> 00:52:50.990 align:start position:0%
at like the storage interface and then also make the current rent

00:52:51.000 --> 00:52:54.109 align:start position:0%
and then also make the current rent balance readable

00:52:54.119 --> 00:52:56.450 align:start position:0%
balance readable in the smart contract so I could imagine

00:52:56.460 --> 00:52:58.490 align:start position:0%
in the smart contract so I could imagine something like maybe a common

00:52:58.500 --> 00:53:00.470 align:start position:0%
something like maybe a common Paradigm for read-only data would be

00:53:00.480 --> 00:53:02.329 align:start position:0%
Paradigm for read-only data would be like if you have an off entry whenever

00:53:02.339 --> 00:53:04.730 align:start position:0%
like if you have an off entry whenever you read it you say you also have a

00:53:04.740 --> 00:53:06.470 align:start position:0%
you read it you say you also have a check to see if the rent balance has

00:53:06.480 --> 00:53:08.809 align:start position:0%
check to see if the rent balance has fallen below some level and if so then

00:53:08.819 --> 00:53:11.390 align:start position:0%
fallen below some level and if so then you call Rent bump on that value

00:53:11.400 --> 00:53:14.450 align:start position:0%
you call Rent bump on that value so I guess or I don't know if that

00:53:14.460 --> 00:53:15.890 align:start position:0%
so I guess or I don't know if that would be possible then because or none

00:53:15.900 --> 00:53:17.390 align:start position:0%
would be possible then because or none of that would be possible and so then

00:53:17.400 --> 00:53:18.589 align:start position:0%
of that would be possible and so then essentially

00:53:18.599 --> 00:53:19.970 align:start position:0%
essentially there's a g path and an expensive

00:53:19.980 --> 00:53:22.670 align:start position:0%
there's a g path and an expensive path and so if your rent is above the

00:53:22.680 --> 00:53:24.530 align:start position:0%
path and so if your rent is above the value then pre-flight would put that

00:53:24.540 --> 00:53:27.109 align:start position:0%
value then pre-flight would put that entry in the read-only data set but if

00:53:27.119 --> 00:53:29.150 align:start position:0%
entry in the read-only data set but if your rent is below a value then

00:53:29.160 --> 00:53:30.470 align:start position:0%
your rent is below a value then PreFlight would put it in the read write

00:53:30.480 --> 00:53:32.510 align:start position:0%
PreFlight would put it in the read write set and bump the rent and so I think

00:53:32.520 --> 00:53:34.250 align:start position:0%
set and bump the rent and so I think that might be also another possible

00:53:34.260 --> 00:53:36.170 align:start position:0%
that might be also another possible solution for for often like read-only

00:53:36.180 --> 00:53:40.069 align:start position:0%
solution for for often like read-only data I mean that's kind of possible but

00:53:40.079 --> 00:53:43.430 align:start position:0%
data I mean that's kind of possible but doesn't solve it for everything like

00:53:43.440 --> 00:53:46.069 align:start position:0%
doesn't solve it for everything like imagine again your token right and it

00:53:46.079 --> 00:53:49.730 align:start position:0%
imagine again your token right and it has the you know an admin and let's say

00:53:49.740 --> 00:53:52.309 align:start position:0%
has the you know an admin and let's say you don't mean this token much

00:53:52.319 --> 00:53:54.109 align:start position:0%
you don't mean this token much so you don't touch the admin entry

00:53:54.119 --> 00:53:56.770 align:start position:0%
so you don't touch the admin entry frequently and then it would still

00:53:56.780 --> 00:54:01.250 align:start position:0%
frequently and then it would still expire right you you know the admin

00:54:01.260 --> 00:54:03.589 align:start position:0%
expire right you you know the admin functions frequently enough so you know

00:54:03.599 --> 00:54:06.829 align:start position:0%
functions frequently enough so you know for the important things you

00:54:06.839 --> 00:54:08.630 align:start position:0%
for the important things you it sure needs some sort of manual

00:54:08.640 --> 00:54:09.950 align:start position:0%
it sure needs some sort of manual tracking and you still need to

00:54:09.960 --> 00:54:11.809 align:start position:0%
tracking and you still need to understand which entries need to be

00:54:11.819 --> 00:54:14.210 align:start position:0%
understand which entries need to be updated they I'm sure we can avoid this

00:54:14.220 --> 00:54:15.650 align:start position:0%
updated they I'm sure we can avoid this food just because you know some interest

00:54:15.660 --> 00:54:18.470 align:start position:0%
food just because you know some interest may be rarely accessible well I think

00:54:18.480 --> 00:54:19.970 align:start position:0%
may be rarely accessible well I think that's okay actually

00:54:19.980 --> 00:54:21.710 align:start position:0%
that's okay actually because if you don't access admin

00:54:21.720 --> 00:54:23.870 align:start position:0%
because if you don't access admin very much and whatever you access it you

00:54:23.880 --> 00:54:25.190 align:start position:0%
very much and whatever you access it you need to restore your admin entry I think

00:54:25.200 --> 00:54:27.230 align:start position:0%
need to restore your admin entry I think that's okay I think the case I'm talking

00:54:27.240 --> 00:54:28.849 align:start position:0%
that's okay I think the case I'm talking about is if you have some really value

00:54:28.859 --> 00:54:31.609 align:start position:0%
about is if you have some really value that you access a ton that still gets

00:54:31.619 --> 00:54:33.230 align:start position:0%
that you access a ton that still gets archived all the time

00:54:33.240 --> 00:54:36.349 align:start position:0%
archived all the time yeah but but my point is that you know

00:54:36.359 --> 00:54:40.010 align:start position:0%
yeah but but my point is that you know you can still forget to call it so I

00:54:40.020 --> 00:54:43.250 align:start position:0%
you can still forget to call it so I mean rely on automatic bumps is not

00:54:43.260 --> 00:54:44.990 align:start position:0%
mean rely on automatic bumps is not going to always work

00:54:45.000 --> 00:54:49.130 align:start position:0%
going to always work and another thing is that imagine

00:54:49.140 --> 00:54:52.010 align:start position:0%
and another thing is that imagine you know

00:54:54.480 --> 00:54:57.290 align:start position:0%
oh maybe it's not a super good example but I I've been just thinking about who

00:54:57.300 --> 00:54:59.750 align:start position:0%
but I I've been just thinking about who who pays for the bump right it's always

00:54:59.760 --> 00:55:02.829 align:start position:0%
who pays for the bump right it's always a source account who pays for the bumps

00:55:02.839 --> 00:55:04.730 align:start position:0%
a source account who pays for the bumps and

00:55:04.740 --> 00:55:07.490 align:start position:0%
and it would be a bit weird like if every

00:55:07.500 --> 00:55:09.410 align:start position:0%
it would be a bit weird like if every once in a while

00:55:09.420 --> 00:55:11.690 align:start position:0%
once in a while like some transaction to your contract

00:55:11.700 --> 00:55:13.250 align:start position:0%
like some transaction to your contract suddenly becomes more expensive because

00:55:13.260 --> 00:55:16.490 align:start position:0%
suddenly becomes more expensive because you need to bounce around but you may be

00:55:16.500 --> 00:55:19.130 align:start position:0%
you need to bounce around but you may be bump into rent of some entries that has

00:55:19.140 --> 00:55:20.630 align:start position:0%
bump into rent of some entries that has nothing to do with your account

00:55:20.640 --> 00:55:22.849 align:start position:0%
nothing to do with your account specifically like for example let's say

00:55:22.859 --> 00:55:26.870 align:start position:0%
specifically like for example let's say you have some found that stores some

00:55:26.880 --> 00:55:28.730 align:start position:0%
you have some found that stores some sorry some contracted Source some State

00:55:28.740 --> 00:55:34.990 align:start position:0%
sorry some contracted Source some State saying

00:55:39.720 --> 00:55:42.470 align:start position:0%
it's like never going to change right and it's always free download

00:55:42.480 --> 00:55:45.650 align:start position:0%
right and it's always free download and then there is no clear owner of the

00:55:45.660 --> 00:55:48.049 align:start position:0%
and then there is no clear owner of the token paywrites they're not

00:55:48.059 --> 00:55:48.650 align:start position:0%
token paywrites they're not

00:55:52.619 --> 00:55:54.650 align:start position:0%
owned by any address or anything so what would happen is like every once in a

00:55:54.660 --> 00:55:56.870 align:start position:0%
would happen is like every once in a while someone who trades with this

00:55:56.880 --> 00:55:59.210 align:start position:0%
while someone who trades with this liquidity pool will need to pay for

00:55:59.220 --> 00:56:03.230 align:start position:0%
liquidity pool will need to pay for their inbound I was a token payer record

00:56:03.240 --> 00:56:05.390 align:start position:0%
their inbound I was a token payer record which is a little bit awkward right

00:56:05.400 --> 00:56:08.030 align:start position:0%
which is a little bit awkward right because I I just want to trade why would

00:56:08.040 --> 00:56:10.730 align:start position:0%
because I I just want to trade why would it charge me more and you know I then

00:56:10.740 --> 00:56:12.950 align:start position:0%
it charge me more and you know I then draw all the incentives to kind of try

00:56:12.960 --> 00:56:15.230 align:start position:0%
draw all the incentives to kind of try to gain this and

00:56:15.240 --> 00:56:17.450 align:start position:0%
to gain this and president not submit transactions until

00:56:17.460 --> 00:56:21.109 align:start position:0%
president not submit transactions until someone else has pumped you know I mean

00:56:21.119 --> 00:56:23.690 align:start position:0%
someone else has pumped you know I mean it's definitely viable on paper but it

00:56:23.700 --> 00:56:26.210 align:start position:0%
it's definitely viable on paper but it just leads to distribute situations for

00:56:26.220 --> 00:56:28.910 align:start position:0%
just leads to distribute situations for you know you're in a bumping rent on the

00:56:28.920 --> 00:56:30.549 align:start position:0%
you know you're in a bumping rent on the some interest

00:56:30.559 --> 00:56:34.250 align:start position:0%
some interest you can respond to know about right I

00:56:34.260 --> 00:56:35.750 align:start position:0%
you can respond to know about right I guess it also depends on the amount

00:56:35.760 --> 00:56:38.210 align:start position:0%
guess it also depends on the amount because it's well enough and it probably

00:56:38.220 --> 00:56:40.010 align:start position:0%
because it's well enough and it probably doesn't matter but if it's high enough

00:56:40.020 --> 00:56:42.530 align:start position:0%
doesn't matter but if it's high enough then suddenly it becomes pretty annoying

00:56:42.540 --> 00:56:47.809 align:start position:0%
then suddenly it becomes pretty annoying for the user who ended up paying it

00:56:50.579 --> 00:56:51.950 align:start position:0%
yeah thank you I agree like it we probably need to think about those

00:56:51.960 --> 00:56:54.770 align:start position:0%
probably need to think about those couple of angles like the

00:56:54.780 --> 00:56:56.930 align:start position:0%
couple of angles like the people that want to kind of maintain

00:56:56.940 --> 00:57:00.349 align:start position:0%
people that want to kind of maintain their their run balance on on those

00:57:00.359 --> 00:57:02.630 align:start position:0%
their their run balance on on those like read-only type of items that and

00:57:02.640 --> 00:57:04.069 align:start position:0%
like read-only type of items that and when I say people here could be a

00:57:04.079 --> 00:57:05.930 align:start position:0%
when I say people here could be a contract that tries to do like like an

00:57:05.940 --> 00:57:08.089 align:start position:0%
contract that tries to do like like an mm right that wants to kind of ensure

00:57:08.099 --> 00:57:11.390 align:start position:0%
mm right that wants to kind of ensure that it keeps alive its own thing at the

00:57:11.400 --> 00:57:13.490 align:start position:0%
that it keeps alive its own thing at the same time there are probably scenarios

00:57:13.500 --> 00:57:14.750 align:start position:0%
same time there are probably scenarios where

00:57:14.760 --> 00:57:17.150 align:start position:0%
where you want to kind of

00:57:17.160 --> 00:57:19.670 align:start position:0%
you want to kind of do that from the outside in some way

00:57:19.680 --> 00:57:22.130 align:start position:0%
do that from the outside in some way right because you don't want every

00:57:22.140 --> 00:57:23.329 align:start position:0%
right because you don't want every contract

00:57:23.339 --> 00:57:25.670 align:start position:0%
contract I mean yeah in the up cases where this

00:57:25.680 --> 00:57:27.410 align:start position:0%
I mean yeah in the up cases where this is going to not work like if nobody is

00:57:27.420 --> 00:57:29.089 align:start position:0%
is going to not work like if nobody is using it or and you need to revalue it

00:57:29.099 --> 00:57:30.950 align:start position:0%
using it or and you need to revalue it or I don't know

00:57:30.960 --> 00:57:34.010 align:start position:0%
or I don't know anyways we have time so

00:57:34.020 --> 00:57:36.109 align:start position:0%
anyways we have time so thank you everybody let's continue

00:57:36.119 --> 00:57:38.750 align:start position:0%
thank you everybody let's continue those conversations actually we should

00:57:38.760 --> 00:57:41.930 align:start position:0%
those conversations actually we should probably create like explicit threads

00:57:41.940 --> 00:57:43.670 align:start position:0%
probably create like explicit threads on the

00:57:43.680 --> 00:57:46.069 align:start position:0%
on the you know on the dev Channel

00:57:46.079 --> 00:57:49.130 align:start position:0%
you know on the dev Channel about those topics and then yeah

00:57:49.140 --> 00:57:50.569 align:start position:0%
about those topics and then yeah we'll keep going

00:57:50.579 --> 00:57:53.300 align:start position:0%
we'll keep going thank you again
