WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
okay let's get this party started hey everyone welcome to storybond design discussions today we're gonna talk about two topics transient storage and upgradable contracts I'm going to take over Justin and I apologize in advance for my nasal sound I'm a bit congested is Dima here yes Dima do you wanna take us through transient storage yeah sure so is this really a pretty small feature and I don't really want to spend too much time on it like if you think we don't need it let's just drop it but basically the idea he said it's also next the cross contract interactions interactions are much more capable than without it for example if a contract wants to do some temporary allowance

00:01:00.000 --> 00:01:59.999 align:start position:0%
to distribute funds between multiple receivers or something like that it could create cause increase allowance function and and do as a corresponding expert transfer phone call right right and the thing is that allowance in this case is not needed to be persisted and my initial intention here why I came up with this ready in the first place is that I didn't want the token to have any persisted allowances but but yeah this was a topic we have discussed last week and it doesn't seem like the general consensus is that the time being on the persistent allowances to still remain in the token yeah but original this idea was if you want to create something that is needed only for the duration of the

00:02:00.000 --> 00:02:59.999 align:start position:0%
time you could use this ephemeral storage or whatever his name is and basically its benefits were that it doesn't need to be included in the footprint footprint and it doesn't need to be written to The Ledger which is beneficial both from the like transaction size standpoint transaction costs 10 point and it's beneficial for The Ledger as well and and the other thing is that from the interface 10 point it probably would be pretty simply to use from the SDK perspective because we can abstract it away if needed and meaning some generic interprets or maybe you can switch your plug or something so I wouldn't be too concerned about SDK side but I guess the main concern is

00:03:00.000 --> 00:03:59.999 align:start position:0%
that valves running too many use cases for that at least yet and I kind of agree especially if he just don't want to go with temporary allowances and we go with persistent allowances allowances yeah I think I don't actually want to upload the token interface with like multiple allowance types or something like that so you know you can drop it all we we can view it but not use it in token I don't have a really strong opinion like there are definitely some interested cases one can come up with you know one contract calls another contract multiple times and then as a contract made want to maintain some state state but but yeah maybe this cases are too narrow to worry about them now I guess that's I have to sleep now got it so it is worth mentioning that this thing has been discussed a lot in the ethereum ecosystem and I think

00:04:00.000 --> 00:04:59.999 align:start position:0%
they're getting pretty close to actually putting something like this that's the AP 1153 transient storage op codes codes and in the ethereum ecosystem it's also something that's been considered in the context of re-entrancy attacks because it allows you to basically kind of like a contract instead of flag that it's like being processed right now and then if there's like a re-entrance then the contract can check that flag I think for us it's less relevant right now because there's no re-engency possibility at all and I think that if we're gonna add re-entrancy possibility there's probably going to be a flag in the call function that allows you to set like whether or not you you accept that so I think that's less of a motivation for for for Soroban my question to you do you mind I think I asked this in the past aside from the allowances use case is there are there any other examples that you can point out too

00:05:00.000 --> 00:05:59.999 align:start position:0%
so actually speaking of reinsurance I think if we do it in whatever ways it might be actually useful and I just forgot to talk about this I don't know if I don't think there are planning arrangements for everyone maybe eventually I feel like it will be beneficial to be able to write some Perfection bits even if it is controllable on the individual contract overall overall but otherwise I don't think I have a super good concrete example I've been thinking generally about you know us tickets for approvals it's just a case of that but you know in general you can imagine something like a custom accounts a smartphone creating creating some authorization tickets that might be used during the

00:06:00.000 --> 00:06:59.999 align:start position:0%
execution time for multiple calls but you know I guess the main issue here is that since since this thing like this does not exist for example in a cage yet right I guess run many users of that because well there's no such feature so yeah but I cannot come up with like I'm very convincing case right now like I have just some fake ideas I don't know obviously it can be implemented efficiently in azervation maybe they can yeah but the important part is that well yeah like I understand that use cases are probably not that obvious but also the maintenance cost is pretty low as well so it's not like a huge shade of it's not very good you know complicated subsystem we need to maintain as well so yeah that's something big got it so I think that given that last

00:07:00.000 --> 00:07:59.999 align:start position:0%
week we decided to keep long lasting approval or persistent approvals and given that you know simple authorizations are handled by off next without actually requiring requiring allowances at all I would say that this is a pretty narrow use case and and we'll clutter the the asset interface so I definitely agree with the sentiment that that we shouldn't include it and I wonder if anyone else on this call has a different thinking about that so you're saying not only remove it or like don't make any changes the token contract but also remove it from and the SDK right because it's been that

00:08:00.000 --> 00:08:59.999 align:start position:0%
like the the tooling for this has already been implemented right yeah my vote would be to remove it especially given that it's such a narrow use case and also you know with State expiration we have a lot of different storage mechanics in in the end and I think that adding another storage mechanic can just add to the product confusion for Developers yeah I agree if we're not going to use it then and we don't have any other good use cases I'm fine with removing it yeah at 10 degrees well it it does sound like a very cool feature but it also also to a large degree it's an optimization and yeah there definitely is like a complexity cost to developers needing to be aware of this thing so you know knowing knowing that it should or shouldn't be in a

00:09:00.000 --> 00:09:59.999 align:start position:0%
footprint which I guess is largely taken to get you know care of by the fact that we generate the footprints for people but but may have developers needing to make a choice about what they use it just seems like one more thing that people need to know and learn about or make a decision about about that for the most part it sounds like we would be telling people don't use this this isn't something that you would use except for you know these these educations that is a very strong opinion I can imagine finding use cases for it but if we're aiming for minimalism then I guess we remove it I don't really care is it in the current release the release has just gone in now okay it sounds like we're pretty

00:10:00.000 --> 00:10:59.999 align:start position:0%
in agreement right now on removing this this so so I will we'll go to the next topic which is upgradable content yeah yeah one small thing on this like since it is in the current release someone comes up is a good idea for use case please let me know because you know if there is something legitimate that people can use right now and they they can play with it so you know we if it is if it seems useful like we can reconsider this trade because it's not really correct oh it is not no right oh okay that's a bit unfortunate unfortunate oh okay I guess you still can write if you have some ideas yeah yeah and once it's asking if it was it wouldn't be a complicated to include Post Main net it will be somewhat complicated in a sense that it will

00:11:00.000 --> 00:11:59.999 align:start position:0%
require a protocol release but yeah it just will be one not complicated okay next topic is upgradable contract so Dima you distributed a doc a couple weeks ago that outlines three different proposals and you've implemented one of them can you give us a brief overview on the different on the problem and the different solutions and focus on the one that you're proposing proposing yeah sure basically basically I essentially want some contract upgrade mechanism to be shipped in V1 just because if there is no such mechanisms and contracts written in V1 will stay unupgradeable forever because no matter what mechanic we come up with it will need to be controlled by the contract itself and you know if contract

00:12:00.000 --> 00:12:59.999 align:start position:0%
doesn't have an updating kindness there is no way it can upgrade itself so it is of course possible with the current tool set to build something like a proxy but the issue is that the state will need to like the state of the proxy contract has to belonged as a top level contract 80 and currently it's not possible to achieve it so we need something to address this issue which is why I had things a proposal an assumption line were said okay we could add some sort of storage delegation mechanism which I think someone quoted existed in Solana maybe some other chain I believe it was one but it could be wrong here but basically it's just one of the approaches that is possible or you say hey I allow or not yeah I

00:13:00.000 --> 00:13:59.999 align:start position:0%
allows that contract I'm calling to actually be using my storage it's not super straightforward to implement I guess guess and also it is going to be relatively manual in terms of like besides the storage delegation mechanism you still need to write all the focusing machine Machinery which might be an overkill for some cases so second option insert option but basically three depends options three develop since option two and and yeah for the option two what we do is we just just allows the contracts to update their conflict executable entry as we call it now or basically contract says this is a reference to my implementation versus references hash of the Verizon web installed engine so

00:14:00.000 --> 00:14:59.999 align:start position:0%
this is Proposal with Zipcar is already deserve it just to allow contracts to call host function and update the hash of this wasn't blob to be some other value performs an updates so basically the update logic and authorization logic is on the contract developer which makes sense a he wants to have different authorization approaches to this but the main point is that it is now possible to just upgrade the button that has been used as an addendum to that is if you folks suggested then the I have this implemented as well we will and wasn't hash to their standardized signature payload for sales just so that you know

00:15:00.000 --> 00:15:59.999 align:start position:0%
will will basically get a some feedback if something has been updated once they were sending the transaction transaction which I guess might make sense if something has been signed a while ago well yeah that's kind of safety measure that's comes with this obviously there are some security concerns but my guess is that this is not significantly more different contract uality based sequels it can be strong funds from it or something like that there are some angles to attack service contracts and so on and so forth so basically it's ultimately on the

00:16:00.000 --> 00:16:59.999 align:start position:0%
contract developers and the good thing about this approach is that it is very easy to tell that the contract is upgradable upgradable like it cannot be obfuscated as far as I understand because you need to follow the host function and kind of obfuscate the plus function calls but should be visible even from the Vasan blobs that the contract is subgradable yeah and also as a benefit compared to the first option where we just automate in the storage access this approach allows to easily extends the interface so for example say you have some nft contract and then after a year nft standard has been ironed out and some new functions have been added to it you may just update implementation of your nft and provide some new functions that's maybe a bad example I don't know if that happens or not but you get the idea right that it's possible to extend the interface without any special

00:17:00.000 --> 00:17:59.999 align:start position:0%
machinery and it's compatible with them and host environment and option three is just another feature on top of that where we allow besides a point generator wasn't hash be allowed to point it a different contract and use these different contracts wasn't hash as implementation and once this gives us basically a like very cheap proxy pattern or it is possible to do centralized upgrades of the implementation on a bunch of contracts contracts this is how I have noticed some bigger contracts work like uni swap I believe where they have some implementation contract and you know it can be updated in various ways for example there could be some voting or something like this so

00:18:00.000 --> 00:18:59.999 align:start position:0%
again authorization is kind of on the contract Traders and it can be as complex as needed and then soon as the implementation is updated every instance of the contract gets update immediately which is close fast and cheap and it is of course more narrow use case than just upgrading a single contract instance but arguably it is pretty important as well because well it affects maybe a smaller fraction of the contractors are likely the most meaningful contracts like uni swap so basically this will probably concern anyway token mm implementations and stuff like that because this tend to have many instances and say probably should be controlled by a single entity a lot of the time

00:19:00.000 --> 00:19:59.999 align:start position:0%
so yeah this is options option two is that is yeah all the parses there so it's only a matter of review and it's very easy extending it is not hard as well well so I don't see a very good reason to not do that besides maybe some additional ux complexity but I saw some folks had some I won't say that so and that's so I do feel like there's there's one possible solution that is not mentioned here and it it may be because it's like really bad from a performance perspective but you could always create like a a simple kind of like contract that's that just like stores things so like a storage access contract and then the

00:20:00.000 --> 00:20:59.999 align:start position:0%
proxy can like you know can can pass that as an argument to whatever implementation contract it uses right now right and and that's something that's pretty much doable now yeah I guess that's an option that kind of yes of house supports for option one it is still like still wouldn't tell for the interface updates updates as I mentioned and of course this is really really slow and I think it's all enough to the point of being being as well as your attaching the storage wasn't like a couple of times okay separate separate to the performance issue I am curious on how authentication auth would work in that flow like with the auth be between the two contracts or

00:21:00.000 --> 00:21:59.999 align:start position:0%
like how would you like the nice thing about auth auth for users or with the contractors you're sort of like scoping their users access access potentially but would we be able to do the same thing for a contract that's deeper I guess we can with auth next sorry I like which approach are you referring to I'm just talking about what time it is the idea time it was sharing where data is I guess it doesn't really matter you just like your storage interface instead of like calling storage through then if you would call storages and as a contract and another contract would rely on the invoker being the admin something exists so basically it is definitely doable other or not it's a good idea isn't

00:22:00.000 --> 00:22:59.999 align:start position:0%
probably it's not the best CD but I mean yeah it kind of works and presumably it's a bad idea because we were talking about what I described as like three separate wasn't environments in it right yeah it's a ton of of the Cross VM calls and I mean every storage Bridge would be another VM read the right would be a VM code and VM codes are really expensive that's the most expensive thing you can do which is why kind of in favor of built-in mechanisms because besides providing some unique features they are also much more efficient Point like additional VM instantiations which are expensive right but if we go in the path of introducing protocol changes for this you can imagine that like this and again

00:23:00.000 --> 00:23:59.999 align:start position:0%
I'm not attached to this idea in any way but you can imagine a world in which we take this you know simple contract contract like simple storage contract and and nativize that so that it's native code I'm not sure how would we negative is it it won't be possible oh yeah well so is that worth doing like I I'm curious why the like this that approach is more beneficial than the solution too like just using the host function function that's that's a good question so I think solution to is is possible my my knee-jerk reaction the solution too is that the fact that a contract implementation can change is is not trivial like it's it's it's you know especially if you look at other

00:24:00.000 --> 00:24:59.999 align:start position:0%
smart contract platforms out there right now now I feel like that is going to be something that is a bit more difficult for people to wrap their heads around I'm not sure how is it different from the processor implementation change is exactly what happens it says that instead of changing the contract that is serving as implementation you are changing the implementation itself which is actually easier to trace a generic fashion because it's independent of any contracts contracts yes from from from a user perspective I agree with you but if you look at the you know if you look at the usdc contract which is a proxy contract right now this you know it never changes right it's always still the proxy contract and the state changes and there's like a different address that it forwards to but the contract itself

00:25:00.000 --> 00:25:59.999 align:start position:0%
didn't change right it's like an observer perspective like like a block Observer perspective well is it actually a good thing I don't think I think that's a good thing because I think the fact that the actual code that runs like the fact that the actual contract code and this is semantics so just there's a thing right it's a contract Behavior may change and it is actually hard to notice that it has changed pressing the second solution emit an event probably and it will be very clear that the implementation has changed I think it is it actually makes things more observable safer right because well you can argue yeah it is just a proxy right but it may point it at a different implementation and if block Explorer actually cared about that it would be pretty tricky for

00:26:00.000 --> 00:26:59.999 align:start position:0%
break it would need to know how exactly this proxy reference is being stored or you know introduce and standard based events or something so I don't quite agree that it's necessarily a better thing because it creates a false Impressions that the contract doesn't change or it actually like its Behavior actually does change in fact but it's just sophisticated yeah I think there's there's basically no way for us to I agree with Gemma here I think there's there's no way for us to prevent contract behavior from changing contracts can just change Behavior that's that's that's their nature they don't always if they did one thing yesterday they don't necessarily do the same thing today because they might have code in them that says you know if it's Wednesday do something different right there's there's always the possibility for contract changing what what you're getting out of something being built into the protocol is a standard way of expressing a pattern of contract change and so block

00:27:00.000 --> 00:27:59.999 align:start position:0%
explorers or anyone else can actually observe that particular type of change which is upgrades and upgrades are you know the least pathological and most expected type of contract change which is that someone just pushes an update to their contract because like life goes on and they've added teachers or they fix bugs that's that's something everyone does in software and so I think expressing it in protocol is actually a good idea I'm in favor I think two or even three I think three can be layered on top of two like it can be done as a future extension so if it's going like MVP like we could just do number two initially and then have you know an additional flag on the thing called indirect reference rather than direct reference and that's not the end of the world but I think building another product I mean this is like I'm a broken record I always want to build stuff into the protocol so this is no surprise coming from me but I'm definitely on the do it in a protocol level it's it's 100 of contracts are going to want to upgrade themselves at some point so it feels like supporting that is is quite natural

00:28:00.000 --> 00:28:59.999 align:start position:0%
yeah I think that was a really good explanation from D mind grade I'm I've changed my mind also one more Point like you have mentioned native as in the contract I don't think you have a good user story for that but I think actually this functionality probably can be leveraged because I'm not 100 sure if it will be ever able to kind of make current contract implementations native without a lot of fun guns especially like alternative implementations of the same interface that are slightly different which means that you know in the future you could say update current contract not tourism but to any different implementation implementation so that's another consideration and another benefit of having this in protocol versus just something that Hulk

00:29:00.000 --> 00:29:59.999 align:start position:0%
builds with contracts foreign there's one aspect of the way this we're implementing this that I saw getting discussed in Discord there was conversation about changing how Earth worked with updating so that signatures froth included the the wasn't hash itself so that if an update occurs everyone's signatures get invalidated I I'm curious I guess like what the motivation for that is yeah I'm to be clear I am kind of neutral to that idea I think you can either do it or not do it there's a motivation was mostly about culture and security implications like it adds

00:30:00.000 --> 00:30:59.999 align:start position:0%
some degree of additional confidence right in what you're signing coming back to the most example of Hayes is the same contract well it kind of can be sure and I think this makes the most sense when when probably more concerned not about the implementation changing to something that is clearly malicious say you know there was a token balance and sensor it's an update and admin now can transfer your whole token balance elsewhere oh they probably can do this anyway but I got the point right so like we are not talking about malicious upgrades here but let's say you just want contracts to be audited if they are updated like you do not trust contracts by default would say we have some database of trusted contracts right and if the contract is getting

00:31:00.000 --> 00:31:59.999 align:start position:0%
updated chances are it won't immediately get to this database for example you know we can connect your wallet to it or something like this which kind of makes it reasonable to just sign for a certain implementation and you know if it has changed then it will basically get to learn it about this or something like that so basically your wallet will be more aware about what you are signing and there is more possibilities for the audit let's get inside of course this is all just Theory I don't know this will happen in reality but this is something that we enable if we add implementation to the US payload so let's say it again yeah yeah because it sounds like I wasn't sure if this was like part

00:32:00.000 --> 00:32:59.999 align:start position:0%
of the core idea what which I think it sounds like it's something we're just sort of considering on the side then yeah I think my concern about it is that it's more of like an advanced user it sounds like more of something that like an advanced user would care about I'm not the general user and to enforce something like that on the general user I think would actually create problems you know in the moment that a contract upgrades anybody who's currently submitting your transaction is going to fail the vast majority of those users probably don't care and they probably just want to go and gonna have to go resign something that they would have been happy to go through anyway and I think I like we always have the weak link that a contract developer could just implement the proxy button sorry that you know the thing that you're signing doesn't change but the thing with the logic actually is will yeah sure it's I guess as I said it's

00:33:00.000 --> 00:33:59.999 align:start position:0%
more about the question of Trust basically let's say you have some swap contract that doesn't actually hold any balances so it doesn't really care about you know if someone can suddenly drain funds from it but you do care about its implementation and again this kind of needs some mechanisms for accessing some audited implementations implementations results that of course it makes zero sense sense with that it makes some sense for the cases when you have some contracts that per C doesn't matter much because yes country proxy proxy pattern could be implemented right but then you know like would you trust this contract in the first place right yeah talking about this use case for you know you worry about the contracts being audited and

00:34:00.000 --> 00:34:59.999 align:start position:0%
right that's something I don't really know for now how that would work right because in general having some trusted contracts contract implementation databases is something that seems like a good idea but for those days will need to be built by community and I don't know to each degree degree only to cover all the cases so yeah as I said I'm kind of partial in the city as well I understand some arguments for it and interest against it you know for some it will be just an annoyance thing not sure maybe we should ask for Timbers and thinkers opinions because saber advocating for I didn't maybe they have more arguments as well right yeah so I'm I don't disagree that this this probably has some utility but but I feel like there's an opportunity here

00:35:00.000 --> 00:35:59.999 align:start position:0%
for us to implement this in such a way that it's not required you know it's not part of the like you know if we make it part of the signature then in theory everybody has to buy us into this model this very very over cautious I'm only going to use something that's yeah like basically buying into that whereas whereas if we find a different way to implement that requirement such that it's not actually part of the signature but maybe of the invocation but maybe it's part of the you know like we have the footprint for example maybe we have something like the footprint that lists out the wasm hashes of the contracts that you're invoking and the protocol just checks that so it's actually part of the the signature for the actual invocation but it's part of the signature for the transaction maybe I don't know yeah actually that's a great point now that I think about it you kind of oh it's not you it's a transaction Source who is signing the footprint

00:36:00.000 --> 00:36:59.999 align:start position:0%
but that's an interesting point if the contract updates that transactions will anyway fail because they are accessing a different wage or entry it just kind of interesting right like of course it needs to happen in in the short time window between like pre-flight snapshot getting updated and the contribution update is in this window and the transactions will still fail so yeah I don't know if it would necessarily be part of the footprint but maybe something like the footprint if it can't be part of the same thing yeah just where you could list out you know these are the contracts that I'm willing to be executed in this oh right yeah but but truly thinking about it it seems like the window where you would sign something basically you could just do this soft chain right maybe you shouldn't really worry about plotting the transactions with this because like if you really

00:37:00.000 --> 00:37:59.999 align:start position:0%
care about that and your wallet has some logic that can that has some base of trust and implementations right it just can be maintained by doing some redundantly requests to the lecture snapshots that are presumably fresh and probably from the security system point it's going to be really that much different from signing the version hash because because the time window for the contract has been updated but the snapshot of The Ledger hasn't been updated kind of coincides with the pre-flight call anyway so your transaction will still probably fail because it has invalid footprint maybe signature shouldn't be even concerned about that like first really need to align for you to basically basically sign a call without knowing that the contract has been updated and actually relating it as I'm not sure

00:38:00.000 --> 00:38:59.999 align:start position:0%
possible so yeah I think that's maybe a good point and we shouldn't worry about it's too much and it seems like the just the forward side implementation is reasonably safe if you really concerned about what contracts you're calling are there any other open questions Dima about the implementation of proposal number two that you want to consult with with a group actually I think it's super straightforward straightforward yeah I think it's pretty easy to use and doesn't introduce too much percent unless as well so yeah

00:39:00.000 --> 00:39:59.999 align:start position:0%
okay are there any other questions from anyone else on stage or in the audience okay this has been very productive thank you all and we can keep chatting on the on Discord if you have any further questions have a great day y'all