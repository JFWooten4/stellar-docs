WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
okay let's get started so welcome everyone this is a soroban design discussion in these meetings we discuss some of the core decisions that we need to make when we're building soroban which is a platform for smart contracts that is in active development right now and is being integrated integrated with stellar today we're talking about off next which is a proposal that Dima put together to address some of our authentication and authorization needs on the network so I think that without further Ado this is the second time we're talking about off next the first time was before the holidays a lot of folks were were were out so I think we're gonna start with an overview by Dima then dive into questions and ideally you will be able to make a decision or get close we would

00:01:00.000 --> 00:01:59.999 align:start position:0%
close without decision today so Dima can you take it yeah hi everyone you hear me okay yeah okay sounds good thank you so a quick overview I will probably skip on the motivation for the sake of time I will just say that the general modulation is that we are aren't too excited about the state the others currently now it's a bit too fragmented and to limit it in some senses well it's too flexible in other cases and it's not necessary so this proposal tries to build something into the protocol that would be those flexible but also standardized so that contracts can inter operate and the client software can Implement certain things just once

00:02:00.000 --> 00:02:59.999 align:start position:0%
without tweaking them for every contract so on a high level The Proposal consists of two big components the first being account abstraction and second being standardized signature payloads and invocation authorization so to play on this point account abstraction is a well-known concept on in other chains and basically is that instead of passing some entities that are tied to some crypto algorithms such as some public keys or something like that or instead of trying all those to say classic server accounts we make the contracts to operate on some abstract entities called accounts and from the

00:03:00.000 --> 00:03:59.999 align:start position:0%
contraction Point account is just an object that has an address that can be used to throw balances for example or for any account related information or transfer balances to this account and it has a way to authorize the invocations of the functions it's not the contract in the contract business logic how exactly the account does that so hence the abstraction and the accounts themselves can be implemented both in a built-in fashion some of our built-in tokens and the building implementation will cover the classic store account so they will all get their default account contract right but they also can be customized right for example if someone comes up is a new cryptogram like this Quantum resistance

00:04:00.000 --> 00:04:59.999 align:start position:0%
for example right or you know there are Hardware votes that currently don't support her at all it is possible to write an account contract that will perform this custom authentication but the possibilities are much better than that it is possible to have a literally complex multi-6 schemes that are probably currently not possible the class Explorer accounts for example it is possible to record different mode async  or different tokens spent or different balances spent basically this is a smart contract I guess that's the bottom line of it so yeah this is the first component and the second component is about the signature payloads because again currently signature pivot system of preform we have like the SDK implementation of some structured

00:05:00.000 --> 00:05:59.999 align:start position:0%
payloads but this is just in one SDK it's not 600 days in any way so the proposal here is that instead of relying on contracts to Define their own signatures schema we provide the generic ones that should hopefully be flexible enough to keep all the use cases so the payload obviously would include some context information such as network ID but the main thing and the main Innovation here is that instead of just signing a single contract call it is possible to sign a whole tree of course or even like Forest of trees nature okay

00:06:00.000 --> 00:06:59.999 align:start position:0%
basically from the contract standpoint when the contract requires an account to authorize family vacation the Urban cost like the power wheel add this into a post deck of all Trace calls and build a context Tower so basically when authorized this code from some contract the payload for this call should contain obviously the currently executed Contracting function but also the call stack of the authorized invocations leading to it and the contract provided arguments so basically it's only since a contract needs to provide these arguments for the authorization and everything else is inferred automatically based on the current

00:07:00.000 --> 00:07:59.999 align:start position:0%
Coast Tech and stuff like that The Proposal also includes  that generalized Finance Management okay I think we wanted today different this but for the sake of overview ready is that cost will contain we will manage nonsense per contract and per account address so that basically neither regular contracts nor account contracts need to worry about that and this comes with some benefits like nouns can be consumed only for the top level invocation and not any subsequence of contract calls plus Ledger access and more flexibility for the users that's rather benefits uploaded so now

00:08:00.000 --> 00:08:59.999 align:start position:0%
so these are two key Concepts and I think another interesting high level point is that things housing is Paradise for the cases of complex contracts PreFlight can be utilized to build this the signature payloads this is like like when we are talking about the contracts that have more than a single signature like it's a current world or modern single authorized and location it's a house next World it may be tricky to figure out like what exactly needs to be signed like the contract may be delegated to some contracts that dynamically depends on their input and things like that so in order to figure out what exactly needs to be signed in order to be able to execute a certain contract call

00:09:00.000 --> 00:09:59.999 align:start position:0%
we introduce a mechanism in pre-flight that we'll basically Trace those authorization calls and build the proper payload and the cool thing here is that this stage like there is no signatures participating and basically no no commitment to any security reasons from the user so the only thing that the private needs is the other addresses of the account that participate in the invocation what else yeah I think that's pretty much it on the high level  I just think quite like so there's a bunch of other things but I think we would want to look yeah I think that's a great starting point and we can open it up for questions I'm especially interested in the perspective of the DAP developer so

00:10:00.000 --> 00:10:59.999 align:start position:0%
Paul if you have any comments there I think that the original auth that we built or what we now call Advanced off the the point in which we realized it was a bit problematic is when we had you know daps and walls try to implement it and it became clear that it's you know it's a lot to handle so I'm really interested to hear about this one in that perspective foreign talk a little bit more about what actually goes into the signature payload specifically like do wallets have to sign only the sub tree sections were like account the authorized is called or they have to sign every like cross-contract call or yeah yeah as I've mentioned basically their trees over the coast not to exit full trees or whatever as a contract calls

00:11:00.000 --> 00:11:59.999 align:start position:0%
basically this is a subset of the whole country of the contract were the current account oh not currently there can't be interested in all Traders something so let's say we have an account a that once so sorry we have a contract is that once the user to authorize it then it delegates to contract BS that doesn't touch right they return Then B code CZ that's authorize the users and that cost tags are user Sciences a and then C B will be omitted so you know there is no yes there is no time in a sense for all well it seems much more flexible right yeah that's okay so I feel like a exchange swap for example you would really only have to sign like the token withdrawal from your wallet yes sir like basically yeah you need to still approve your token to some router contract and then router contract can

00:12:00.000 --> 00:12:59.999 align:start position:0%
route your token in any direction or vice versa like you may sign like some low levels of operation that just swaps you with someone and you don't really care how exactly this is being routed again your signature is required under this bottom level operation so both ways work and also an important note on signatures that I haven't mentioned is that wallets would sign the hash of the whole payload and this is mostly for the sake of compatibility it's whatever hard of our wallets and possible features basically we want to bound their signature pivot size like the actual signature go outside it's not premature yeah so the wallets take the entire subtree hash that then sign that so there's only one second sure okay cool thank you yes Dima yeah yeah I have a question about and I'm going to steal a list questions

00:13:00.000 --> 00:13:59.999 align:start position:0%
What In the case that you want to pass an invalid signature one of the subcontact with the purpose of taking a different path in the contact execution right and explicitly you want to fail one of them yeah this is here okay so like I mean I'm interested to see like an actual use case for that because from there like this only influences pre-flight right from the preference standpoint like I describe this feature where we can record the authorizations but the side effect of recording them is that we treat them all as successful it is not impossible to mock failures in the preferred API it's like basically not a protocol change I'm not convinced this is something we actually should do and it's really unclear to me why would you ever want this to be the

00:14:00.000 --> 00:14:59.999 align:start position:0%
game basically in my mind like if it's fine for the authorization failures to be recoverable for example you know you want to clear like multiple trades and at once and in a general case trades may not clear for multitude of reasons one of them being that signatures for the trades for this trade are incorrect and you don't want for example to fail other trades if you're just patching things together right this is a fair case but I think this case is only meaningful during the on-chain execution I think it is fine for the pre-flight for example to execute the hate this scenario because it will be probably it will consume more gas and build access knowledge your entries than do it in case of failure so it will make it superset of what is executed in chain

00:15:00.000 --> 00:15:59.999 align:start position:0%
of course it is possible to write some really weird contract Logics that would try to reorder trace the account but again I'm not quite convinced that ever a good idea and there won't be a good support for that from the pre-flight standpoint for example and but but I think there is a pretty good reason to not support it because you kind of have this recursive dependency where like you want your signatures to depend on the function input but then if your signature defines like what the signature should be you get this basically cyclic dependency rate so I I'm not convinced this is a good idea basically like what I would want contracts to do normally is that if you call contracts function with certain arguments it comes with a certain signature preload and this

00:16:00.000 --> 00:16:59.999 align:start position:0%
relationship should be deterministic right and it should not involve signatures in the input which is actually one of the problems with the current Advanced awesome because we are like are we used to like include some information from the signatures while building pillows for another signatures and it's pretty messy and how to painting and power so yeah yeah and another question this change implies that you need to do the cryptographic verification posts transaction execution right are they very end right because you need to build the pre-image and in order to build a pre-image you need to run the contact right so not on the simulate side but when you actually go and execute it you need to run the entire smart contact

00:17:00.000 --> 00:17:59.999 align:start position:0%
three right and only at the end you have the pre-image that you can verify with signature that's actually not true right like it's a bit of an implementation detail and I think it may change but in the current prototype what happens is that since we kind of decouple authentication and naturalization well at first the whole tree has to be passed in some way along the transaction right so the transaction should know in the first place whatever if you are claiming you have time so from the smartphone perspective for example it's possible to examine the whole tree that's trying to or trades from the authentication perspectives there is just this curved payload which is the hash of something and from the

00:18:00.000 --> 00:18:59.999 align:start position:0%
authentication standpoints the only thing we need to do to it is to basically verify the signature of this payload is correct and in case of mounted sync accounts find all the signers right so basically the current implementation the authentication happens so easily the first time the account writes to trade something and actually the same goes to evaluating the whole tree over the course in the vote like the latter part may I may not change but I think yeah there is really no need to do anything until the end of the contract execution we just do verification as soon as possible so basically you've like if Thompson is not like if some were deep in the subject there is a cause that hasn't been authorized will find out about it as soon as we reach this point but not

00:19:00.000 --> 00:19:59.999 align:start position:0%
I see so the entire tree is effectively submitted as part of the transaction right yeah it is and yeah I have seen your suggestion on the dog that maybe instead of passing like the whole show explicitly we made Parts ashes of its nodes which probably may be fine in terms of the transaction sites but yeah it really only matters for the transaction part of the things not for the actual execution yeah so my concern here is that people are going to use the existing contact a infrastructure to develop like deep executed contact tree right and when that happened we can have several hundreds of contracts executed right per transaction and I just kind of like a horrified of the idea that as a result of that we're

00:20:00.000 --> 00:20:59.999 align:start position:0%
going to have hundreds of signature in each transaction account so again there is only a single signature per account right and said like the signature flow is you take the payload which is basically a network plus a vector of the invocations you want to or trade you hash it you sign the hash that's it ah so there is only a single signature then the first time execution time is the first time the account tries to try something we verify the signature and then we will just do basically matching like weather resist invocation is present in the tree or not now to the Deep tree topic I don't think it's it's the new route it has any relevance to this because it's not like it's impossible to close up to contract now

00:21:00.000 --> 00:21:59.999 align:start position:0%
and the bank accounts versus these right like you cannot probably execute a hundreds of contract calls even if they don't do any actualization shift because it will run out of gas before that like we are going to have gasoline it on the transaction so and I think it's completely it will always be a better idea to have a single contract than a multiple contracts than multiple contracts into these things and because cow in a contract comes at the cost so yeah next week very differentiation yeah right thank you can I give us a question about the to do with this you know what gets signed in the subtrees and going back to deem of a example you provided when you when you're answering one of polls questions you describe a situation where an

00:22:00.000 --> 00:22:59.999 align:start position:0%
account is signing like that you're calling a contract and that contract is calling three other contracts a b and c and this account just wants to sign the call to contract a and the call to contract B in that situation is that does that mean that count a science two sub trees like separately so they provide two signatures Play sign a and they sign b or are they because a few times it's been mentioned that an account only ever provides one signature is there some way that somehow they sign those two sub trees but it's only one signature or how does that work yeah so basically as I said like technically you're not signing the tree you're a sign in a forest of treats so for example if you have a top level router contract that doesn't require any authorization but then you make two subcontract calls that are authorized that would spawn to all trees

00:23:00.000 --> 00:23:59.999 align:start position:0%
right because they will have different top level or trades nodes which I think is fine like you still need just one signature over that as I said I'm always saying like one signature per account account here is an account object it doesn't mean like that it's Unique so if your transaction accepts two accounts and they happen to be to have the same address very long try to duplicate them and then there are a little bit of signatures so you know when I'm talking about like single single short per account that's only in the context of that account like in the context of the whole transaction there may be a return number of accounts and some of them maybe duplicates and they will have their own signatures too so if you don't try to be any more collaborate here so it's yeah one per account not more okay so in that situation where

00:24:00.000 --> 00:24:59.999 align:start position:0%
account one wants to sign contract a and the contract tree a c but they don't want to sign the top level like the very very top level contract call they they would provide two signatures they would sign like the sub tree for contract a the subtree for contract C and then they would include those two signatures is that right okay so at first I want to make points that I think it's more like it's important to practice say that it's not that account wants to do something it's what the contract wants to do because the source of the signature pullouts in the first place is the contract it's not the account the count row is to verify the signature like an account contract account in a more broad context or always to sign stuff eight and seven so basically depending on the call tree you

00:25:00.000 --> 00:25:59.999 align:start position:0%
will get different results for example if you have a contract as I said that calls independently into say contract B and contract c but you provide it once at the top level you'll get a single payload so let's say you have a contract a that doesn't require authorization itself but it does go into contracts bncs and direct prioritization if you provide contract a then you will get a single payload with both invocations but on the other hand you could just pre-sign contract B and contract C and then write like you don't want to know the user to know about your top level contract then your top level

00:26:00.000 --> 00:26:59.999 align:start position:0%
contractual when you take care about having two different accounts right but it will be still possible to forward the signature so basically it's whatever the contracts Define and whatever you try to prep white or build signatures for it's driven by the contract interfaces so I mean it's probably a good idea to try to implement things in a way that only a single signature is needed so that you know we have some Atomic operation per account that may involve arbitrary number of subcontractables but nothing limits you from you know using small result present calls but you will need to this needs to be reflected in the contract interface and implementation that's right so what you're saying is that contract a could just sign the entire tree if they wanted to

00:27:00.000 --> 00:27:59.999 align:start position:0%
yeah like you you would need some criticize instead of so if you just so just ignoring PreFlight for a second just assuming that the developers here know how to build these trees themselves they know how to do all the signage themselves I'm not really too interested in the automation just yet but a developer could choose to sign the entire tree and they would be signing a b and c or they can choose to sign just the subtree A and Justice subtree C and include those two signatures basically yeah like as one is your Forest of trees corresponds to what what has been authorized you should be fine so you know if but basically what you can do like if you're in full control of all the execution paths you will just look at where your authorization secure and you would include all this into the signature pivot where signing it and then you basically can embed this sub

00:28:00.000 --> 00:28:59.999 align:start position:0%
trees in arbitrary called trees you care about as well for example the same topology and a signature Bionic a signature on a tree will just mean that whatever the address is for that signature is authorized anywhere in that tree where that address shows up is that correct authorized anywhere the contract calls all tries on it right so there is anywhere contract requested authorization I have a question related to this about authorization context and the call stack so if you invoke a contract a that calls B and you know B is the only one that calls authorized then a is not part of the context how long someone to front run a by submitting B I'm wondering if there are any security issues or weird use cases here and if we

00:29:00.000 --> 00:29:59.999 align:start position:0%
should consider requiring the full call stack by default with the option to authorize the subset the cost stack and then the concern here is a high level if it's possible for the front run to prevent I expected logic from running well it sounds right like at first that was a consideration to include like the full cost tax but the scenarios like we have just discussed such scenarios like it's rather limited and makes use cases like exchanges much trigger to implement properly because you know you may care only about like swapping the token and you don't want to care about like how exactly it has been solved and and so from training some contracts would indeed need some front-end prevention in place so for example you know coming back to the batching the operations example right so let's say your contract clears multiple swaps and swap May Fail for multiple

00:30:00.000 --> 00:30:59.999 align:start position:0%
reasons one of them is run signatures another one is front run right someone front Trends is Swap and it's no longer valid right this case is really not different from any other failure like just write contract in a way that it gracefully handles the failures and you should be good as for security issues I mean it is possible to write a contract in such a way that you can transfer into signature for it and it's one to the right thing but it's probably on the contract and so I can implementation issue right normally what you should require is easier to sign should be it should be a some sort of atomic operation that the user should intend to perform it shouldn't be some middle step so for example if I want to create a clinical balance for example a simple thing right I

00:31:00.000 --> 00:31:59.999 align:start position:0%
want to transfer the token to the contract and I want to create an entry on behalf of this user I could drive this incorrectly and take just the signature for a transfer and you can from transit signature quarter transfer but that's obviously about what I should do is I should reverse the authorization the whole thing I'll use the pro or whatever so I mean bugs would exist for any sort of authorizations but I don't really see an inherent security risk here and so on as you don't require the user to sign some non-atomic things that you will build storage account so let's say coming back to the swap example let's say you did something based on the swap outcome then probably you would want to or trades your top level contract that does the swaps because it does something else will probably need to be or trade right and

00:32:00.000 --> 00:32:59.999 align:start position:0%
you don't want it to be functional right so and also there's a front training prevention topic never mind okay go ahead yeah so like the you said it makes sense like the the one thing I'm concerned about is you know the the authorization authorization context is determined by the contracts right as you mentioned and the user is just going to sign whatever pre-flight returns so and these bugs are not that like you know if you don't have a great understanding of how this authorization that these authorization Mechanics Work you may not see it when you look at the contract and the user is just going to sign whatever pre-file returns so it may not be you know at any point easy to see what the issue is until until it's too late so that's just my concern I don't know if no I'm still not sure if this is so go ahead yeah yeah I know my intuition is that again this is probably the case for any sort of traditions like let's say you understand the whole tree like do you really think that add in

00:33:00.000 --> 00:33:59.999 align:start position:0%
like a bunch of stuff does a tree would like prevent some weird cases when you sign something that you didn't think yeah I'm not sure but I think a great thing that structural payloads are always it's it should be easy to implement a generic forward support for just parsing this tree and finding the relevant code you know like if you send something to The Exchange that it's supposed to sell token a for you and you get your payload and your vote says hey this is going to withdraw like 10x of the token a that you actually wanted to trade then you know you probably won't find this and wait you wouldn't worry about this too much so yeah there is definitely like more control from the interesting point in a generic scenario I agree that some things might be vulnerable and

00:34:00.000 --> 00:34:59.999 align:start position:0%
these are wouldn't know about that but I'm yeah I I don't have a good understanding of how prevalent would this be or how dangerous would this be because well and so it could be contracted a flowed in multiple wage rate and you wouldn't know so it's I guess the question of trust and you know only using the things that matter and the fact that we at least can easily know what the contract trying to go to your tokens or whatever other Commodities you have it's already a big wins here because like kind of limits the impact simulator yeah thanks Dina any further questions

00:35:00.000 --> 00:35:59.999 align:start position:0%
Lee yeah I have a question but it's a little bit derailing so I feel like I want to if anyone else has questions that are moral on the line of what we're already talking about that might be best to do first the URL awaitly so I'm interested in Anna have a proposal interacts with the simple invoker auth case that we we currently support today so I think when timer was describing before you know we developed the current version of sorbenorth we realized that it's actually relatively complicated to use and so then we went and had added invoker auth which is basically the same as message.sender in the ethereum world and the way that it's implemented is the source account on the operation is the invoker and so a contract can just say who's the invoker and they'll either get back and address they'll get back an

00:36:00.000 --> 00:36:59.999 align:start position:0%
address which is either the source account on the operation or the contract that's calling them yeah I saw I understand that the proposal basically says okay there's the proposal replaces the complicated and the simple auth we have today and creates a single unified interface that contracts use to verify that the address is authorized I'm just wondering like if there's a way that we can retain the simplicity so that for the vast majority of contracts enter the wallets and contract interactions they still have the simplest form of in terms of like what they need to sign it's like the simplest without needing to go and sign these call statues

00:37:00.000 --> 00:37:59.999 align:start position:0%
well I mean the host Tech tree for the case that is currently an invoker case it's pretty much equivalent to just the conflicting location right because it consists only of a single invocation and you know you just add a vector around the things that already exists so even if that call has like so I'm calling just one contract but that contract may be calling five other contracts as a part of its what it's going to go do those calls may be unimportant to me so maybe they're just calling out to an oracle again some information again Nano Trace calls are not included in the payload wait this is an important point I want to reiterate again that what what these are Sciences only the authorized upset of the whole country

00:38:00.000 --> 00:38:59.999 align:start position:0%
country so it doesn't include any in between or side calls even if the authorized call is the top layer so even if I'm like the top call is going to be authorized Ultra is doesn't propagate anywhere authorize means that I'll try this and only this added in the current context that's it it doesn't say anything about inside invocation so that curse would not contain things that are not done on your behalf so whatever the contract calls into doesn't matter for the secret signature so for the case where invoker is used currently I mean invoker cannot be propagated currently right you cannot forward the invoker to the other contract which actually they have seen from discussion it's kind of a bit annoying and confusing right because you may sometimes want to propagate it

00:39:00.000 --> 00:39:59.999 align:start position:0%
but yeah this is a side like in this exact use case when you don't propagate the top level account anywhere the signature pillow it will be almost exactly the same module of the different structure rate instead of like having a single contract and invocation you will handle it support into a vector and that's pretty much it and you will have a signature a few different plates so you know from adapt perspective it will be marginally harder to build this payload but you know doesn't need to account for anything new so just need to use a bit different structures and from the transaction State Savings endpoint like we are keeping the invoker making sure to like save on signatures and you know if the source account thanks a whole transaction and the contract call it is possible to mark that it is an invoker and do not

00:40:00.000 --> 00:40:59.999 align:start position:0%
require like a second signature so the optimization part is there two and yeah the only thing that kind of changes from the contract interface 10 point is that yeah you need to pass the account explicitly and intercourageon account we may or may not introduce some sugar in SDK to simplify that and make it so you don't really need to type what you want to authorize but you know it's like one line of code we also want to do this for the sake of Click so if you can but I don't think it's too big of a an issue to basically do this but on the other hand like it is now possible to for the constant to do things on behalf of accounts in the sub course which is not possible within local current which I think is yeah of course

00:41:00.000 --> 00:41:59.999 align:start position:0%
yeah I think an optimization like if if there is some way for us to retain an optimization where The Source account could still be used to authorize I I guess the because I'm not really too concerned about that one line of code that a contract has to add I'm more concerned about what that the story is for a Dap or a wallet developer yeah but the transaction you know a number of things I need to sign like like a you know like a hardware wallet needing to sign the Stellar transaction as well as this blob which is like two signatures so two rounds of signing they need to go through versus if the if 99 of contract calls really only just need that Source account you know they really only then have to sign just the transaction once which is yeah yeah I think you definitely want to preserve that it's increase that for

00:42:00.000 --> 00:42:59.999 align:start position:0%
the signature key test when you know you'll pay for the transaction that your qualities or one contract it's definitely easier to just passing a signal curvy so basically yeah it doesn't go anywhere but it will be possible to do everything in this single signature how frequently this will be used compared to something else we don't know yet because we have discussed a lot of the cases and you know some third-party page for the fees but you know that's something you've got a secret you know it's a case for the user to just send a transaction to Samsung do to your business and this multi-help transactions hopefully possible to sign other corporations at once while still being compatible with something

00:43:00.000 --> 00:43:59.999 align:start position:0%
are there any other questions either from anyone on the stage or the audience I have a minor question that maybe like you can explain like in the Prototype why is authorize called authorized instead of something like verify authorization I think that was done intentionally but I don't recall the reason I no I I don't think there is reasons okay yeah I mean odd trays it's like I don't know I'll try this current invocation but if it's confusing you can use whatever name defines you to go to college verify that's radiation as well check I don't know foreign

00:44:00.000 --> 00:44:59.999 align:start position:0%
okay so I think there's yeah I think the last one we touched on which is having to sign multiple payloads for the even for a simple case I think that's a no-go I think we need to either optimize for that or or scrap this at the end of the day people are using external signing applications people are using Hardware wallets and we need to figure out for the simple use case how to sign a single payload yeah okay so let's stay so I'm yeah I'm not saying this is going to go anywhere so as simple use cases will be possible but you know for the complex use cases you may end up needing to send two things

00:45:00.000 --> 00:45:59.999 align:start position:0%
but yeah do you mean the simple use case would be satisfied by just keeping the existing invokerol with capability or are you meaning that we would introduce an optimization into this proposal so that the contract still uses the same method they still call Dot authorize or dot verify authorization yeah nothing changes somehow comes from the The Source account Yeah so basically we don't truly awake the whole driver for this proposal was to kind of have unified account oh sorry unified Contracting rupees and you know I find it kind of problematic that you kind of hard code your contract to use invoker right if you don't use Advanced host on the current approach and that's kind of bad right because if you want to use this in a different context you cannot it's hard cut a teas and Walker so the contract interface itself uses

00:46:00.000 --> 00:46:59.999 align:start position:0%
what's next it uses accounts and addresses and the abstraction and you know one of the implementations of that abstract account even though it's kind of built into host but it's just invokers rate it's just one of implementation of the abstract account contracts shouldn't worry about that it's all implemented in the host and it's in the current prototype as well so yeah let's Chooser and by simple use case I mean the cases when there is only single accounts it needs to trace operations you know throughout multiple accounts and one of them can actually can be invoker but that's reason to pre-size something but they want me to sign the storage induction so hopefully you know a majority of the case is only single signatures needed so just to be on the same this is implemented in your host prototype for off next right now yeah it's in the Pro

00:47:00.000 --> 00:47:59.999 align:start position:0%
Tab right now so this is an important thing and it's important and is the way that works that you it's only the top level contracts but if they call Dot authorize they would see the source account as being authorized yeah they actually will see wait basically the trees teeth sharing the transaction payload but instead of cutting the signature you pass nothing and instead of passing the account ID you pass the flag because it's an invoker it's similar to how we handle invoker currently in advanced cars it's just move to the transaction structure itself right I'm just wondering because in Vegas today is only it has no depth like yeah now it has depth yeah now it will have depth because the transaction has the whole tree of the coast so basically you are signing the tree

00:48:00.000 --> 00:48:59.999 align:start position:0%
itself which is why it is safe okay so so this the way it's currently implemented it's not really messaged us and it's like the transaction.origin from ethereum it sounds like is the way that it's working I I'm not sure but I think the key factor here is that you explicitly you still explicitly out price calls right it's not like you just gave for a contract blanket permissions to call things on your behalf it is really just it's keeping the signature verification part because you when you're assigning the transaction or operation you are also assigning the whole authorized call stack payload that you've been talking about before so yeah so basically yes the world would need to show you that hey as a part of this operation you

00:49:00.000 --> 00:49:59.999 align:start position:0%
maybe a sign in multiple token operations for example right but you know from the signature standpoint it needs to still be sanctioned once so it's basically like msg.center but better because like energy the center is like contingent on the fact that you have signed the top level and location here you sign all the invocations that you need to try yep okay yeah I'm the reason I just mentioned that the transaction of origin is because I'm just trying to think of if there's anything that we really need to worry because it feels a little bit more like transaction.origin in the you know you could you're the source account you call this contract either calls another contract you tell that other contract that you're authorizing as the invoker so that other contract is authorized

00:50:00.000 --> 00:50:59.999 align:start position:0%
with the top level Source account yeah I think it's probably fine because you're right it's reflected in you still have to specify yeah right there is really no way no matter what kind of authorization you use and so it's no way to somehow hide the subcontract call that prefers authorization so there is really no way to hide some token withdrawals number deep in the trade those still circuits no matter what or it will just fail because you haven't seen it yeah any other questions from the stage of the audience okay so I think you know dima's done a great job at answering all these

00:51:00.000 --> 00:51:59.999 align:start position:0%
questions I think there's a still most of the concerns are around the you know what is the contract for the Gap developer and to get insights into that I think we need to regroup and probably come up with some you know minimal prototypes that help us understand that so hopefully that's something that we can put together soon enough and discuss again and if no one has anything else they want to ask or to add then I think we can call it a day yes maybe if you have a few more minutes I have one question it's yeah about the non replay protection if a transaction fails because the

00:52:00.000 --> 00:52:59.999 align:start position:0%
call stack change will the nodes be consumed or not yeah the non-consumption is actually trick using May need to think more about that in the current implementation nonce is basically tied to the top level or try it's called which may or may not be the right thing to do which means that it's something fails basically okay if the whole transaction fails The Ledger state is completely rolled back those announced won't won't be consumed if a top level contractor tries succeeds but some subcontract call fails and

00:53:00.000 --> 00:53:59.999 align:start position:0%
the top level contract handles is Grace collisions and not smart Bureau project thank you okay we we may need to discuss this further because this can be an issue with like at some point the transaction fail and then becomes available again because the code stack is available again someone can just run through you and replace the transaction doesn't make sense yeah I I mean the transaction replay but basically again frontrun is kind of weird because it's it shouldn't be an issue most of the time because someone would do what you wanted to do anyway yeah yeah but what you wanted to do at one point may not be what you wanted to do in the future so let's say I want to transact with one inch to spend my

00:54:00.000 --> 00:54:59.999 align:start position:0%
money then these fails so I spend my money with another Exchange and then someone replay the previous transaction and spend my money again like we can discuss this more but basically yeah I think like I think this kind of brings another topic which is exploration which I don't think we have discussed and they didn't do anything in the proposal it may be a generally useful feature to have you know for your signature to have expiration and that even could be a part of the standard payload so that we could distribute expired payloads but yeah I think it's kind of complementary to our question okay yeah yeah the Norms could be Ledger bonded or

00:55:00.000 --> 00:55:59.999 align:start position:0%
time bonded that may be a good idea okay yeah yeah we can discuss this and yeah it would be nice to try to come up with basically some Sooners and the sink they can get abused somehow because thank you thanks Tebow so we are approaching time thank you so much for everyone and Dima especially for you for prepping this and for answering the questions we will regroup and update on Discord thank you all
