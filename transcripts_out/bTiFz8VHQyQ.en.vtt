WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Great. , hi everyone. , sorry, Carson, I said you would start up. , first, can you hear me? Well, please let me know. , write in chat. , all right. Great. , okay, cool. So, hello everyone. , today I'm going to present a few caps. as many as time permits and I have three total and all of them were kind of spawned from Le's proposal proposal that was linked to one of the caps and the idea behind the proposal was about extending our capabilities for the classic star account or G accounts and the idea behind it was to

00:01:00.000 --> 00:01:59.999 align:start position:0%
add a capability for IG account to have a set of contract signers. So one contract signer and if you have a contract signer you can really have arbitrary authentication logic with arbitrary policies and stuff like that. but in addition to that you could also you could also add a capability to manage trust veins for example from soraban soraban which closes even more feature gaps because this proposal as it is it won't be possible to use this C standards outside of Soraban because we currently do not provide a way to run contracts outside of the transaction apply for with that like Jay is not hearing me. I don't know Jay seems like people still hear me.

00:02:00.000 --> 00:02:59.999 align:start position:0%
so that that's kind of high level motivation behind that. but I'd like to actually start with cap 71 which is something I figured while thinking about how this whole GI account customization thing could be implemented and this cap is about adding protocol level support for delegating authentication between custom accounts. Yeah, thanks Marius. It's actually not a new mic. It's just Discord settings. which is funny. So Cap 71 and motivation for that stems from several different issues. and basically currently what is

00:03:00.000 --> 00:03:59.999 align:start position:0%
possible to do in Soroban what some of you may know there is this require O function that requires authentication authorization from an address and this function can actually be called from within a custom account check O function that performs as well. So this is kind of the current way of delegating not. So you have an account but instead of verifying some signature you say I try this other contract to perform verification for me and this has some benefits for modular custom accounts and it is like a cornerstone of this proposal for G accounts to have C signers because it's effectively the same kind of delegation right so instead of having a cryptographic signature for a G account we say you don't actually know what the signature is we let a contract to perform

00:04:00.000 --> 00:04:59.999 align:start position:0%
verification instead on its custom signature format. But this mechanism while it kind of works it was not like built as a full-fledged feature in the protocol. It's just a byproduct of the design. Design allows it. That's not visible out because there's no reason to dissolve but just kind of inconvenient to use and also not optimal to use. The inconvenience factor lies mostly in simulation. so if anyone has tried it, they would quickly learn that you cannot simply simulate this. currently you need to build for for the delegated contract call you need to build its own signature payload. which is kind of tricky and this could in theory be fixed the simulation where although it might be a bit complicated as well.

00:05:00.000 --> 00:05:59.999 align:start position:0%
but yeah it would still be kind of annoying because you would need to do several simulations and all kind of propagating more and more authentication information into the system. and yeah, I think it is still kind of annoying. But in terms of optimality as well there is quite a bit of duplication here here because like you spawn new authorization entries like for example if you have two accounts and one delegates authentication to another one then you would end up with two authorization entries in transaction that increases transaction size and increases complexity for building it and the tipping point for me for why I came up with cap is the context like the some of the proposals that I've seen

00:06:00.000 --> 00:06:59.999 align:start position:0%
for the delegation for custom accounts maybe do not use context much but if we were to do this for the G accounts we do not want to lose the authorization context which is basically the list of the the contract codes that have been authorized And the issue with the approach of calling require O from within check O is that you could pass context to the require O call but it would not look the same as the normal context that you would have during normal authorization which means that for example let's say you have a an account implementation that does something about the context you cannot simply use it as a delegated banner of a G account for example because the context will be kind of in messy nested form like it will be

00:07:00.000 --> 00:07:59.999 align:start position:0%
an argument of a call instead of a list of the call. So it is kind of messy and I think it is going to be quite annoying to maintain this mess in the protocol like it creates some inconsistency between like how different types of contract signers can be used. which is basically the motivation for this but it also solves the issues I've described before. Oh yeah, and also if you want to have the context you will need to attach it to to the transaction as well which is like even more duplication on top of it. But you have like besides like specifying multiple authorization entries for every address, you would need to specify like the whole call stack as well for every address but in different forms. and it's a lot of mess. mess. so what do I propose to do about this?

00:08:00.000 --> 00:08:59.999 align:start position:0%
it is actually not that big of a change and it consists of basically two parts. one part of it is on the XDR side as can be seen in the cap. And what we do in the XDR is we introduce a new type of credentials which is basically this part of the authorization entry that contains signatures and stuff like that. And the credentials are pretty much same as robban credential of address. but they have an additional field called delegates. And each delegate is just a strct that contains an address and a signature C value which can be an arbitrary value for one can parse. And it also has a list of nested delegates. in case if you call delegated

00:09:00.000 --> 00:09:59.999 align:start position:0%
accounts from within delegated account and the cool thing about this exr is that you may have a single authorization entry that has as many delegated signers as you need. So there is no duplication at all like there is only necessary information. information. So in the simplest case for example right we have an account that asks another contract to perform us on its behalf behalf and this will be represented as a single authorization entry that has the main account that we are performing O for in the credentials at the top level and the contract that actually performs O and delegates array and we only store its address and its signature. and this structure is very simple and like if you get a result from this

00:10:00.000 --> 00:10:59.999 align:start position:0%
like it's usually up to you to fill in the credentials anyway. So if you are dealing with delegation as a wallet, what you need to do is just build this new type of credentials. it should be pretty simple like it's only a couple fields more than you would need to fill for normal or entry and there is no like this messy propagating the O data into simulation and stuff like that is basically basically kind of a way to do multi-IG but instead of doing multiple signatures you have multiple like sign implementations on the high and there is one more small change which I will talk about a little bit later. and from the host side we add two functions that actually allow contracts to interact with the delegated

00:11:00.000 --> 00:11:59.999 align:start position:0%
signers. The main function is delegate count O which is very similar to require O. but it can only be called from within a custom account from within check O reserve function. and it doesn't take any arguments. And what this does is something similar to referrals, but instead of like just authorizing the current call arguments and current call, instead it will inherit the context and the signature payload from the current check implement from the current checkos invocation. invocation. So basically you have a check off and then you have another contract that you want to perform checkos for you and that other contract will get exactly the same check arguments and its own signature.

00:12:00.000 --> 00:12:59.999 align:start position:0%
which is really cool. It allows like all the delegate centers to sign the same payload basically and have the same context. So there is no messes like this nested context in argument and stuff like that. So for every contract it would look like as if they were authorizing the call themselves while in fact they're doing this on someone else's behinders  present for the current cost check. And the motivation behind this function is simply that if you were to use this feature you would have an issue of somehow attaching this delegated signers to your signature payload. like you would need to list some signatures or something like that. And like since I would imagine

00:13:00.000 --> 00:13:59.999 align:start position:0%
a few contracts would want to use this and it's kind of annoying that everyone needs to reimplement this and come with their own UDS and stuff like that and in since we already have the delegated XDR we just add a getter that returns this delegated attached to the transaction and matched to the current. So you can get them then you can make sure that they are actually the centers for the account and then you call deate account on for them. So there is no need for some bespoke representation of this deate center. They're kind of building feature that you may use and you don't need any data structure or app. And again, this reduces duplication even further because like if you fully delegate your O to another account, you do not need the signature for your main

00:14:00.000 --> 00:14:59.999 align:start position:0%
account. account. All right, that's it on the high level for the host functions. the cap has a bit more detailed description of the exact algorithm or how does it work but I think the simple summary if it is really that it is require that just make sure that the arguments look as if you've been authorizing the require call at the top level and the last small thing that I've mentioned before in the XDR is that unfortunately we need a new type of signature payload which I think is like the main downside with this approach and the motivation for this is that the current payload that you need to

00:15:00.000 --> 00:15:59.999 align:start position:0%
sign to for thoraban is it does not contain the address for which you're signing this payload and in the current O framework it makes sense because it is implicitly tied to the address so address is signed but it is signed in a different part of the payload but with a delegation like you need to explicitly sign for the address that is a top level address that delegates everything. everything. So basically without that this whole thing would be insecure. So that's kind of the annoying divergence between like the different credential types. I think while it is definitely a downside it's probably not as big because it is it has one to one mapping

00:16:00.000 --> 00:16:59.999 align:start position:0%
to the credential right. So if you do not support delegate credentials, you don't need to worry about this. If you do support delegate credentials, you don't need to worry about this. But the criteria for picking the right signature, it's pretty straightforward. again camp has more context on this issue. yeah, so I think it is more or less it at the high level. cap also has a proposed simulation flow which is kind of universal for any world that wants to use delegated accounts. Sorry J accounts are this you can do this for J accounts but there are some custom accounts implementation around that but also delegated account which I know there could be like know Zeppelin has been working on something similar

00:17:00.000 --> 00:17:59.999 align:start position:0%
and I know has experimented with this for a while but you know if you like a lot of convenience and to link your well also simplifying and optimizing the transactions transactions Right. we'll cap the trail for Yeah, we will get to cap stream later but probably answer is yes questions. questions. , so any questions? No designers to send G transactions.

00:18:00.000 --> 00:18:59.999 align:start position:0%
that's cap 72 and not yet but it is a step forward in that direction right if we ever allow CERS to sign transactions and G accounts with C signers will also be able to do that that's again we can talk about this a bit later yeah, it is definitely stack or or more interoperability between GNC accounts in general.

00:19:00.000 --> 00:19:59.999 align:start position:0%
I I know that Lee had some concerns about Cap 71 specifically in terms of like like about yet another protocol feature. and I do not disagree that it could partially result with simulation but as I've mentioned before I think doing this at protocol level very beneficial especially if you go ahead with cap 72 and does not only like improves ax but it also simplifies the transactions which is not something that simulation would allow us to solve. I see is there no question for please feel free to chime in the discussion thread if you come up with something

00:20:00.000 --> 00:20:59.999 align:start position:0%
yeah I think that let's go to cap 72 because I can see that folks are excited about it. So again 71 71 is kind of what I think is a prerequisite to 72 just to make it kind of not happy out of the box. So cap 72 is about the mentioning contract signers for scar account for T account account and motivation this gap it's this in the original discussion as well but basically well to allow you to do difference in this existing CH account because G accounts still have

00:21:00.000 --> 00:21:59.999 align:start position:0%
quite a bit of adoption rate and this allow to extend their functionality arbitrarily. it can be new ways to sign for operation. operation. It may be a way to implement new policies and stuff like that. it is really very open-ended. I think there is a lot of demand for passes. It is a pretty hot topic and an argument can be made that maybe you can support this natively as center. this is not the part of CAT 72 but I don't know I'd like to gauge some interest maybe another discussion can be started if someone thinks strongly that has to be a feature on a G account. Now

00:22:00.000 --> 00:22:59.999 align:start position:0%
of course if in the future we support signing for transactions with C account this will become a nonissue because you will be able to do anything with a C signer that you can do today with a normal T account. so well yeah I don't want to spend much time on on motivation here but I think it is pretty significant factor like the ability to u modify the account like a lot of things to do this. so what do we do for this? the first thing that we do is we add a new ser type that is stored in the account entry in a similar fashion as any other sign sign and it is called the dated serer

00:23:00.000 --> 00:23:59.999 align:start position:0%
which is basically how it's it connects to cap 71 right it's also delegation delegation because unlike u the cryptographic centers for example that exist Now they're just public keys. get it center is a contract that defines its own logic with its own cryptography and stuff. the every signer has its own weight in the same fashion as normal planners have weight. but the caveat for now at least is that logated centers can only be used in the smart contract environment because well they are contracts. You cannot run contracts outside of smart contract m environment just yet.

00:24:00.000 --> 00:24:59.999 align:start position:0%
so unfortunately you will not be able to use the seat sign to sign the whole transaction. transaction. but we can do anything in carbon and signing the transaction will work if we ever support signing the transaction with a C account as well. So basically if we support running the contracts transaction validation time which I'm not saying it's necessarily going to happen but it's definitely something we are thinking about. about. again B I'm sorry about that. okay so besides that what we do is that since modifications is a sorryation since operations the C accounts can only happen. But one notable use case we

00:25:00.000 --> 00:25:59.999 align:start position:0%
been thinking about has something to do with various account recovery flows right with using pass key or there are other custom logic to for example recover the account. account. this use case needs an ability to modify G account from Turaban. and we provide this ability this new type of built-in contract which I coined as GAC G account contract and unlike unlike terror asset contract stack which has to be explicitly instantiated GAC GAC is implicitly it implicitly exists for any G account on chain not need to do

00:26:00.000 --> 00:26:59.999 align:start position:0%
anything to interact with it from Soraban you will be able just starting from a new protocol to call contract functions on a G account just really convenient and it is well overhead solution in terms of storage okay so that's kind of a high level overview now go into a bit of detail. so in terms of the standard changes as I've mentioned it's very straightforward. We just extend the existing ser set of signers for the G accounts and we just them in the G account. they're not supported in some more exotic context like in some operations and stuff like that but that's a minor detail

00:27:00.000 --> 00:27:59.999 align:start position:0%
and then the GE account interface as well specified in the cap and it is still up to debate the cap as it is proposes to add an ability to add any type of address as a delegated signer which might create some ambiguity like G account is a delegated center of a G account but it's like G account itself is a public key so we have kind of the same identifier that may be in two different context and it may may not cause some issues and confusion downstream. downstream. So, it is still up to debate. like if you decide to not go with delegated G accounts, the contract interface may be simplified a bit. to

00:28:00.000 --> 00:28:59.999 align:start position:0%
manage signers just based on the address type, G signers would be always cryptographic signers for example and C accounted signers. that would slim down the interface a little bit. But anyways, the current proposal is just to have a pair of functions to modify a weight for a ED 25 signer or remove it. Then the same pair of functions to modify weight for delegated signer or remove it. and then two functions that just manipulate the weights of the account. It's not like strictly necessary but this seem like a logical thing to have if you provide the basic account management capabilities anyway. So just allow to modify the master weight and update the thresholds for the

00:29:00.000 --> 00:29:59.999 align:start position:0%
account. account. so these are just for completeness and not strictly necessary. so for the classic transactions as I mentioned the derated sus will not be supported at the moment. so transactions that try to use them they will be rejected and there's not not even a way to kind of provide a signature for a delegated but for the smart contracts themselves we extend the building functionality that performs authentication for the G account account and this extension leverages 71 one where we would call the functions behind there which will enumerate all the delegated signers existing in the current context and we will call this

00:30:00.000 --> 00:30:59.999 align:start position:0%
new Jate account of house function for them and we'll obviously use the XDR format for the payload defined in cap 71 so it's directly benefits from it And another caveat is that current management operations that in this cap u are they must have a high signature threshold to match the semantics of the set options operation. So it is something new that we do. previously we always used medium threshold for all the rob operations to all G accounts. So that's a small change to use high threshold for the account management operation. And I guess the only somewhat tricky part about the implementation of the G

00:31:00.000 --> 00:31:59.999 align:start position:0%
account contract itself is that we kind of do something new for Sorban. Here we had a way to manage classic entries from Sorban. not not just manage them but add or remove new entries which hasn't happened before right before the only thing we did with classic was we update the trust in balances for the account balances now with this cap we will also modify subentry count this sub entry count which affects the page reserve for the account and if we remove a signer we also might need to remove a sponsorship from this signer This is all like perfectly reasonable to do on this robust side. It is a bit of work to kind of properly maintain the variance. but on the high level, yeah, I guess the main concern here is

00:32:00.000 --> 00:32:59.999 align:start position:0%
that that account has to authorize its modification and it obviously does that by authorizing the G account contract function itself. So on any call with I said you need to provide a signature that matches the highway threshold and besides like performing the modification as well also authorizes modification of the accounts reserve and sub entries. the only difference between this and classic is really that you cannot create new sub entries using some sponsorship because there's not even a way of setting up sponsorship. So if you want to manipulate a G account with GAC, you need to have enough base reserve. You cannot use someone else's sponsorship. which I think is generally fine and

00:33:00.000 --> 00:33:59.999 align:start position:0%
someone wants to sponsor a G account they can do that by for example performing an XLM bundle with G account modification or something like that. yeah so I mentioned already that every G account function performance requires and it will require high signature threshold and I think it is pretty much it for the high level overview of the cap. I think yeah I think I don't have much else to talk about like from bit more details in the camp but I don't think there is anything too significant and the main thing that not the main thing but at least one thing that I'm still not sure about is a final interface like what we do with delegated

00:34:00.000 --> 00:34:59.999 align:start position:0%
G account standards but I think this can can he can offline especially since Lee is not here and had some concerns about representing stills and so on. yeah so any questions? yeah, speaking of string keys, by the way, way, I do not think you will need string keys like an E string key for this one. I I hope at least. So you will just have a G account and it can have a C signer. So that's probably direction we'll end up in. So know your account time. yeah any question.

00:35:00.000 --> 00:35:59.999 align:start position:0%
Okay. I think I don't see any questions for now. it's going pretty fast. Again, I would say like if anyone has any thoughts or comments, please feel free to chime in in the respective camps. And Mat is typing something. I'll wait for a few more seconds. Okay. So, close from the cap. This has a somewhat naterization in selling balance of the account for hasn't been for so why this is the

00:36:00.000 --> 00:36:59.999 align:start position:0%
case this is the case because classic classic when we create a new classic entry or sub entry such as an account signer we need to reserve base reserve from the accounts that owns the entry. Okay. best reserve being.5 XLM as of today. Right. So it is not a strict withdrawal of the fee, right? We not like in fe or anything for that rate. It just increases increases just reduces your spendable XLM balance on the account. It is just like we cannot bypass this mechanism, right? we are doing the same things that we are doing on classic based reserve and just doing it from soran now and I guess the only intuitive non intuitive part about this is really that this hasn't happened before but I feel like

00:37:00.000 --> 00:37:59.999 align:start position:0%
it's not super offensively counterintuitive counterintuitive because when you authorize an account operation you basically it is like a high privilege operation anyway and you acknowledge the consequence quences and one of the consequences as well your days reserve can be increased on the account so you can spend less XLM now it is the same as classic no way around this I looked into an alternative where like extra standards could be stored in the robite and then you would need to pay rent for them it's not like it removes the fees magically it just moves fees in different direction but automatically I'm not sure if the approach other approach or is centers and sorban is sources because creates some new interactions in classic st that going to be kind of tricky to

00:38:00.000 --> 00:38:59.999 align:start position:0%
implement and maintain and are generally much more invasive than what proposed in this cap. but yeah, if anyone is curious, they may look up the history of the cap because it's the first version that was merged. All right. I think we have like 20 more minutes. So why not go through cap 73 while we at it? And cap 73 really supports cap 72 on one hand to allows the accounts to sign for the trust l creation but also in general it just closes the feature gap that has been there from the inception of soraban and I think some people are very well aware of it and it happened I guess just in some flows that do not involve from custom o or

00:39:00.000 --> 00:39:59.999 align:start position:0%
anything. and the the issue is basically that when you're doing contract operations in sorban you cannot create new balances for the G account and new balance being an account entry itself for the XLM token specifically and a trust line for any other token and it is like not completely blocking usage of sack right for G accounts. you can ask the users to set up the trust point first. but there are contexts where you may want to do this programmatically. There is of course a capstone 72 context. You may want to use your C account logic to manage your trust lines. And it also helps to kind of bundling this with some programmatic operations.

00:40:00.000 --> 00:40:59.999 align:start position:0%
such as for example an example I I saw recently from Tyler week. with that you would be able to for example create a new classic asset effectively and create a distribution account transfer asset to the distribution account account distribute later to the users all in the same transaction which is pretty convenient. so yeah I guess there are convenience there is convenience factors there is a factor of really closing the gap and factor of being more compatible with C designers of J account with cap 72 that's the gist of the motivation and the way it works is via two new functions for this to asset

00:41:00.000 --> 00:41:59.999 align:start position:0%
contract. contract. these functions are change trust and has trust and again the exact interface is still a bit up to debate but as it states now the change trust function operates in the same fashion as the forget the name of the operation classic the I think it's called change trust as well in classic the operation and what it does is basically sets a trust line limit for a given address. if the limit is zero, then the trust line is removed. If the limit is non zero and the trust line hasn't been there, then created and of course if it is there it can be just modified. the question is whether we need to manage limit at all. I did some analysis analysis among the trust lens that have been

00:42:00.000 --> 00:42:59.999 align:start position:0%
active during the last year with 98 plus% use limit trust and limit over one to the power of 18 which basically represents infinity. but if anyone is aware of any use cases for limits that are low please let us know u because we might get rid of it for the sake of simplicity because yeah it is not really obvious if it's necessary and for this programmatic manipulation of trust twines. really likely that only binary modifications would be possible because if you need a non- infinite transpoint limit, you're doing something super specific probably and it seems kind of weird that you would know that the wants to do that. It seems really unlikely. unlikely. And another function has trust just

00:43:00.000 --> 00:43:59.999 align:start position:0%
checks if an address has a trust line. And the purpose of this function is really to make for better programmability of trust management because change trust operation requires authorization from the address that the trust lane belongs to. And for example, you are performing a DSD transfer to a new address, right? And normally you would only need O from the transfer source. but if you wanted to create a destination trust lines then you would also need us from the destination as well. you cannot just unconditionally call change trust to make sure that the trust point exists. Maybe you could, but then you know you could make it so you don't need to require us if well it's not verified is really something up

00:44:00.000 --> 00:44:59.999 align:start position:0%
to the further discussion how this interface looks like. But anyways this is the current proposal. The h trust function really helps to check if you actually need to call change trust or not and thus whether you need to require o from the receiver of the balance or not. which is kind of convenient and if you wanted to call this from Z contract similarly to cat 72 this modifies base resource and again in the same vein we we cannot avoid that because it's classic semantics and and we require authorization on the change trust operation in same way of classic so the base reserve modification ation is just yet another thing that you're authorizing by signing this u and it has the same

00:45:00.000 --> 00:45:59.999 align:start position:0%
downside of saying about it going that sponsorships are not available. So if you want to create a trust line, you need to have sufficient excellent balance for it. And And for the excellent specifically there are no trust lines and instead just create a new account. Then an excellent transfer is performed to a G address that does not exist yet. And this account will be funded with this newly transfer balance. the only caveat is that the minimum transfer amount here is one XLM because that's the minimum balance that H account may have. If the balance is less than one XLM the operation will fail as it does today. well it will fail with an error. So yeah XLM is arguably much simpler because it does not require any

00:46:00.000 --> 00:46:59.999 align:start position:0%
, and yeah, it just is very simple in this sense. , and yeah, I think that's pretty much it on your head over that's a pretty simple cap. , yeah, the only tricky part about it is really handing down the interface. because yeah we could make it much simpler if you went for like binary either zero or infinity trust but we need some signal whether it is too restricted or not. Okay question in classic one of the reasons sponsorship were added was to print accounts created by wlets from being merged by Z party for the base reserve. Is it a concern for creating accounts on transfers of sponsorships? sponsorships? I am not sure I understand the question create an account on transfer

00:47:00.000 --> 00:47:59.999 align:start position:0%
why would you isn't that how it works for for for classic as well like when you create an account you it's like an excellent transfer maybe I could go to this page I cannot if you're talking Oh no,

00:48:00.000 --> 00:48:59.999 align:start position:0%
that's unfortunate. yeah we can discuss this I think I am still not sure I understand this maybe it is some bit of classic protocols that I'm not aware of I want to count out on currencies cap , well, technically the Okay, I think it's technically the transpoint part and XLM part are kind of independent. I bundled them into the

00:49:00.000 --> 00:49:59.999 align:start position:0%
same cap because they really serve the same mission of like dealing with non-existent G account balances. So I thought like it makes sense to close this gap all at once and not just for a part of the site balances. But yeah, if we figure out that something is much harder to do or much easier to do, we could build this up further. But given how simple it is, I would hope we could do both atomically. , , so yeah, that's recaped. , I guess the only one thing to say for now is that we are still not sure which protocol will this go into this get through. , so likely some of the caps will come a bit later, later, may come sooner. So just stay tuned for that. And yeah, please feel free to leave any feedback, suggestions in the C

00:50:00.000 --> 00:50:59.999 align:start position:0%
discussion. discussion. , thanks Ariel.
