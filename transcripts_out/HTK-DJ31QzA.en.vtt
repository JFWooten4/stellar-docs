WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
hey everyone welcome to the open protocol meeting sorry for the slightly late start just a quick technical glitch as per usual so the Stellar protocol meeting in these meetings we discuss and plan for upcoming changes to the Stellar protocol and today we're going to talk about something very exciting project jump cannon which is going to bring smart contracts to Stellar so just quick intro as most of you know Stellar was launched in 2014. at the time there was a very deliberate design decision to keep things simple right so only support a fixed repertoire of transactions but at this point after a ton of feedback from the ecosystem it's clear there's a need for more flexibility so developers they're

00:01:00.000 --> 00:01:59.999 align:start position:0%
interested in building applications they're relying on submitting custom turing complete contra code right to run in the transaction execution phase of the network so essentially people want smart contracts so in march we officially kicked off project jump cannon and there's a link to the announcement in the meeting description and after a very thorough examination of the existing smart contract landscape we made a decision to build it on a we made a decision to build it on a webassembly run times wasm for short so if you want to know more about the so if you want to know more about the selection process there's also a link to a blog called project jump canon choosing wasm and that will sort of help walk through that decision the evaluation that led us to where we are today but today we're actually going to start to get into the protocol changes necessary to like accommodate that decision so we're going to start by talking about the core advancement proposal cap 46 webassembly smart contract runtime environment which as you can probably guess by the title specifies the lowest level code execution and data

00:02:00.000 --> 00:02:59.999 align:start position:0%
model components of a wasm-based smart contract system for the Stellar network once we talk about cap 46 we'll also start to ask some general questions about how smart contracts should interoperate with the network this is as per usual a technical discussion so if you want to keep up i discussion so if you want to keep up i suggest taking a look at the cap as well suggest taking a look at the cap as well as the discussion thread about it those are both linked to in a meeting description and then if you're interested you can also join the conversation about smart contracts you can do that by participating in that thread that's linked to here or by joining the Stellar developer discord which is where we're having all the jump cannon discussions so that the work is open the participatory we're doing you know can really follow along on the Stellar developer discord okay cap 46. so cat 46 came out on friday cap 46. so cat 46 came out on friday i think there's been a lot of back and I think there's been a lot of back and forth on the mailing list though over the past few days a lot of questions asked but I'm going to pass it to graden asked but I'm going to pass it to graden grading I guess to start off with is there anything that you want to tell us

00:03:00.000 --> 00:03:59.999 align:start position:0%
about cat 46 and or about any issues that you have that you'd like to discuss about it today thanks yeah there's lots to discuss here i want to give a discuss here I want to give a little bit of background because this is in some ways an unusual cap is this is in some ways an unusual cap often times when we write caps they're directly changing the protocol or they're proposing to directly change the protocol that people are using and cat 46 is a that people are using and cat 46 is a little bit weird in that it contains protocol contents there are new xcr definitions like there would be in most caps but none of them can actually be used this is a building block for other caps and so if this cap for example were accepted as is tomorrow there will be no new messages that you could send on the network yet so this is just a building block cap it's a piece of vocabulary that we want to talk through the potential uses for in the future but without it without actually committing to a specific transaction

00:04:00.000 --> 00:04:59.999 align:start position:0%
format specific ledger entries anything like that this is a vocabulary like that this is a vocabulary in particular for interoperation between two environments so the way to think about this cap is that it's describing two different places in inside of Stellar core where code can run the guest and the host and so that division between guest and host is a key concept that's being introduced here and most of the cap is a introduced here and most of the cap is a discussion of how the guests and hosts are going to relate to each other both their calling relationship with what values can be passed back and forth between them and then the types of data that will be stored in this particular proposal the way we're discussing data storage actually involves a split and it's a split that's brought about by idiosyncrasies of the wasm runtime interface which is that you can't really pass complicated data types back and forth there's a few other reasons for this

00:05:00.000 --> 00:05:59.999 align:start position:0%
it's actually there's a there's it's actually there's a very large rationale section of the cap that tries to lay out our thinking as we explore different options here there's an efficiency argument code size there's a compatibility the ability for third parties to browse and interoperate for contracts to interoperate with one another there's a whole host of different reasons for splitting data the way we are but really the way to think about this cap is and i've had this conversation with a few people so far to picture in your mind a sort of a to picture in your mind a sort of a four quadrant diagram upper left upper right lower left and lower right and in the upper level you've got the host and guest environments on the left and right okay so those are at runtime okay so those are at runtime while code is executing there's these two environments that are communicating with each other and

00:06:00.000 --> 00:06:59.999 align:start position:0%
sharing access to a data model where much of the data is stored on the host much of the data is stored on the host side but the guest has these little handles that reference into it and then in the lower two quadrants you have corresponding to each of those types of data what we would call the values which can be handles and the objects there's an xdr layer so in the upper two there's an xdr layer so in the upper two quadrants of this diagram you've got the hosting guest at runtime where values are in memory and then and the contract is executing in the lower two quadrants you've got the xdr representation which is sort of data at rest and in fact quadrants are quite the right description because the entire lower layer of this diagram is essentially all xdr but there is a there's a correspondence between values that are accessible in the guest side in accessible in the guest side in valve then the sc valve xdr type that's presented in the cap presented in the cap so the cap introduces these value and object types and it introduces the split between the host and the guest

00:07:00.000 --> 00:07:59.999 align:start position:0%
environment and that vocabulary is a sort of background of what we're trying to get laid out here now we have trying to get laid out here now we have a prototype implementation of this we actually at this point have two prototype implementations because we we've done a version of this in c4 plus and version of it in rust and we're fairly confident this is a this we're fairly confident this is a structure that works well in that it allows a very small and highly interoperable guest code to run in a you know a guest code to run in a you know a wasm runtime that is connected to a host that has these host objects and so most the discussion around this cap so far has actually been like which host objects to start with because there's a potential repertoire there's a potential repertoire of multiple types of host objects and a little bit around the value representation and bit packing and stuff like that but there's not a lot of

00:08:00.000 --> 00:08:59.999 align:start position:0%
you know in many caps there's semantic rules to talk through in terms of a sequence of events that occur in response to a transaction or an algorithm that's implied or something like that there's not a lot of verbs in like that there's not a lot of verbs in this is really more of a nouns cap right it's laying out a vocabulary of things that will exist in memory and or on stable storage and xtr or being sent over the wire and so you can imagine all sorts of operations happening all the actual operations that will occur on this data model are essentially left to later caps they're things that still have to be worked out we're still sort of out we're still sort of experimenting with that but because smart contracts are such a big project and there's so many different parts to smart contracts we wanted to try and split out meaningfully digestible pieces of the problem and you know review them talking through have community input on them

00:09:00.000 --> 00:09:59.999 align:start position:0%
and ultimately as a software engineers you know implement and merge them piece by piece and this is the first piece so that sort of gives a little bit of background on it there was one other thing i wanted to there was one other thing I wanted to mention gradient I actually do have one high-level question for you i know high-level question for you I know you've you go into this in detail in the cap but can you just like give a the cap but can you just like give a brief overview on the specifics of like the value object split because that's something that is very unique in the world of blockchains i think that elrond is blockchains I think that elrond is the only other blockchain that we saw that does something similar yeah for sure yeah so like what is the alternative and why is this better yeah totally so an analogy that a lot of people have this was actually the thing i wanted to talk about i just remembered wanted to talk about I just remembered so I'm glad you brought it up there's this analogy that a lot of people have been using while we're talking about this that i thought it talking about this that I thought it would be good to bring up here which

00:10:00.000 --> 00:10:59.999 align:start position:0%
is that if you've used a web browser you can really think about this in terms that are going to be very terms that are going to be very familiar so in a web browser you program your web pages in javascript but the web browser itself is a very large piece of code that is not written in javascript right so like some of the front end is written in javascript but a lot of the web browser is written in c lot of the web browser is written in c plus or rust or something or c or some other low-level systems language and it's compiled ahead of time and it's essentially a platform for the applications to run on in the end the javascript applications if you if you've written javascript you'll know that you often have object references that aren't references to javascript objects right you can have a objects right you can have a reference to a dom node or a window or a reference to a dom node or a window or a media container or a an xml http request or something like that and these objects they're not like the other objects right you they're not like the javascript code that you have you can't inspect them you can't find the source code to them they're just sort of out

00:11:00.000 --> 00:11:59.999 align:start position:0%
there somewhere where they are is they're in the host environment they're supplied by the c plus platform that you're running on they're much more efficient they can do things that the javascript code isn't capable of doing they're often much larger pieces of code and so if you had to ship them over and so if you had to ship them over and over again with every application your application would be gigantic and so there's a sort of there's a sort of the by being part of the platform and the environment in which your javascript is running they are almost like a library that you can call of very fast very reliable very common features but that you operate at some distance from right you if a function call goes into them you know you don't get to you know you don't get to break on your javascript debugger in the middle of that function call right it comes back to you and then you get control back in your guest code when it returns so that we're approaching this

00:12:00.000 --> 00:12:59.999 align:start position:0%
model and as you said it's the same this model and as you said it's the same model that i think the lra model that I think the lra network uses in a similar fashion where we're coming up with a set of objects that the platform of objects that the platform will provide that are implemented in cpu plus or rust and they're kind of baked into the platform they're things that all or quite a lot of smart contracts are likely to want and so ahead of time the Stellar core developers ourselves and anyone else who wants to contribute to it would have created this repertoire of extra objects and those objects are again fast so they're gonna you know they're not gonna be written in wells and they're not running on the virtual machine they're written in native code they're much larger typically there's a there's much larger typically there's a large code footprint that supports them that will not be included in your smart contract you don't have to include code in your smart contract your smart

00:13:00.000 --> 00:13:59.999 align:start position:0%
code in your smart contract just calls them contract just calls them and so your contract code is much smaller but you operate them at a distance so you have this reference to a host object when you're working on it rather than you know running in the memory of your smart contracts your smart contract has a little linear memory it has the virtual machine has its own memory and so you can write code in and so you can write code in whatever language you're writing and i think most of our smart contract and I think most of our smart contract source languages are going to be we're looking actually at mostly rust there as well interestingly enough and so you could write a data structure in rust and have it running in the wasm in rust and have it running in the wasm virtual machine just like you would have a you know a just like you would have a you know a javascript array or something running inside your javascript program but we're also going to try and provide almost every object that you want as a host object so that you don't actually have to compile anything to your contract except for a handle and so this handle which is essentially a this handle which is essentially a pointer or a certain quasi-pointer it's

00:14:00.000 --> 00:14:59.999 align:start position:0%
not actually a memory address it's just an integer number that starts from zero it counts up as we allocate host objects but these typed handles that you'll be operating on and passing to host functions refer to host objects but they don't actually hold the host object in the guest's memory and so again there's a variety of benefits one of the benefits I haven't mentioned yet so much but it's in the rationale section and we've talked about it a bunch while we were working on this is a bunch while we were working on this is that corresponding xdr form and when we've looked at a lot of smart contracts most smart contracts spend most of their time from what we can tell most of their time from what we can tell if they're not doing cryptography obviously there's the special case of doing cryptographic operations which we'll also get to but a lot of which we'll also get to but a lot of them spend a lot of their time serializing and deserializing their data

00:15:00.000 --> 00:15:59.999 align:start position:0%
store so the smart contract is invoked and it's given a byte buffer and then it spends all of this time in its virtual machine running in virtual machine instructions those virtual machine instructions are just like inspecting a byte buffer and copying values out of it into a data structure in memory then operating on the data structure in memory and then re-serializing it back to plate buffer and that's a little bit weird for a few that's a little bit weird for a few reasons it's not a good efficient use of computational resources because that's like compute expensive work and you're doing it on the virtual machine instead of the host where it would be on in native code and it's also it's very likely to be shared or shareable right if you were using a data structure that is similar to other data structures that other people are using the idea that you would need to do custom serialization deserialization as opposed to just reusing a library that does it is a little funny it's sort of it's making every smart contract ship

00:16:00.000 --> 00:16:59.999 align:start position:0%
redundant duplicate contract code that does the same thing as someone else could do and on that note with respect to commonality the more the data types are common between smart contracts the more you can interoperate between smart contracts so if smart contract a wants to call smart contract b it's going to want to pass data it's going to want to pass arguments right accounts and amounts and maybe vectors containing things maybe large numbers or cryptographic data types or whatever and in order to pass data from one contract to data from one contract to another i mean a contract is just a another I mean a contract is just a program and for two programs to interoperate they have to have a common data language and so if you assume that you're going to have this interoperability requirement between contracts where they share some kind of data vocabulary then necessarily the serialization and deserialization code has to be shared and so factoring that serialization deserialization code out having it be part of the platform and having

00:17:00.000 --> 00:17:59.999 align:start position:0%
the user not actually have to ship serialized code but having the xdr serialized code but having the xdr pulled out of a ledger entry and turned into host objects and then just handing handles to those host objects to a contract saves the contract from shipping any of that serialized code it's is the contract serialized code it's is the contract from having to deal with compatibility issues because everyone's using the same data model using the same data model it just seems like a win all around you it just seems like a win all around you know every time we know every time we sort of thought about this problem from another angle we found another way in which it seems advantageous third-party browsers for example would be able to browse the stable data format as opposed to many smart contract systems every data value that the smart contract saves into the blockchain is just an opaque byte blob that no one can inspect if we have a common data type such as the one that's presented here all of the ledger entries will be at least structured so you could browse

00:18:00.000 --> 00:18:59.999 align:start position:0%
them now you might not be able to make them now you might not be able to make total sense of the contents of it but at total sense of the contents of it but at least have some structure that you'd be able to browse which would make diagnostics easier it would make writing third-party adapters to consuming events coming out of the system easier it would make testing easier creating mock data of attaching fuzzers to it there's all sorts of advantages to using a common data format so I tried to lay some of them out in so I tried to lay some of them out in the rationale section here but it really does seem like this is a does seem like this is a huge key to a better design for smart contracts than what we've seen in a lot of other platforms and so again that's sort of and so again that's sort of why this made up the first building block cap is because if we do adopt this block cap is because if we do adopt this approach we'll be will be deeply structured by this decision and obviously if we don't adopt it if there's really strong there's if there's really strong community feedback this is a terrible idea nobody likes it if all the technical review says this is impossible it won't be able to make it work or it's it won't be able to make it work or it's

00:19:00.000 --> 00:19:59.999 align:start position:0%
you know there's no way you can never come up with common data types that everyone would find agreeable that's really important information to know because it does seem very appealing but if it's not going appealing but if it's not going to work that will also change our strategy very dramatically so i've talked a lot right now i don't know i've talked a lot right now I don't know if you have any other questions or other things that you wanted to discuss about it there's some detail in the cap most of mostly conversation we've been having so far is just like around missing detail in the cap or debating a set of objects that's one of the big questions is like which objects do you include as your sort of mvp first pass what host objects do you include as your baseline so i actually have one baseline so I actually have one follow-up question before we go deep into the details which is how do we encourage people to use these managed objects rather than to do something you know very offensive on the like the source language side on the like the source language side just because they can yeah so this does not this of course this does not preclude you know shipping

00:20:00.000 --> 00:20:59.999 align:start position:0%
your own encoder and decoder and just storing there's a there's a storing there's a data type in this cap called a binary which is just a raw bite array and so if which is just a raw bite array and so if you want to store a rod by right and you want to store a rod by right and you want to ship the serialized deserialized code yourself we're not gonna be able to stop you i we're not gonna be able to stop you i mean it's a touring complete mean it's a touring complete environment right so that's like trying to prevent someone from computing a particular function it's just not it's against the whole point of the platform to try to prevent that but i think you'll have a fairly strong disincentive just from the fee model if there's any type of pricing of resources here which you know there has to be in here which you know there has to be in order to make to arbitrate access to cpu and disk resources on the validators it will be a lot more expensive to do it that way and so i think you'll just that way and so I think you'll just my hope anyway is obviously this won't work very well if the fees turned out the other way but my hope and my assumption is that you'll be saving a ton of you know whatever gas metering fees the system is charging users by using host objects because they're so

00:21:00.000 --> 00:21:59.999 align:start position:0%
much faster and efficient I mean is it time to start digging into some of these details or does anyone i guess my first the first question is I guess my first the first question is in general do people feel pretty good about this model I mean so I have kind of a meta comment which is that it seems to me it seems you know having you know been involved in like a few standardization efforts it seems a little weird to be contemplating a change of this scope without like a requirements document first to reference so like i have a bunch of nits but to so like I have a bunch of nits but to some extent it's gonna be like who knows because like we don't know what the requirements are and aren't right so i have like i have huge concerns so I have like I have huge concerns about the use of floating about the use of floating point values for example it just seems like i can think of like a million bugs like I can think of like a million bugs that like really

00:22:00.000 --> 00:22:59.999 align:start position:0%
catastrophic bugs that are that could happen right like certainly in my lifetime like literally hardware has implemented ieee floating point incorrectly right on top of that there's like from one release to the next of like the compiler runtime there might be small changes like that they might use like a different not a number representation because there's like tons of ways of representing not a number things like that you know positive negative zero so but you know maybe we need it maybe we don't but know maybe we need it maybe we don't but like this is just without a requirements document to go back to like how do we know back to like how do we know whether some of these things are good ideas or not or whether they're gonna serve our purposes so david we've been you know we've been like the one thing that we have going for us right now is that there's a lot for us right now is that there's a lot of prior art in the world of smart contracts and we have made a list of like sample smart contracts that we

00:23:00.000 --> 00:23:59.999 align:start position:0%
are interested in seeing like that should be like a sep or something there should be like this should reference like a document saying like you know like these are the requirements for our for like smart contracts on Stellar right okay that makes sense I can work on that maybe in the meantime if you have specific concerns like the floating point thing is sounds like something we might want to discuss i can speak to that a little bit i mean just very briefly wasm as a spec does include wasm as a spec does include instructions for floating point this cap doesn't specifically preclude them we've talked so far somewhat seriously about the possibility of actually filtering them out of saying that all the floating point instructions equal invalid contract

00:24:00.000 --> 00:24:59.999 align:start position:0%
just again to sort of to allay fears because you're not the first person to use expressed fear is your own floating point now personally myself I'm a little bit more of a floating point believer so i I'm not floating point believer so I I'm not as concerned about that there are two sources of what we might consider non-determinism or wiggle room in floating point behavior that are left open in the wasm spec in all other respects wasm just delegates directly to ie754 and if you do not implement 754 correctly yeah you're in error that's that that's that and 754 has not actually changed in 40 years so i mean i think that's 40 years so I mean I think that's actually a fairly stable thing to point to yeah but it's not it's not to yeah but it's not the standard so much as like implementations of it which have been buggy or there's been like there have been like two cpus shipped in my lifetime that had bugs and they were like very bugs and they were like very high priority fixes so i think high priority fixes so I think saying like that

00:25:00.000 --> 00:25:59.999 align:start position:0%
saying like okay like but these are like exactly the cpus that would be like running Stellar core right so this would be like catastrophic for Stellar core so again if we have a requirements document and say here's like 10 contracts you want and like six of them need floating point then we need floating point if zero of them need floating point then it seems crazy i agree that we can decide I agree that we can decide whether or not to have floating point i think referring to the f div bug as a think referring to the f div bug as a reason that floating point is not a reliable piece of software is hyperbolic i don't think that's a fair objection I don't think that's a fair objection floating point is very well defined at this point what about compilers that like you know use 80 bit when it's in a like you know use 80 bit when it's in a register and 64-bit when it's been spilled to memory right like things like that so a 80-bit floating point is not a an accessible format in lesson you only have access to the 64 all the operations but i find it like all the operations but I find it like there's like a bug in the run time that there's like a bug in the run time that it would like accidentally use 80 bit but you're saying like that it's not available it's literally not available

00:26:00.000 --> 00:26:59.999 align:start position:0%
on the target the wasm target on the target the wasm target does not have extended does not have extended floating point there is at the same time to like figure out if there's a requirement for floating points before getting too deep into what might go wrong i think it's the what might go wrong I think it's the right one okay so tell me you're making that you're gonna make that awesome sound yep okay are there other you know so floating points is we're putting a bracket on and it may come up and it may bracket on and it may come up and it may not we can have that discussion are there other like concerns like that we should get into now well i think like the big one is well I think like the big one is concurrency right like do we require like if the do we require like if the requirements include sort of performance then we need to be able to run you know smart contracts and multiple cores in parallel which entails one set of requirements like making sure that we don't run conflicting smart contracts in parallel

00:27:00.000 --> 00:27:59.999 align:start position:0%
if we don't need performance that you know then we don't need that but it seems like that again is but it seems like that again is something that we need to decide pretty early and it needs to be driven by requirements yeah i can speak to that a little yeah I can speak to that a little bit that is definitely something that we have been extensively considering and have in fact a prototype planned for as with everything sort of above the single contract single vm interface it's not specified in this cap so this cap doesn't for example talk about ledger entries at all and so any concurrency issues relate to access to the ledger there is essentially no there are no concurrent there are no concurrent host objects in this model and i I'm host objects in this model and I I'm happy to spell that fact that these host objects are isolated to a single vm the single vm single threaded

00:28:00.000 --> 00:28:59.999 align:start position:0%
or sorry to a single host context which is may have multiple vms but they are executed on a single thread in serial so there's no concurrent access to host objects whatsoever in this host objects whatsoever in this cap right so this seems potentially not workable depending on our requirements let me finish concurrent access to ledger entries is planned so the ledger would be the shared concurrent data structure the thing that it's meaningful to talk about concurrency with respect to and that's something that we will be discussing in later cap because the transaction format for invoking transactions that we have planned includes a sort of i guess a trick or a standard sort of I guess a trick or a standard pattern from the deterministic database literature where transactions carry static read write sets sort of staple to the transaction so you know

00:29:00.000 --> 00:29:59.999 align:start position:0%
the semantics are strict serializability with the caveat that it's implemented by you know deterministically partitioned read write sets especially there's no actual contention there's no actual contention there's no requirement for concurrency control because the concurrent executions are all on disjoint data i think so an are all on disjoint data I think so an account id for example it's a type that doesn't exactly respond to an actual account it's just yeah it's just the public key or whatever and then the contract literally then and then the contract literally can't see any data that it hasn't pre-declared as part of its rewrite sets so there's a there's essentially a static data structure on a static schedule for each transaction set that partitions it into non-overlapping partitions and then run concurrently so I agree it's a concern it's something that we have been thinking quite a lot about i don't think quite a lot about I don't think most of its contents show up in this cap most of its contents show up in this cap i think they show up in that the

00:30:00.000 --> 00:30:59.999 align:start position:0%
I think they show up in that the cap that talks about the transaction life cycle and access to ledger which will be coming later but i will which will be coming later but i can reiterate in this cap that there is essentially where we're not going to be supporting the any of the wasm multi-threading proposals that are floating around in the future for running inside one of these vms and that the multiple vms that exist inside of a host context that are described in this cap are intended to be strictly serial semantics and that all of the objects would be private to that single thread that are described in this gap so far okay cool and so everything else other than floating point is like completely well defined in the wasm spec like if you shift a 32-bit number by more than 32 bits like that that's like what does that do for example yeah that that's that is well defined that that's that is well defined in the lessons back the there are as i said there are two there are as I said there are two floating point idiosyncrasies they're actually not the ones you're they're actually not the ones you're talking about there's some

00:31:00.000 --> 00:31:59.999 align:start position:0%
nan normalization which all the interpreters we've been looking at have some option for normalizing bands after every operation is just expected to do and the state of the floating point environment flags you have to you know there's a hardware environment the floating point environment which control controls the rounding mode and the exception propagation of the exceptions are eager or quiet and that is assumed that something it's something you have to set and as a host environment you have to set it as a host environment you have to set it to a particular state before you invoke your wasm code but there's no interface for changing it from inside wisely code so you know so long as we specify what this what the settings of the floating point environment are it would be deterministic it would be deterministic with respect to that it's just that wasm as a spec doesn't define what you will set the floating point environments settings too so what happens if you right shift the so what happens if you right shift the a 32-bit integer by 32. i don't know off the top of my

00:32:00.000 --> 00:32:59.999 align:start position:0%
32. I don't know off the top of my head you'd have to look at head you'd have to look at the spec i don't have the glass inspect the spec I don't have the glass inspect memorized but it's it it's very well defined it's one of the most well-defined vms out there i think probably that's ever out there I think probably that's ever been done there was something else you were asking about though oh yeah everything else he is in wizard is very well defined the big caveat in my mind is that there are no host functions specified here but there are a bunch of host functions implied by the data model right like there's a map and a vector and a big num and you know you only have those data values if you expect to have functions that operate on them and a completely reasonable objection that caveat that one might have to this cap is i don't think it's possible to is I don't think it's possible to specify functions on this data type unambiguously so you know we should leave it out and i think should leave it out and I think that's particularly when we're talking about cost models that's something I'm somewhat concerned about is making sure

00:33:00.000 --> 00:33:59.999 align:start position:0%
that it's that we're only including data types about which we can plausibly believe that we would be able to construct correct or at least worth case cost models for any of the reasonable operations that would be implied by the presence of that data type so you know big numbers imply there's going to be big number multiplication can we figure out a reasonable worst case cost model and make sure that that's correct i think we probably that's correct I think we probably can that's why i include big numbers i can that's why I include big numbers i think big numbers are reasonably well studied but you know if that strikes you know if that strikes at the heart of fear of non-determinism or fear of impossibility of bounding cost models i think that's something cost models I think that's something that would be a very reasonable sort of point of debate on this cap is like please leave this out because it's too scary itself like actually doing an exercise to create and enumerate on any of those in the cap itself or is that something that's just a bunch of unnecessary work

00:34:00.000 --> 00:34:59.999 align:start position:0%
i don't i mean the thing is we don't I mean the thing is we don't really we don't have at least I'm not so I'm not really expert in cap writing but it seems to me that we don't have a it seems to me that we don't have a section in caps that's sort of like miscellaneous discussion or speculation and that's really what we'll be doing there we will be speculating forwards to future caps and saying and that's what's unusual about this app is that it is really incomplete it's not a whole feature in and of it's not a whole feature in and of itself i say in the preamble to it that itself I say in the preamble to it that there's actually nothing new that a user can use here which is a little bit weird can use here which is a little bit weird for cap and so it might make sense to include in and so it might make sense to include in that preamble or in the context or justification section or something like that a little bit of forward speculation about you know we assume that the following things are going to come they'll probably look a little bit like this but we're not specifying them here it's just like for context if you like I'm happy to add that no it's okay i think we are going to no it's okay I think we are going to have those other caps like the host function cap for example is one that we need to

00:35:00.000 --> 00:35:59.999 align:start position:0%
kind of lay out as well right and we have a different cap I think that would be around the cost model and things like that limits and cost models so it's all it's fine it's more like yeah it's one that's like being covered in separate caps right now yeah like we started to do that with feedex actually the whole like split up you know like an actual protocol into many pieces so that we have like parts that we can think about discuss and there will be some of that here as well of course i think we want probably I think we want probably yeah now is going to say real quick like yeah i think we want to quick like yeah I think we want to leave some time to also talk about the other topic for today so yeah david you have another question oh yeah what

00:36:00.000 --> 00:36:59.999 align:start position:0%
so i guess I'm also trying to so I guess I'm also trying to understand like so you can have like a 30-pin number either as a value or as an 30-pin number either as a value or as an object a 32-bit number there's no object type for a 32-bit number no object type for a 32-bit number there's only a version there's only a version embedded in value because it always fits in value is the 64-bit type with the tag union on it so there's no reason the tag union on it so there's no reason to ever box it essentially sorry so you have this part where you say like the only the data values that are shared are 32 and 64-bit numbers floating point in integer and then you have these like tag types that include a 30 a 63-bit positive number and like a 32-bit unsigned integer and 32-bit signed integers so how do those like what's the relationship between those and like the fundamental values then i see okay yeah sure then I see okay yeah sure happy to talk about that so the point that you're reading that says there are exactly four types of data

00:37:00.000 --> 00:37:59.999 align:start position:0%
values shared between guest and host I'm maybe being splitting hairs in terminology here a little bit these are essentially the data values these are essentially the data values mandated by the wasm interface so these are the only possible data values there's no way for us to talk about a data value that is not one of about a data value that is not one of those four when we're calling those four when we're calling a function for example and passing arguments the only argument types are those four so well i see what you're saying we don't well I see what you're saying we don't have for example a 64-bit integer like we even though we can pass a like we even though we can pass a 64-bit integer we always interpret it as one of these tagged things yeah so what comes later yeah so what comes later on is and i should on is and I should actually clarify sort of that layering here is that we're picking just the 64-bit type we're actually only using the in n64 and we're saying every value we pass back and forth is going to be an n64 and back and forth is going to be an n64 and we're going to use it as a tag union we're going to use it as a tag union inside of itself to carry a bunch of different stuff so some of which can be a 32 some of which can be an object

00:38:00.000 --> 00:38:59.999 align:start position:0%
reference which can be a small symbol there's a bunch of little values in there well should we move on and talk about the next agenda item which is interoperability there are a couple of questions here that i think that I think yeah i think we can ask more questions yeah I think we can ask more questions on the dev meeting list on the on the dev meeting list on the runtime all right cool let's switch topics then so excuse me on the topic of interoperability my questions kind of come back to the same kind of thing that david opened up with which was like what are the requirements i've been thinking about this for you know the last like 10 days or whatever at this point but it's really vague what we actually want what we actually want and one of the big questions that we keep coming back to that keeps coming up in conversations I'm involved in is like what should a smart contract fund seller be able to do and one of the examples that

00:39:00.000 --> 00:39:59.999 align:start position:0%
you know keeps coming up is like you know one of the things that becomes very centralized on seller today is managing the authorization for an asset you know like what if you want to have you know like what if you want to have like a daily transfer limit or something like that like these are things that are really annoying to do because it all has to be done to like because it all has to be done to like a central server etc but a smart contract could fulfill this role in theory do we want to make it easy for do we want to make it easy for smart contracts to do this stuff where basically they become like a gatekeeper to classic or do we want to not make that easy and or do we want to not make that easy and basically say like hey if you want to build these kinds of things just build them entirely and smart and get the features there and these are the kinds of questions I'm interested in the high level and there's more to like how this is structured but first let's just open this up like do we think those kinds of things should be possible or should we just say like hey just like do that in smart

00:40:00.000 --> 00:40:59.999 align:start position:0%
and to help me like understand that the actual question on this like the low level type of you like the low level type of you know super granular access control example like the question there is like should people be able to do like a normal like classic looking payment and it still ends up being gated by some smart contract is that what the question is i can supply an example but is I can supply an example but i mean understand the use case it's more I mean understand the use case it's more like in terms of the what is the question on the how is that really related to classic i guess i guess the way that I'm imagining I guess the way that I'm imagining any of this stuff working is like anything that comes through like anything that a smart contract is involved in originates on the smart contract side so you'd imagine basically saying okay i'd like to make this payment but then the smart contract does everything all the operations and stuff it's basically just a gatekeeper it's like okay like you can do this then it like okay like you can do this then it goes and you know issues the allow trust

00:41:00.000 --> 00:41:59.999 align:start position:0%
and then it issues the payment and then you know it issues the revoked trust and etc and it does all of that on trust and etc and it does all of that on the native on the classic side basically controlled by smart so you don't submit a classic payment anymore but everything is kind of happening classically including all this allow trust stuff which adds a lot of complexity as we know so i think like the payment alone is I think like the payment alone is kind of an essential building block you can't have classic can't you can't have classic you can't have smart and classic like not even be connected by payments that like that wouldn't make any sense but the other stuff you know the other stuff you know managing trust lines managing signers managing authorization all this other stuff do we want to allow stuff do we want to allow that or do we want to just say hey i that or do we want to just say hey i can't do that from smart i mean i think that yeah this is exactly I mean I think that yeah this is exactly getting to the core of like what getting to the core of like what why i want the requirements that can be why I want the requirements that can be because like one thing that like so definitely like managing trust lines and allow trust is like a big pain it's and allow trust is like a big pain it's like something you might want to do is write a little smart contract says that you know if so-and-so has authorized you

00:42:00.000 --> 00:42:59.999 align:start position:0%
to like hold their asset then like you can automatically hold my asset right so like is that the kind of thing we want to support and if so that requires like a fair amount of like a fairly wide interface between smart and classic right you know my bias a priori would be to you know my bias a priori would be to say that we actually want that because at the end of the day we want you know we want as much we want transactions to be as cheap as possible because that's always been kind of the Stellar way and so the more we can kind of like leverage stuff that's implemented in c plus and it's potentially sort of optimizable through maybe even future things like speed x like the better it also of course makes it easier to debug it's you know makes interoperability better because everyone's speaking like the same language using the same objects but again it boils down to requirements so i can you know while we don't have so I can you know while we don't have this document of requirements I'm happy

00:43:00.000 --> 00:43:59.999 align:start position:0%
to throw some out there you know a one to throw some out there you know a one of the things that are very important for our ecosystem is that existing services and existing stakeholders don't become deprecated so we're talking mostly about exchanges about issuers like circle we want to make sure that their asset is still viable and fully functional with you know the new smart world now what extent is it just like a user just what extent is it just like a user just like you know moves their value into the smart world and then like it's a whole different primitives i don't know that's kind of like what we I don't know that's kind of like what we need to figure out but we do want people to be able to but we do want people to be able to issue smart assets as well that is you know a lot of people a lot of you know a lot of people a lot of issuers are using things like sep 8 today to do things like you know various velocity limits or like minimum balance on their native asset on their issued asset

00:44:00.000 --> 00:44:59.999 align:start position:0%
limits and today that it requires a lot of finagling it would be great for people to be issued to be able to issue them similar to how erc20 tokens are issued so but we could keep step eight so in other words like there would be a new in other words like there would be a new signer type which would be like the smart contract endorses and then you could just kind of like do it through the smart contract but like we would keep the same framework or not right yeah i think we're like i or not right yeah I think we're like i think you're getting into think I think you're getting into implementation here i just I'm implementation here I just I'm getting into the how you choose this actually affects cap 46 like whether certain things are a good idea or not or what base objects we good idea or not or what base objects we might want to have supported and so you know like for example one thing that is not in here is any kind of capability right that i can tell that I can tell so like if like a smart contract wanted to like if like a smart contract wanted to like invoke some privilege or sign some other

00:45:00.000 --> 00:45:59.999 align:start position:0%
transaction there'd be no way to do that maybe privileges or whatever you want to call them need to be some a you want to call them need to be some a kind of first-class thing my privileges here do you mean like a contract has the privilege to do a certain action on a certain account that is not the contracts account or it has a certain signing weight or something yeah exactly yeah this gets into the like the second part of my question in the document which is like the relationship between my contract signers accounts and like lee has proposed this is lee here i don't know I don't know yes so leah's kind of proposed this model where like maybe a contract should be a signer in some sense like if a contract can generally control an accounts trust lines data entries whatever the account

00:46:00.000 --> 00:46:59.999 align:start position:0%
itself then it should be a signer on that account and for a variety of reasons maybe it should be the only signer with any weight on that account so it has like exclusive control but in this world like you could still imagine the kind of case where you want like a one-off right like i want to want like a one-off right like I want to allow this contract to like withdraw funds from my account right now a certain amount that i believe is going certain amount that I believe is going to be withdrawn like 100 or something and this gets like a little weirder it's like well what do you it's like well what do you say like okay like the transaction that runs the smart contract invocation like the account signs that transaction and that's what gives it the authorization but how do you be certain that the con that the smart contract invocation at the time you actually run it is going to do the thing that you it is going to do the thing that you thought it would do it's a little different from like you know a seller contract where you're like this is a payment for fifty dollars signed and that's where i think these kinds of and that's where I think these kinds of privileges come in like either you give

00:47:00.000 --> 00:47:59.999 align:start position:0%
the account like one off control of your entire account at that signing weight to do anything you know you say medium well i can do anything at medium whatever it I can do anything at medium whatever it wants or do you need some better control i don't know I don't know what do you think about this david I mean yeah I think that it cannot sound like a broken record but like there are many possible answers here you know in a priori without having the context requirements might my kind of inclination would be to you know to make privilege something people tend to run into problems with like ambient authority right when it's sort of like any time you do something it's like if there's any possible way you're allowed to do it like you can you you're allowed to do it like you can do it right think of all these like can do it right think of all these like time of check the time of use bugs and time of check the time of use bugs and stuff that happen in unix and so to have some notion that a smart contract has privileges and then it needs to explicitly invoke particular privileges like maybe there's a smart contract that has

00:48:00.000 --> 00:48:59.999 align:start position:0%
we wanted to have power over two accounts and so it has two different privileges and when it's doing something we want to literally specify which of those two privileges it wants to do to avoid you know a kind of confused deputy problem so without knowing the requirements i would without knowing the requirements I would say like i would like to say like I would like to i it seems to me like maybe a good I it seems to me like maybe a good idea to have privileges be like a really explicit thing but again it's a little abstract right now yeah definitely if i can just chime in on definitely if I can just chime in on one thing with respect to vocabularies and cat 46 this is just a minimal prefix right this is this the set of host objects is this the set of host objects we can think of right now so you get to we can think of right now so you get to add new ones in the future if we don't have to have a complete list for this that's all I'm saying sure but you know getting the sort of

00:49:00.000 --> 00:49:59.999 align:start position:0%
privilege model right from the start is probably a good idea like i don't know probably a good idea like I don't know there's i mean there's no concept of a there's I mean there's no concept of a privileged operation here because there are no operations so we don't yeah all I'm saying is we don't have to worry about the weather privileges are properly modeled in this cap we can say that is a thing we have to decide but that is a thing we have to decide but doesn't necessarily hold this gap one thing on the topic of privileges that i think is relevant here privileges that I think is relevant here is like the bigger we make the like interop surface area the more complicated the privileged system has to be if the privileged system basically amounts to like you can only make payments then it's like okay like how much payment can i make from what account to what account for what asset that's like the whole space i think it's sort of unless that's space I think it's sort of unless that's right it gets a little bit yeah more complicated about that and like you know do we say that you can just you know do we say that you can just do payments or do we say that you can do payments or do we say that you can do payments at frequency or like had the number of cases like we're

00:50:00.000 --> 00:50:59.999 align:start position:0%
almost saying that permissions are almost a contract that you can implement so like we've talked about privileges and permissions before but i don't think and permissions before but I don't think we've really talked about how do we make it so that people can innovate on them because you know we could define some basic privileges but then people will be stuck sort of what they have today with classic Stellar that they'll be limitations that they're trying to like work around or you know they end up just going and building their own erc20 like contract just to completely replace the entire system because the permissions don't give them access to what they want to do i mean i guess one of the things I'm I mean I guess one of the things I'm saying is that Stellar actually does already have a notion of permissions or a privilege that's called signing weight and so we haven't really sort of formalized it or maybe like expressed it this way but you know the you know with without knowing you know as a first

00:51:00.000 --> 00:51:59.999 align:start position:0%
draft we probably want privilege we probably want to like you know use that exact same structure and not introduce something new like where things tend to go wrong is if there's like two different you know ways of talking about two different privileged systems that are kind of operating on the same objects then you get like weird loopholes where people can you know there's like a gap between the two that can maybe be exploited two that can maybe be exploited so but the signing weight is it's a really weak privilege system that's what i was talking about at the beginning of I was talking about at the beginning of this where it's like I'm authorizing a contract to do stuff to my account at medium signing rate what am i authorizing it to do though what am I authorizing it to do though like unless i've audited the code the contract might do anything it's way more complicated than looking at a set of opera listeners contract is code so this can only do what the code can do right so sure but i mean like what it might do could but I mean like what it might do could be complicated it might actually even be very difficult for me to predict at the time that i

00:52:00.000 --> 00:52:59.999 align:start position:0%
signed the transaction like imagine a contract where it has two functions one function is hey set a number and the other function is hey whatever number was set most recently extract that amount from my account and send it to the contract i there's no way i can know what the I there's no way I can know what the contract is going to do when i sign for contract is going to do when I sign for it but at the time you add that contract it but at the time you add that contract at the time you give that contract signing weight on your account there's presumably some reason for that right i mean you decided you wanted to this I mean you decided you wanted to this contract have access to your account sure yeah but like I don't necessarily want to give it unfettered control over my account right or even very strong the contract is code right so the contract does what the contract does and you decide whether or not you want that to have access to your not you want that to have access to your account right if the only thing a contract does if the only thing a contract does is you know manipulate the

00:53:00.000 --> 00:53:59.999 align:start position:0%
authorized flag on trust lines then you look at the code you say great like you look at the code you say great like i don't have to worry about this I don't have to worry about this draining all my lumens by signing like huge account fees what if the account is what if the contract is mutable well okay so that's something that needs to be driven by the requirements document do we need mutable contracts right general consensus in this room is yes what that question there's general consensus on in this room and the answer is yes on in this room and the answer is yes okay well i need to be convinced like okay well I need to be convinced like I'm not saying that you can't but don't show me the requirements that tell us we want that what we want cannot be achieved through like multiple releases of a contract it's just like having eval in an actual contract right but if you have multiple releases and a point of indirection which is the pattern people have when they only have immutable contracts if they have a point of direction like a proxy or something and then releases you still have the possibility of the requirement in fact of people delegating authority to

00:54:00.000 --> 00:54:59.999 align:start position:0%
the indirection point with permission and saying i give with permission and saying I give permission to this indirection point whatever it happens to be pointing to right now to do something and so you're right back with beautiful contracts people will work their way around which is something that is behaviorally equivalent to a mutable contract that has whatever permission you've given them they'll either investigate another question on top of mutable contracts or via whatever indirection system you build but i just want to say we are pretty but I just want to say we are pretty much out of time so if this much out of time so if this feels like a great last question i'd say ask it if not maybe we hold off well i was just saying like you can have well I was just saying like you can have your contract not have direct access to the account but just have access to another contract that only does certain things like not the things you don't want to do but anyway so it seems like a requirement we just keep coming back to this requirement stock that you're requesting would be the thing that would help guy guide us figure out the answers to these questions okay cool i'd also like to propose perhaps moving this meeting to the dev discord and having it weekly instead of every

00:55:00.000 --> 00:55:59.999 align:start position:0%
other week because there's there are going to be a lot of questions that we going to be a lot of questions that we need to answer and do it quick with john need to answer and do it quick with john cannon cool I mean I think that we should ask that offline and just verify that works for everybody and look at calendars and i can do that after this meeting awesome thanks everybody see you next time
