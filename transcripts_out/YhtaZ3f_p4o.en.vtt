WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
hello everyone and welcome to the Stellar open protocol discussion so in these meetings we discuss core advancement proposals aka caps these are technical specs that suggest changes to the Stellar protocol necessary to allow the protocol to continue to evolve to meet the needs of the ecosystem and we live stream these meetings so that anyone who's interested in watching they can follow along although i do want they can follow along although I do want to know it is a technical discussion so if you are watching you may want to take a look at the caps you may want to take a look at the caps themselves and they're linked to in the show description

00:01:00.000 --> 00:01:59.999 align:start position:0%
show description also we do keep an eye on the discussion box and your comments there they do help us inform our decisions going forward today's discussion will focus on two caps and our goal is really as it is generally in these meetings to try to resolve some outstanding questions about them so we may not address questions that you ask directly but if some relevant ones come in i may actually try to ones come in I may actually try to incorporate them into the conversation so as i said we are focusing on caps and so as I said we are focusing on caps and this meeting is just part of the cap life cycle so generally caps are discussed on the Stellar depth mailing list there's a link to that mailing list in the event description for anyone who's interested in joining the discussion then caps are drafted and iterated on based on feedback and suggestions and they end up here in this protocol meeting and based on what happens in this meeting they may be put up for a vote by the cap they may be put up for a vote by the cap committee who decides whether or not to accept a rejected cap which point they move into final comment period so there's everyone has a last chance to raise questions on the Stellar debt mailing list and if it makes it through final comment period a cap is implemented into a major Stellar core release

00:02:00.000 --> 00:02:59.999 align:start position:0%
core release then there's still one final step which is that every major release every protocol upgrade is voted on by the validators and has to is voted on by the validators and has to be accepted before it's applied to the network and so all of that is to say this is a and so all of that is to say this is a long process where there's a lot of public participation and ultimately the network decides to accept major protocol changes so enough preamble today we are discussing cap 21 and cap 40. both of these lay the groundwork for building payment channels on Stellar so payment channels they allow multiple parties to securely transact off chain and periodically settle on chain and among other things that could make it easier to build high volume use cases on Stellar so if today's discussion seems dense at any point keep that in mind these caps make technical changes geared towards payment channels and payment channels are important for scaling network throughput so without further ado we will look at the actual caps we're going to start by talking about cap 21. this proposal generalizes the time balance field in transaction to support other conditions including conditions that relax sequence number

00:03:00.000 --> 00:03:59.999 align:start position:0%
conditions that relax sequence number checking and provide relative time locks and since we last discussed this there were some small technical changes there was also the addition of extra signers and i think we should start signers and I think we should start there the new precondition extra signers has been added lee can you just explain what that why that edition happened and sort of talk us through any questions that you have about it yes so extra signers was initially added to support stateless htlc's so the ability to just to say that this transaction needs to be signed by or a hash needs to be included with this or a hash needs to be included with this transaction to make it valid without having to store that hash as a signer on the account so right now you can use the hashtag signer to say that you need this you need a hash included with transactions to be able to transact with an account and instead of needing to store that

00:04:00.000 --> 00:04:59.999 align:start position:0%
and instead of needing to store that on the account it can now just be stored on the account it can now just be stored within the transaction and then second it's also being used for cat 40 which we'll talk about later would help for me to like overview the other changes to cap 21 just because you know i think it was just because you know I think it was already people were kind of generally okay with it the last time we discussed it and so a lot of these changes are it and so a lot of these changes are kind of in response to leads like specific implementation and experience like things that just came up because of implementing it i think that would be super helpful yeah I think that would be super helpful yeah great when you're working so yeah so one of the changes is that the previous version didn't really talk about the results and there's new failure modes now because you've got these multiple preconditions and so you might have sort of multiple preconditions failing and in particular you know you could have preconditions failing because it's too early or preconditions failing because it's too late or both and so what we basically said is if a

00:05:00.000 --> 00:05:59.999 align:start position:0%
and so what we basically said is if a transaction can never be valid again then even if there's other things that are too early we'll still call it too late and we'll give the result code tx2 early only in the case that there is the possibility that the transaction can be valid again if resubmitted at some later time so basically if you have said a thing that's too early and a thing that's too late that gets combined to a too late error and so that fits it into like the existing error codes and i think existing error codes and I think you know preserves the sort of the intuition if you're too late you can never resubmit and if you're too early there might be a chance of resubmitting at some later point so other things that we changed there's some clarifications oh yeah the we kind of rearranged the stuff that's dangling off the account of the account entry in the ledger because it turns out that

00:06:00.000 --> 00:06:59.999 align:start position:0%
in the ledger because it turns out that kind of the sponsorship information is only there if you're actually sponsoring things and so otherwise it's currently null or it's a v1 extension instead of v2 so we changed that into a pointer and we just kept the v2 data structure as a thing that dangles off the v3 now optionally if you're actually using it and then the final change is that we didn't talk about we previously i hadn't mentioned we previously I hadn't mentioned what to do to an account that didn't have an account entry extension v3 and so the answer was just now we just say pretend all the fields are zero right so that means like it's as if like the last time it was mod the last ledger the last time it was mod the last ledger was modified in time and stuff are zero and that's okay because even though that means anything can anything that's like a relative delay will execute any time you would use these things it would be on some new account in some new protocol

00:07:00.000 --> 00:07:59.999 align:start position:0%
on some new account in some new protocol and so therefore there would be some other transaction on the account knew that zero wouldn't matter so again it's just to be precise i don't so again it's just to be precise I don't think it really matters but it's important to like say that it's something just to make sure you know everything is deterministic and fully specified so i think that's pretty much all we so I think that's pretty much all we needed to change right forget anything lee no i think that was everything that no I think that was everything that we listed and I think specifically to do with you know the extension like I'm really interested to hear what nico siddharth john what you folks think of this and how this might impact core well the first thing i'll say is you were the one who kind of just prototyped out this implementation so what was your experience doing it so I haven't tried the new change so the diff the difficulty that i definitely

00:08:00.000 --> 00:08:59.999 align:start position:0%
definitely hit with the initial proposal was that there are assumptions made in core that the sponsors the v2 extension is only present when the account's involved in sponsorship and that shows up a lot in the tests more that shows up a lot in the tests more than the actual application code so i guess if call makes that assumption so I guess if call makes that assumption in tests are there any other products or anything else that makes that assumption that might be interpreting xdr comes to mind I think please continue I think the new proposal which says that you know the v2 is still only there when the sponsorship i think that works from my perspective here like i from my perspective here like i don't think it really matters that much i don't think it's really worth fighting I don't think it's really worth fighting about much honestly in the grand scheme of things like i

00:09:00.000 --> 00:09:59.999 align:start position:0%
in the grand scheme of things like i could see some merits to this now that we have all these dangling things maybe it would be nice to every once in a while you know smash them all down in a while you know smash them all down into one single dangling thing then dangle some more stuff off of it for a while some more stuff off of it for a while and then smush them all down again at a and then smush them all down again at a later date again i can see merit to that again I can see merit to that i think in terms of like how core I think in terms of like how core treats these things core basically like the process that we've used for upgrading these extensions is basically like there's like two parts to it like one thing is like once it comes to existence will never unwind that so like if you sponsor an account and then remove the sponsorship you'll still have the v2 extension so the tests most of them have these assumptions about when will these things appear and that's what you were running into not about whether they will be there or not period the other thing is that we are kind we already kind of made this executive decision when we added the sponsorship stuff that when we added the sponsorship stuff that like

00:10:00.000 --> 00:10:59.999 align:start position:0%
like imagine that you didn't have any native liabilities so you shouldn't have had a v1 extension but then you participated in the sponsorship now you have a v2 extension and we just said like okay well in that and we just said like okay well in that case we'll just inject the v1 extension and set it to zero and it's no different and set it to zero and it's no different from the case where you would add liabilities and then subsequently remove them so from my perspective like core is designed in such a way that like either solution is completely reasonable i think like in terms of the total I think like in terms of the total net implementation changes it would probably be less if we dangled it but the size of the if we dangled it but the size of the extension would be less if we didn't so like so just to be clear you're okay with the current state so the current state is like a right hybrid right where v3 includes v1 but dangles off v2 so that's kind of that that's there's basically this thing called sponsor info that is a pointer to an account extension v2 but that's inside the account entry extension v3

00:11:00.000 --> 00:11:59.999 align:start position:0%
yeah that would be fine I mean again like it doesn't really matter but like if it doesn't really matter but like if you're gonna do that you're if you're gonna do that then the marginal additional cost of dangling the v3 extension off the v2 extension is even smaller because the four extra bytes are appearing in either case so you're saying that there's no situation where it's important that the v2 be null correct okay so well anyway i guess i don't okay so well anyway I guess I don't really i don't care what i really want is for I don't care what I really want is for cap 21 to make it in so like what's the cap 21 to make it in so like what's the best structure to like make this happen or is the current one i mean i think it's is the current one I mean I think it's like I'm the one that always brings this back up you know as soon as you so you know the current proposal in a way is kind of this weird hybrid thing like that is neither of the nested one neither the you know the fully like represented one so i say like represented one so I say like either we consider one or the other but

00:12:00.000 --> 00:12:59.999 align:start position:0%
either we consider one or the other but not this kind of half broken one because you get basically like the reason why you want nesting in the first place that's kind of the whole rationale that we have in the repo actually and why we are in the repo actually and why we are doing nesting is because it makes it easier for people to they don't have to change their code right like if you depend on let's say sponsorship you keep referring to sponsorship the same way you don't have to add the non you know conditions like oh if it's a v3 i need to go look for sponsorship over I need to go look for sponsorship over there instead of over here right and so there's never it's never going to be useful to take something that has sponsorship info and then delete the sponsorship info because or to kind of create new accounts that just don't have any sponsorship info because they've never sponsored anything that's the question it sounded like lee kind of wanted this in order to make a kind of wanted this in order to make a lot of the tests easier to port oh well does it act there's not going to be easier hold on

00:13:00.000 --> 00:13:59.999 align:start position:0%
there's not going to be easier hold on wait let me clarify something there the v3 extension will always exist for a newly created account right that's right but the sponsorship info might not whereas like and it so it sounded like currently there's a cal like in a lot of currently there's a cal like in a lot of tests there's like accounts that don't have sponsorship info and they think they never get upgraded to v2 and i don't know that this is somehow i don't know lee do you want to this is primarily i did this primarily this is primarily I did this primarily in response to your feedback lee so i don't know if you want to jump in and yeah so that so you want to jump in and yeah so that there's two so i think so far we've that there's two so I think so far we've only really talked about the impact on core and it sounded like from what john was saying like there's not really a big impact on core and i think the concern that i had and I think the concern that I had around the impact on tests is maybe misplaced but the second impact is the impact on the ecosystem which i think is what niko the ecosystem which I think is what niko was highlighting to and that is you know everyone who passes this xtr will need to look for fields in the v1 and the v2 in two fields in the v1 and the v2 in two places they'll need to look for it either in the v1 or v2 or in v3 if we move it and i think

00:14:00.000 --> 00:14:59.999 align:start position:0%
in v3 if we move it and I think that's maybe something that eric well like the horizon team would you know that's something that they would be having to deal with basically anyone who passes the xtr has to know to look for it in all these to know to look for it in all these different places which can also be a little bit of a foot which can also be a little bit of a foot gun for people who are upgrading because they may not realize that this field has been duplicated into a new place yeah although we can mechanically fix it with like any place that gets translated to json for example we can just mechanically always move the sponsorship info out yeah i don't think we should be making yeah I don't think we should be making any decisions based on the effects of downstream applications consuming ledger entries realistically we're talking about one maybe two consumers so you know we can talk to them okay you know we can talk to them okay so i think that so I think that i mean to my mind the two things that I mean to my mind the two things that make the most sense are to either keep the cap 21 draft exactly as is or to flatten

00:15:00.000 --> 00:15:59.999 align:start position:0%
cap 21 draft exactly as is or to flatten out the sponsorship info the way it was in the previous revision of the draft so it's just all one big like v3 structure wait well you're saying that so I'm looking at the current master is that what you call the latest draft because this one is the hybrid one that has like this half flattened version exactly and so I'm saying either we just keep that or we should fully flatten it just like instead of having so no but that's actually the one that doesn't make sense the one that's half flattened either you're doing a nesting fully nested right where you extend d3 inside v2 okay or you're doing the full flattening okay and then let's do that how about the full flattening how about i just full flattening how about I just instead of making that up instead of making is having sponsor info be a pointer to like having sponsor info be a pointer to like an account entry or account extension v2 how about i just take the fields of account entry v2 and make put them in line inside the county account entry v3 or

00:16:00.000 --> 00:16:59.999 align:start position:0%
inside the county account entry v3 or just put the whole v2 structure in there yeah I know I don't really care honestly flatten it or fully nest it but yeah the hybrid or fully nest it but yeah the hybrid thing i think is kind of like the worst thing I think is kind of like the worst of all the worlds i propose that i will so i propose to I propose that I will so I propose to just basically revert to what it was before if lee is okay with that what was it before yesterday it was nested before no it was nested before no it was flattened before it was just the fields at the fields of v1 and v2 the fields at the fields of v1 and v2 structures were just inside the v3 structure yeah the things that i do think that yeah the things that I do think that flatten every time we flatten structures it involves changes in a bunch of places that we may changes in a bunch of places that we may or may not understand and i'd rather not do it if we can avoid and i'd rather not do it if we can avoid it so are you advocating for the nested version foodie nested is kind of the as a default is safe

00:17:00.000 --> 00:17:59.999 align:start position:0%
as a default is safe because we don't definitely require the fewest changes to core because we already have well not just score but like yeah it's not just core it's also right like the you know anything out there that is actually using sponsor like looking up sponsorship let's say so what about having them so what about having them not as pointers but just putting the v1 and v2 structures into v3 so then any xtr library can just kind of extract those things by type no but it's the same problem you have to no but it's the same problem you have to switch like you have to change your code that still compiles and still looks like it's working but it will just fail miserably when you actually run into that like existing code it's always the same problem right kind of like the problem we you know we created the problem we you know we created with the what was it the next accounts right like but i would argue that like mux but I would argue that like mux accounts is precisely because it's way worse mexican was way worse because

00:18:00.000 --> 00:18:59.999 align:start position:0%
worse mexican was way worse because of course people use accounts a lot more right but here we make it even more french so that's kind of why you know if you're looking at like the edge case of the edge case and you the edge case of the edge case and you hope that people are going to do the right thing i think it's do the right thing I think it's actually less likely because i mean the problem is that the because I mean the problem is that the nested is just like much harder to program to right it's like you're literally like fighting with like the right-hand margin of your text editor all the time of your text editor all the time where it's like you have to put like line breaks in the middle of like you know expressions that contain dots and arrows to access fields so it's just like you know we're getting the point that we're now we're gonna access fields that are like you know four or five or six deep in structures it's just kind of like painful for the programmers so what so like yes there might be like a little bit more stuff to do in transitional though i would argue that actually if like we do our xcr stuff right it's actually not

00:19:00.000 --> 00:19:59.999 align:start position:0%
do our xcr stuff right it's actually not that hard because you can automate a lot of this stuff and so i'd rather just have a little bit of pain up front and just have something that's like much nicer to program to in the long run so when i wrote in the long run so when I wrote the prototype i actually used the nested version I actually used the nested version i didn't use the flattened version I didn't use the flattened version because it was easier to do an essence i it was easier to do an essence I mean you put the account entry v3 you didn't use the security put the account entry v3 inside the country v2 yeah I'm pretty sure that's what i did yeah I'm pretty sure that's what I did and it was it wasn't that bad how wide what's your what's the width of your text editor i mean i use softwrap I mean I use softwrap the thing is that david like the if you want to have a helper function to avoid typing all this stuff you can right like it's it that helpful function is optional in the nested world it's mandatory in the non-nested world and we already have all right okay whatever I'm overruled like no but

00:20:00.000 --> 00:20:59.999 align:start position:0%
whatever I'm overruled like no but that's gonna vote you guys are all wrong but i'll do it you guys are all wrong but i'll do it this way i'll rewrite the cap to do this you know generations of like poor Stellar programmers are gonna have to be typing structures six nested deep because like whatever you guys are worried about a non-existent problem but fine it's more important to get cap 21 accepted so fine it sounds like a reasonable concession there we are going with the nested version in order to get cap21 done i like it i think this raises I like it I think this raises interesting points though for the preconditions type that we're introducing because the precondition type is setting itself up to be like a flattened version or at least a flattened version or at least that's that was my understanding of the proposal it would definitely work better i mean like in the better I mean like in the like five years from now there will be no benefit you know there will be only disadvantages to doing what we're doing now but like yes in the what we're doing now but like yes in the short run it will be slightly smoother

00:21:00.000 --> 00:21:59.999 align:start position:0%
short run it will be slightly smoother to do it with like a fully nested thing to do it with like a fully nested thing it's just like just how when they were choosing you know not to fix the precedence of the bitwise and or operators when they went from bcpl to c and introduced like the logical double and double r and they're like well you know yeah this is broken but there's like hundreds of c programmers in the world like we don't want to you know break backwards compatibility and you know then we got to the point that even java then we got to the point that even java adopted those broken let's get back like i don't know i understand what like I don't know I understand what you're saying but at the same time there is this like there is this need to there is this like there is this need to sort of get something out there that people can adopt and start using in order to well i adopt and start using in order to well i think there's really there's use cases that there's really there's use cases that cap21 allows there's two cap21 allows there's two problems here i think problems here I think one is i think people are like massively one is I think people are like massively mistaken about you know how hard it is to adapt to you know how hard it is to adapt to something where you have like multiple versions of the structure right and we already have an existence proof that we did it with something which much harder which was the accounts in order

00:22:00.000 --> 00:22:59.999 align:start position:0%
harder which was the accounts in order to get the most accounts right so if we to get the most accounts right so if we survive that we can definitely survive this the second thing is i think people don't the second thing is I think people don't appreciate how much should be automated because currently in our sdk we're doing too much sort of manual stuff right and if you use sort of like more meta programming friendly xdr libraries like say you know goxster the one that i wrote or the goxster the one that I wrote or the xdrpp that we're using for Stellar you can actually automate a lot of this stuff and so what would be great is that since and so what would be great is that since there's like the places where people actually care about this probably if they do it all is when they're manipulating the json and it's not it would be easy to write just like not it would be easy to write just like a few simple rules to like make the json look the same or to understand the json both ways but you know what I'm just beating a dead horse we'll i'll just you know maybe a thing to do is like you know maybe a thing to do is like introduce a cap that's like a meta cap but like this is how we should do upgrades and show some evidence for why in the future

00:23:00.000 --> 00:23:59.999 align:start position:0%
show some evidence for why in the future it's better to actually version structures and put the versions at the top instead of putting these ext things at the bottom but whatever so general preconditions I think that's what was it lee it was yeah asking about that yeah sorry i think in general I think in general a it's a misleading name yeah I'm not really too fussed on the name but i I'm just the on the name but I I'm just not the no it's not the name but the you not the no it's not the name but the you know right now it's hardcoded not general that's what i mean by it's a lie that's what I mean by it's a lie so i thought it was habit you so I thought it was habit you wanted to become like pre-conditioned v1 or something like what do you want no i would like make it an array of no I would like make it an array of you know static array or something but we've already let's but we've already let's not relitigate that i know we do we not relitigate that I know we do we already discussed this already we already discussed this and only introduced because so actually they have a more of a question related to the cap

00:24:00.000 --> 00:24:59.999 align:start position:0%
question related to the cap because what have been the time i spent because what have been the time I spent actually in the past few days was looking at the step that is the payment channel protocol trying to see okay like how is that set related really to the cap and it doesn't look like the set is using all of the functionalities that are in the cap so that's kind of what you know the cap so that's kind of what you know where I'm coming from it's like i feel where I'm coming from it's like I feel like it's trying to guess on use cases that maybe don't exist and at the same time i would don't exist and at the same time I would prefer to grab something that's that can be extended easily as opposed to right now because we can just version it right just we can just version it right now if you mention it you break everybody even if we're doing the fully nested there's no reason why we can't version the v3 thing that's dangling off the v2 right like if you want to add a new condition like if you want to add a new condition you would break all the all consumers no because you would just

00:25:00.000 --> 00:25:59.999 align:start position:0%
all consumers no because you would just have a data structure that includes yeah now you need to add access also every single condition no you just need a function that always converts to the latest version but that can be done in a in an but that can be done in a in an automated way could we just add a v2 can we just add could we just add a v2 can we just add an extension on the end of the general precondition so that we can v2 it dangling i mean we're going to have to if this I mean we're going to have to if this thing is like we're totally bike shedding this thing like and did someone else wanna make a pass at this and then like i'll clean up the mess so that like because otherwise I'm gonna do something that like you guys aren't going to like I think it's worth just responding to nico what you said about you know the prototype channel protocol doesn't use all of the fields the only field it doesn't use right now is ledger bounds it uses everything else

00:26:00.000 --> 00:26:59.999 align:start position:0%
and I think that was a comment or something that david and i talked about very briefly was it doesn't make sense to keep ledger bounds because of that why what is the argument for keeping electric bounds the argument for keeping the ledger bounds is that the current payment channels are kind of probably safe enough but they're not safe if there's like you know something happens and there's like you know an hour of downtime on the like you know an hour of downtime on the network or something which you know does actually happen periodically so somebody who's paranoid and wants to make create a payment channel that is actually robust to downtime of the network would also need the ledger bounds to be safe if right because it never goes down all your timers expire but if you have this ledger bound thing then you have since the network wasn't creating you ledgers while it was down

00:27:00.000 --> 00:27:59.999 align:start position:0%
creating you ledgers while it was down you still have some opportunity to you know get in there and prevent someone from incorrectly closing the channel personally I'm like not really that concerned about changing the like however we struck for the preconditions like we could make it an array of you know we could make it an array of you know of whatever of unions and that would be fine or we could make it a it doesn't really matter honestly to me i think like I think like at the end of the day like people are at the end of the day like people are caring much more about writing these than reading them like the only thing that really should be reading these at the end of the day is you know like if you for some reason want to inspect something to make sure that you're signing the thing that you mean to be signing which i think is like a very which I think is like a very small subset of the code because a lot of times you're assigning the transactions that you're creating yourself in which case you kind of know what you're doing

00:28:00.000 --> 00:28:59.999 align:start position:0%
what you're doing and core and since like this stuff is super isolated down to just like one code path and core and if you read the wrong branch and you're you know signing code and then you you're just not going to sign that transaction because you didn't know what it meant or your code didn't understand it so like i don't feel like the risk of like I don't feel like the risk of blowing yourself up with edge cases here is particularly high so like let's not fight about it that much like we have unions on all like we have unions on all sorts of stuff everywhere and we just kind of you know transactions for like for example i could send you a for like for example I could send you a v0 transaction if your code only knows how to handle v1 transactions you're going to blow up so like we already serious problems is john is your comment about whether or not we need ledger bounds no it's about like the whole like nico saying like these aren't really general it's about that part i personally i it's about that part I personally i think my point is kind of like the ludger band my point is kind of like the ludger band seemed reasonable to me the structure is reasonable to me we could do a different structure and it would also be reasonable to me i don't see a lot of reason to hash it

00:29:00.000 --> 00:29:59.999 align:start position:0%
I don't see a lot of reason to hash it out for 20 minutes so i is just it could you could we so I is just it could you could we just change the name from general preconditions to something else yeah i mean like if you named it like yeah I mean like if you named it like preconditions v1 or something that would map up with the names that we that would map up with the names that we normally use but like that sounds good doesn't really matter to me because if you didn't change it i would because if you didn't change it I would just stick like if you called in general preconditions i would just like if i needed to change I would just like if I needed to change it later i would just call it general it later I would just call it general preconditions of v2 and call today so you know can we add an extension as well can we add an extension as well so that we just follow the same dangling pattern i follow the same dangling pattern I just don't see a lot of reason to is just don't see a lot of reason to is kind of my point here like if you can't handle the types of transactions you're trying to sign you won't sign them and like great if you didn't sign something then you didn't agree to something you didn't understand so that's not that i mean the point so that's not that I mean the point is it's already in union we've already got like no preconditions and time bounds right so

00:30:00.000 --> 00:30:59.999 align:start position:0%
time bounds right so there's like if it turns out that we need a different kind of preconditions we can just add a you know a preconditions v2 nobody can handle the v like the what is it's the extension to like number two like case number two right now anyway without modifying their code so like it's more about thinking about what happens when you change when you make a v2 of that thing change when you make a v2 of that thing right yeah that's what you're saying though like if let's say that i make let's say like if let's say that I make let's say that like i add a new feature which is that like I add a new feature which is like i don't know like time times ledger I don't know like time times ledger bound some super crazy stupid condition that nobody no how about number of ledgers that aren't completely flawless number one that's actually plausible number of ledgers that aren't completely full but like if you want to sign this you're but like if you want to sign this you're only going to sign transaction like if you want to sign stuff and you want to sign stuff and you want to understand what you're signing so you're checking for some condition you're not going to sign stuff that you don't understand so like your code might barf but like you won't have signed something that you didn't understand so it's fine

00:31:00.000 --> 00:31:59.999 align:start position:0%
didn't understand so it's fine like i don't understand what the bad like I don't understand what the bad case if you don't understand something is you're just not going to agree to something that like i don't know i don't like I don't know I don't i don't think there's a bad case there i think the case that I'm concerned with is the same case with that we were talking to about with the account extensions and that is that every sdk every application that pauses the xdr now needs to look for time or now let's take a ledger bounce so say ledger amount stays in the v1 then we add v2 ledger bounds is now going to be in v2 ledger bounds is now going to be in two places so it needs to look for it in two places so it needs to look for it in both places so there's the parsing case and then there's also the creation case for the transaction so sdks need to make a decision about you know what's the general best practice for creating a transaction that has ledger bounds do they use the new v2 has ledger bounds do they use the new v2 that has ledger bounds or do they use the new v1 or do they only use the v2 when they're using one of the new fields and for the most part in a lot of and for the most part in a lot of cases that probably won't matter but in the cases where somebody builds a transaction and then they want to build that exact

00:32:00.000 --> 00:32:59.999 align:start position:0%
they want to build that exact same transaction and they want to expect the sdk to build it the same way that does matter because if an sk sdk developer decides they're just always going to use the latest version structure then the transaction is going to change every time they build that same transaction so we're actually in some ways we're actually introducing it backwards incompatibility because we're saying like you conceptually build the same transaction but you know sdks may make it so that but you know sdks may make it so that you're actually building a different transaction i see what you're getting at here and I see what you're getting at here and like that's a concern i don't totally that's a concern I don't totally think that concern is necessarily exactly relevant here in the sense that like i don't know what promises sdks are making but like if an sdk is promising to have that property that we're not going to retroactively change your stuff and that's really a property of the sdk because like if you're creating like a semantic transaction i feel like the sdk semantic transaction I feel like the sdk just has a promise to do what it's

00:33:00.000 --> 00:33:59.999 align:start position:0%
just has a promise to do what it's what you asked it to do but if you want what you asked it to do but if you want to have a stronger constraint like an exact transaction you probably need a different vocabulary in the sdk for that but putting that all aside like the thing that I'm the thing that makes me scared about like doing the nesting in this context is like you really don't want to sign something that you don't understand like imagine that you're a guy and you're like I'm looking for this ledger bound structure right which i know to be in the case 2 I know to be in the case 2 extension also known as general preconditions but like imagine we're dangling a v3 off of it you have to actually like you can't just call a function to look up the v2 one call a function to look up the v2 one and look out look up the ledger numbers because you actually have to check to make sure that the v3 stuff isn't there because if it is there in nested you're going to sign something that you didn't mean to sign this is what i wrote in the code this is what I wrote in the code example in the agenda this is why it kind of explodes and becomes pretty awful so as versions increment you're going to get more and more of these to go

00:34:00.000 --> 00:34:59.999 align:start position:0%
get more and more of these to go down the rabbit hole of checking so i really think like the much safer thing I really think like the much safer thing is to just fail to like fail to sign things you don't understand and then update your code to understand them instead of having to handle all these cases of like oh like what if the these cases of like oh like what if the what i need something that's in the v4 what I need something that's in the v4 but the v3 doesn't like but the v3 exists but i don't care like but the v3 exists but I don't care about anything there maybe the v5 like that gets really confusing and your code can change out from under you just as the extensions grow basically and i think that there's another and I think that there's another thing too which is that if we were really trying to build this like little language of like you know have an array of little of like you know have an array of little precondition operations that can be sort of like arbitrary or you know it can be constantly extended honestly we then we should try to unify that with like the claimable balances right because we have like two different little languages for like preconditions right or if we do have two different ones then it just seems like really needlessly complex for people to like learn how to use this so what we have is

00:35:00.000 --> 00:35:59.999 align:start position:0%
learn how to use this so what we have is simple it is not it doesn't have to be the last it is not it doesn't have to be the last word because we can change it by again using these unions and it you know it covers like all the things that we need to do payment channels plus the thing that we need if we want to do like super safe need if we want to do like super safe payment channels which like there's you know some people like might want to be able like people could potentially object that you know well on ethereum i can make it safer by counting ledgers or something that like this is like a good set and that like this is like a good set and that we shouldn't let the perfect be the enemy of the good we just do this and if enemy of the good we just do this and if it turns out that it's like so successful that we want like 12 different other slight variations on the preconditions then we can do a an array of a programmable thing or maybe we can update the claimable balances and have like a general language for describing preconditions I'm pretty in sync with david on this one personally i think the argument is basically just a I think the argument is basically just a lot different than the

00:36:00.000 --> 00:36:59.999 align:start position:0%
lot different than the ledger entry stuff where we than the ledger entry stuff where we already have something established that we're already doing so what would that mean the next step is for cap 21 like what is the revision and who who's sort of taking it on I think the only thing we said we might change is to change general precondition to precondition v1 and that was it that's it and we would keep ledger bounds wait i thought we were also we bounds wait I thought we were also we had to move to the extensions these like multiple extensions i think what john counted i thought what I think what john counted I thought what john and you were advocating for was no extensions i thought we were just talking about the I thought we were just talking about the preconditions not the preconditions not the legendary extension there's two questions right one is should our preconditions be how to do future accessibility for the preconditions that are embedded for the preconditions that are embedded in the transaction and the other is

00:37:00.000 --> 00:37:59.999 align:start position:0%
in the transaction and the other is what to do about the ledger entry extension part or the count entry extension part right so john i believe you and i were talking so john I believe you and I were talking about just what goes in an actual transaction the preconditions right yeah that's the thing that i think right yeah that's the thing that I think is really dangerous to have these accessor functions for that just like look that don't necessarily look all the way down to the bottom right and so of course while right and so of course while I'm happy to leave cap 21 and this is it sounded like we wanted like it sounded like the everybody else wanted me to make like these to dangle accounting extension v3 off of account extension v2 yes yeah sorry i left that out v2 yes yeah sorry I left that out at least so i guess i can just do that at least so I guess I can just do that fine i'll change my stomach but i'll do it and so that after that change we'll sort of reevaluate cap 21. are there any other questions that we want to talk about cap 21 right now or should we move on to cat 40. now or should we move on to cat 40. i did have one other question about this

00:38:00.000 --> 00:38:59.999 align:start position:0%
I did have one other question about this there was like something that struck me as kind of strange yeah so there actually i had yeah so there actually I had there like three lines i pulled out and there like three lines I pulled out and like all of them were basically about the exact same thing and i kept thinking the exact same thing and I kept thinking that this was really weird there's a sentence in the proposal that reads all transactions are validated sequence numbers increased and fees deducted before any operations are executed one consequence is that bump sequence operations though they update an account seek time and seek ledger do not affect the validity of other transactions in the same block but that's actually not how things work at all right now so this is like either a very profound change to the way that things work that we'd have to recognize is a really big change even though i don't think people are even though I don't think people are using bump seek a lot or it's a misunderstanding of the current situation sorry the audio is breaking up

00:39:00.000 --> 00:39:59.999 align:start position:0%
audio is breaking up sorry what's the line number or what can i search for or what can I search for because you broke up when you're saying which yeah let me just tell you what to search yeah let me just tell you what to search for if you search for probably if you search for one consequence is that'll probably work let me see if that works okay yeah i often find myself searching for yeah I often find myself searching for one consequences right but that actually is what happens currently right bump sequence happens when you're executing operations it doesn't happen when you're validating operations correct but like let's imagine that you have one source account you submit transactions t1 and t2 at sequence numbers you know n plus one and n plus two you know n plus one and n plus two you get the point and the behavior like both of them are no ops they contain like zero sorry i don't know if david can zero sorry I don't know if david can hear me at all right now no i can't but

00:40:00.000 --> 00:40:59.999 align:start position:0%
oh crap hopefully I'm on summer when like i can't like I can't i couldn't do this meeting but i want to I couldn't do this meeting but I want to move forward so you have okay where's the chat let's take this one off let's take this one to the mailing list i think yeah and I want to point something out that doesn't actually impact the behavior of the bump sequence the payment channels are not actually

00:41:00.000 --> 00:41:59.999 align:start position:0%
payment channels are not actually dependent on that so i think that what that breaks is so I think that what that breaks is that it breaks that right now you can have transactions that fail later because of that sequence number exactly like as you can imagine you have to go on the mainland list at you have to go on the mainland list at this point you're bound from this call there's no chat david not a new chat that i see at least that I see at least so yeah there's not a ch there's not a so yeah there's not a ch there's not a chat in this interface one does not simply chat during the protocol committee meeting yeah it sounds like he can hear it so yeah it sounds like he can hear it so yeah the concern is that you have two transactions first transaction and sequence number you know nn plus one and then the first one does a bump sec to n plus ten this invalidates the second one that will fail with a bad sequence number but that will only happen at applied you know like when you actually

00:42:00.000 --> 00:42:59.999 align:start position:0%
you know like when you actually apply transactions and the proposed change would actually break that if you are changing because it would allow both transactions to execute exactly if the second one has like some funny you know side effects in the proposal now those side effects can actually happen and there are like some pretty important consequences to another sentence in the proposal which is that earlier in the proposal there's a two sentences that read a transaction whose preconditions are not satisfied is invalid and must not execute even to fail meaning it cannot change the source account sequence number or charge a fee but basically the example we just gave you could imagine a like a you could imagine a like a seek gap thing min c mint c gap and seek age whatever you guys know what I'm talking about

00:43:00.000 --> 00:43:59.999 align:start position:0%
guys know what I'm talking about and that would be broken by the current bump seek semantics because it would actually write it during the apply time and then the later one would be invalid at apply time and therefore fail so yeah there's probably some like edge cases here that we have to iron out either we here that we have to iron out either we have to say that these work in a different way from other stuff or yeah I'm not super sure you'll not allow i think i thought what we talked about I think I thought what we talked about before was maybe not allowing more than one so like that source account can only be in one transaction but that's not necessarily easy well i know it's not but that's the only way you can it's not but that's the only way you can make this work i think but you know make this work I think but you know maybe there's a better I'm that's i think the only way but that might be other one another one not that people can figure out but it sounds like this is something that will bear further thought

00:44:00.000 --> 00:44:59.999 align:start position:0%
that will bear further thought like it will require further thought to sort of figure out what's the best solution here and so i think the best solution here and so I think this is something that someone maybe john if you should raise on the mailing list yeah i'll send me an email about it or yeah i'll send me an email about it or something call me by any chance i don't actually no david you have solar flares or something like I'm on a amount of crap you might find out but like this is like super important or can we have this meeting next week or something i knew this was like a bad week for this is like the week that i wasn't gonna have a wired interest I wasn't gonna have a wired interest david didn't predict that it's true did yes i apologize for did yes I apologize for trying to force it forward but i mean we trying to force it forward but I mean we can certainly this is super important stuff that we're this is super important stuff that we're talking about now so there's no way zoom usually allows you to like call and how and get in by phone but when i how and get in by phone but when i click the thing it doesn't give me a

00:45:00.000 --> 00:45:59.999 align:start position:0%
click the thing it doesn't give me a phone number the crazy thing is i can hear everything the crazy thing is I can hear everything you're saying now so maybe just tell us what you want to say okay what i was gonna say is if you have okay what I was gonna say is if you have transaction n and you have transaction n plus one and n is a bump sequence to like say n plus two both can currently execute yes they will both execute but no currently yeah guarantee the second one fails exactly how does it feel so you've actually executed the bump sequence when you're validating transactions sequence suppose transaction n like changes the signer or something right you're still charging a fee for transaction two right but it fails exactly yeah it fails so what I'm like what kind of ends up happening is like any check that we run during validity checking also gets run during

00:46:00.000 --> 00:46:59.999 align:start position:0%
also gets run during transaction application so basically you get all your validity checks get done twice once kind of speculatively and once for real for real and if it fails the validity check that it does again during application it fails at application it's on the ledger it's charged a fee and the sequence number is consumed yeah okay so what about this what about saying like these preconditions always get checked twice if it passes the first time you get charged the fee if you get if it passes a second time you then can execute that that's fine that would basically map up what we're saying but the question is like does that break your stuff no i mean it's a little more no I mean it's a little more expensive but it's like well the age thing that's what john was talking about right yeah i don't was talking about right yeah I don't know if you were able to hear me at that know if you were able to hear me at that point but like this would this potentially messes up the seek age or seek gap i can't the seek age or seek gap I can't remember so maybe we check the age things only

00:47:00.000 --> 00:47:59.999 align:start position:0%
so maybe we check the age things only once in the other fields twice and we like rearrange the data structure if it needs to be such that it's very if it needs to be such that it's very obvious which section is the stuff that gets checked once and which section gets checked twice in all honesty like there could be some sanity to basically saying like hey like these to basically saying like hey like these preconcept precondition things we only need to check them once but you're saying that this would currently allow things to succeed where currently they fail well right now the preconditions aren't anything that can be that can change state like time is time it's all checked against the close time so it shouldn't matter but yeah they can't yeah the yeah they can't yeah the thing is that right now we don't have a thing is that right now we don't have a concept of checks that are done at apply time before like while we do like the fee processing for example like we don't

00:48:00.000 --> 00:48:59.999 align:start position:0%
fee processing for example like we don't have that kind of concept which is I think what we're talking about like a phase that is like let's do all those checks that are like on the you know the only done once per block before anything else happens that would actually be really easy to implement like a bed that would be easy but that doesn't exist today right agreed yeah and i think agreed yeah and I think i wonder if it would do something funny I wonder if it would do something funny also in terms of like results oh yeah there'd probably be some annoying cases to handle there but like because we don't have a place right now to express that there would be a failure in that phase for like for horizon I'm thinking like the mirror doesn't let you fail early like that hold on wait do we really not like early like it doesn't there's like it

00:49:00.000 --> 00:49:59.999 align:start position:0%
there's like it applies at apply time you get the results but you don't you wouldn't know that it's a failure that happened because of a an early check there's something kind of interesting going on here though like i guess the real point would be like I guess the real point would be like these precondition checks are something that should be done at validation time but not at apply time because if they succeeded at validation time i guess you're right yeah that I guess you're right yeah that could also be the that could be the change right the new like the updated thing is that we have certain checks that are only done at validation time yeah i bet that could be useful for other I bet that could be useful for other reasons so i mean the problem reasons so I mean the problem the annoying thing is that okay well one thing i mean it wouldn't be thing I mean it wouldn't be i mean like arguably the behavior that I mean like arguably the behavior that I'm describing here is not like terrible it's just unfortunately like a slightly more permissive than what we currently do it might not

00:50:00.000 --> 00:50:59.999 align:start position:0%
than what we currently do it might not be inherently fatal so david one of the things that's actually annoying to do those checks at validation time only is that we're supposed to have a i don't we're supposed to have a as I don't we're supposed to have a as more or less as an invariant that those checks don't depend on let's just state I mean like they only depend on sequence number i guess only depend on sequence number I guess right but you're still literally you're loading the account entry right you're loading the account entry right yeah that's the only thing but like if we wanted to have like maybe other dependencies there like in terms of checks i guess you could everything depends on I guess you could everything depends on either the ledger header or the ledger entry there's nothing you don't need to fetch any you know right cross lines or any other kind of state so i think that we should still be okay in I think that we should still be okay in terms of no extra database accesses

00:51:00.000 --> 00:51:59.999 align:start position:0%
I don't think that's a big issue i think this is something we can handle I think this is something we can handle in a sane way i think it's just in a sane way I think it's just something i think i just think about let something I think I just think about let me just like address it like i can make a pass of address it like I can make a pass of this and i can propose something this and I can propose something that is that is both compatible with what we're doing today and has kind of the least overhead like avoids double checking if it's sane to do so i have to think it if it's sane to do so I have to think it through a little bit more but i could through a little bit more but I could have you know something by next week or next week i could do something but next week I could do something but i mean that feels like the logical next I mean that feels like the logical next step to capturing one to me yeah okay so i have to address this and i okay so I have to address this and i have to address the nested ext structures and I think yeah like with this new condition like one of the like i guess that paragraph or like I guess that paragraph or whatever section in the cap will be where you can talk about

00:52:00.000 --> 00:52:59.999 align:start position:0%
if we have like specific rules around multiple transactions that maybe you want to like where you want to allow you know like certain combinations like what I'm thinking here is that if you have two transactions with this min age requirement because otherwise you're going to break the payment channel like the you know the assumption that you have a grace period every time you process a transaction for the payment channel protocol that's a good point also well okay i will i think well okay I will I think that's good that's a good change i think that's good that's a good change I think we're going to highlight this specific environment that we're this specific environment that we're going to go after here that's the same environment that we need for the transaction queue policy exactly okay so i think i need is there anything

00:53:00.000 --> 00:53:59.999 align:start position:0%
okay so I think I need is there anything else because i want to make sure we else because I want to make sure we discuss cap 40. no i think we should move on to count no I think we should move on to count 40. i mean there's only four minutes 40. I mean there's only four minutes left so let's jump to cap 40 because i feel like there's a clear path with cap 21 cat 40. what is the let me see that so cap what is the let me see that so cap 40 just trying to find myself so for anyone who's watching this proposal allows participants in a payment channel to safely exchange signatures for a set of up to three transactions in a single step it looks like there are some open questions several but we don't have time that much time so what is the most important question that you need answered here lee so I think i guess the question i've been most I guess the question i've been most interested in is nico raised you know is this the right structure are there other things like local trees that we could be using and then maybe i

00:54:00.000 --> 00:54:59.999 align:start position:0%
that we could be using and then maybe i can add a little more detail on i mean i have that on the mailing list I mean I have that on the mailing list right like that the question there is really so i looked at so the so I looked at so the proposal i think makes sense with the proposal I think makes sense with the current proposal of payment channels because you only have like a very small set of participants if you are looking at what you would need if you have more participants or maybe it's like those multi-hop things or whatever would that make this like insufficient and then you need at that point like some way of expressing a bigger set like a miracle tree maybe i don't know like a miracle tree maybe I don't know something else i mean i think that what we have now is I mean I think that what we have now is so general like yes you can't do merkel trees but you can like interoperate with like ethereum or like other blockchains like it's so not only does it like save entire round trips and like eliminate a whole bunch of foot

00:55:00.000 --> 00:55:59.999 align:start position:0%
and like eliminate a whole bunch of foot guns on these payment channel protocols but it also like in such a straightforward way adds support for essentially we can basically do htlc's with other blockchains without even the hash part right like you can literally like just kind of tie transactions together across blockchains so from my point of view this is just so from my point of view this is just like completely obvious in retrospect except you know obviously it's brilliant because like nobody thought of it until now but like this like it's just it's so straightforwardly like exactly what you want in so many situations where it's like i want this texture only if this like I want this texture only if this executes fine if you execute this then sign the other thing right and it's like we're done right so it's so simple and so useful I also had like a very similar reaction to this when we suggested i was like oh to this when we suggested I was like oh that's very clever no like no i mean i agree like i no like no I mean I agree like I think it makes total sense for the for what we're trying to do right now is for what we're trying to do right now is it's more the question for me is that going to be durable

00:56:00.000 --> 00:56:59.999 align:start position:0%
be durable for in terms of design for the payment channel because i know for example channel because I know for example in lightning oh i think it didn't go in lightning oh I think it didn't go that far because no but like for in the context of payment channels they didn't do that with lightning in lightning for example because they need a lot more to unlock a lot more transactions with one transaction no i think honestly i one transaction no I think honestly i think they just didn't think of it right because you could just say if you have a three hop like lightning payment you could just like have to sign you know all three hops in order to cash you know all three hops in order to cash it in yeah but so you need three yeah you need yeah but so you need three yeah you need this transaction needs to have three additional payloads right sure so that's why this doesn't scale that's the part where it doesn't scale so that's my question let me ask you a that's my question let me ask you a question nico like sometimes there exists a world where it makes sense to have something that's like simple and easy to use but not necessarily scalable and something that's harder to use but highly scalable i feel

00:57:00.000 --> 00:57:59.999 align:start position:0%
harder to use but highly scalable I feel like the merkle tree falls into that category of like it's obviously much more scalable but it's also not as easy friend user friendly and not as easy to fit into like the current Stellar model so like well maybe a miracle tree of one a miracle tree of one element is the same thing right that's kind of what maybe i don't know that's a it's more like a if the design relies heavily on such a construct I'm more questioning the design of the payment channel but honestly you could do the merkle tree it's just the merkle tree would have to be on the ethereum side right but like but you know obviously we don't have like logic to interpret merkle trees but the point is like because you're signing arbitrary data right you could do something such that like a single payment on Stellar like a usdc payment on Stellar could like unlock like 20 you know usdc payments on ethereum right and do some kind of complicated multi-way exchange that way

00:58:00.000 --> 00:58:59.999 align:start position:0%
complicated multi-way exchange that way david if we like let's so your point is well taken that if the merkle tree part was on the ethereum side perhaps this would work there so is the argument you're making that the construct that lee proposes is sufficient for the merkle tree case assuming that Stellar could also handle the merkle trees or is the payload not big enough or you or is the payload not big enough or you know whatever I mean you know to be honest the things that the cases that i think come to mind the cases that I think come to mind involve multiple signers rather than signatures on multiple transactions right because you could always on Stellar you know we have a different way of unlocking transactions which is like twiddle sequence numbers and use like the or the and use preconditions so from my point of view the real the so from my point of view the real bottleneck here is that just like i don't want to add like

00:59:00.000 --> 00:59:59.999 align:start position:0%
don't want to add like a gazillion signatures just because verification is expensive right so if we somehow change the transaction if we somehow change the transaction fees to like also include the number of signature verifications or something like i could see like there's a very like I could see like there's a very obvious way to extend this to have like more than two more than one or two signatures well actually so actually that's related to yeah that question on number of signature verifications actually that's sorry I missed that as part of the capturing in one conversation because you know you guys added this the extra sign at the same time then kat von extra sign at the same time then kat von d and i didn't d kat von d and I didn't i was not sure on which cap was tracking I was not sure on which cap was tracking you know what one thing we could do because in the context of cap 40 it's just another sign i mean the cap 40 it's just another sign I mean the x-ray signature it doesn't matter actually because it's being processed like any it's being processed like any other signature right but we don't charge for signatures do we thought we just charged for operation but for so yeah so now going back

01:00:00.000 --> 01:00:59.999 align:start position:0%
but for so yeah so now going back though on to cap 21 but how it's being though on to cap 21 but how it's being used in a new way right that is you can have like those is it two or three additional signature checks i would argue that signature checks I would argue that those should be counted towards the 20 signatures limit that we have on a transaction okay that's fine right because that way we don't have to change the model in terms of like fees or anything because right now it's i mean if we are going with the I mean if we are going with the did you see what i mean like i think it did you see what I mean like I think it gets too complicated done right and that's a quick cap 21 change because cap 40 just introduces the concept of this new type of yeah of cyano i also want to say we're over of cyano I also want to say we're over time so i think we're going to have to time so I think we're going to have to cut this but i do i mean i feel like with cap but I do I mean I feel like with cap 21 there's a clear path forward and it's that david is going to make those two revisions with cap 40 is there an easy next step that we can take here

01:01:00.000 --> 01:01:59.999 align:start position:0%
easy next step that we can take here just to keep this moving keep pushing is there a discussion that we need to have either synchronously later or async on the Stellar dev list about this question i think we should move to accept cap 40 I think we should move to accept cap 40 today yeah I feel like the argument about you know would it be better if it's a merkle tree this is a little bit it's a merkle tree this is a little bit like one or both you know this is very simple and it does it's you know only really useful in specific constrained cases like the payload has to be below a cases like the payload has to be below a certain size that there's a lot of constraints and so if there's a lot of constraints and so if the constraints are a match this is a great use and are a match this is a great use and then if the constraints aren't and we have use cases that need that are outside those constraints then maybe we need some other type of signer like a mogul tree signer and then you know with that sign like comes a whole lot of costs and things we comes a whole lot of costs and things we have to figure out bigger problems to solve

01:02:00.000 --> 01:02:59.999 align:start position:0%
I mean like the only reason I would say it should not be accepted yet is because we don't like it doesn't make sense to have kept fully in the abstract it's actually in the context of cap 21. actually it does make sense in the abstract the same way we have hashtag signers it's just like a better baby like who is going to use that anybody who wants to like anybody who wants to like tie multiple but who is this anybody my point is that caps what we have in my point is that caps what we have in the you know in the description of a cap is in the description of a cap is that you have to have the use case before we actually go and spend the work on implementing those things so you're advocating for holding off on accepting count 40 until yeah i mean accepting count 40 until yeah I mean it looks fine right like from what we're saying it's fine it's more of a like we're not going to spend time implementing it if you know if we don't have the full story but so we could just make a soft sort of but so we could just make a soft sort of promise okay we're planning to accept yeah this one is like right after we

01:03:00.000 --> 01:03:59.999 align:start position:0%
yeah this one is like right after we accept cap 21 we're looking good yeah so ideally our next protocol meeting whatever that is we can accept both cap 21 exactly yeah i'd rather do that than try to do this than try to do this piecemeal thing because the point of all this is like to get something that makes sense for to get something that makes sense for payment channels yeah sure but i do think cap40 is just yeah sure but I do think cap40 is just it's so simple and it has so many additional uses it's just like a fantastic thing in and of itself but actually one thing i would love to see thing I would love to see in the cap 40 proposal would be a use in the cap 40 proposal would be a use case for cap 40 that doesn't depend on cap 21 that would be cool i would like that 21 that would be cool I would like that lee can you add like an ethereum like swap sure okay so that's all that cap40 will that's like basically the requirement for cap 40 is lee's going to add a use for cap 40 is lee's going to add a use case that doesn't reply require cap 21 rely on caption one the goal for next time is to review the changes that david makes to

01:04:00.000 --> 01:04:59.999 align:start position:0%
review the changes that david makes to cap 21 ideally to get cap 21 shortly followed by cap 40 accepted cool i think anything else we'll just look to I think anything else we'll just look to the Stellar dead mailing list and everyone here thank you so much for joining thanks for your time thanks for thinking this through anyone out there who's watching thank you so much you know it's always you know it's always great to have you here and feel free to great to have you here and feel free to join that dev mailing list if you want to see these discussions and participate in them yourselves there's a link to it in the show description all right sorry we ran over everybody but thanks again for your time
