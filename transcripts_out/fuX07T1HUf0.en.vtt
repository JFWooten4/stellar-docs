WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Great. , hi everyone. I think we have bit of an issue here without clear your agenda in terms of who is supposed to speak. I guess the purpose of today's meeting was just to revisit the caps that we have before the final approval and the agenda suggests that the cap authors would present them and I think almost all the caps have been discussed before besides cap 70. So maybe if parent is here. Yeah. Maybe you could talk about cap 70 because it's completely new and then we could I don't know I guess quickly recap other caps

00:01:00.000 --> 00:01:59.999 align:start position:0%
and there any questions concerning any. any. Cool. yeah that sounds good. so I guess getting started with cap 70. this one is a recent addition to protocol 23 but it's fairly small and straightforward. And so essentially what this does is it introduces a couple of new network config settings that control some of the timing parameters around consensus. so essentially today like during consensus there's a couple of hard-coded values such as the block of the ledge or the length of the ledger being 5 seconds as well as some of the more nitty-gritty details on consensus as to like how long nodes wait for certain rounds like timeouts between certain consensus rounds and things like this. And so essentially this cap doesn't actually change anything but it just allows us to change these values in the future. So for instance today stellar core all the

00:02:00.000 --> 00:02:59.999 align:start position:0%
nodes are hardcoded to have a 5-second ledger time. but with this cap it allows that to be dynamic and configurable. And so kind of the the motivation behind this is that as we want to move towards you know higher throughput and lower block times making you know large jumps is difficult. Going from 5-second blocks to 2 and 1/2 second blocks is very very challenging. so the goal with this is to allow us to kind of make small incremental changes via SLPs where you know to get to that goal of 2 and a half seconds or whatever it may be you know we start by just trimming off like one or 200 millconds at a time and over time we'll get there and so essentially this cap introduces all these new config settings but the default values are the exact same values that are currently hardcoded into core and so cap 70 will have no noticeable change when it's initially implemented but just opens the door to have more configurability and hopefully tighter iteration cycles as we go to

00:03:00.000 --> 00:03:59.999 align:start position:0%
improve consensus and nomination timing in the future. Yeah. So, I think it's pretty straightforward and probably not super controversial, but if anyone has any questions or wants to talk about, you know, feel free. yes have a small question which I kind of already asked in the but basically basically is it possible like for example for seran network settings it is relatively easy to understand what every settings means and you know if you're for example increasing the prov limit for instruction like 100x it is kind of easy to spot that it's probably not going to work because we will take 100 times more time to close the ledger. So my question here is how risky is this set of parameters? Is it possible to accidentally v

00:04:00.000 --> 00:04:59.999 align:start position:0%
for an upgrade that breaks the network in an unintuitive way because we're kind of altering the consensus algorithm which on its own is used to well do everything on the network such as upgrades. So unbreaking the network would be tricky. So you know how risky it is to break the network. Yeah. So I I do agree with you. these are pretty kind of you know low-level technical settings. I think kind of the reason it makes sense from a technical standpoint to be config settings is that these are things that we want to change often and kind of slowly over time to you know make small incremental progress and all the nodes have to agree on them. So it makes sense to be conflict setting but they definitely are difficult to understand. And so I think as far as validation pretty much the only tool that we have is supercluster and kind of simulating the network and seeing the effect these values will have. and they definitely have effects that are sometimes not

00:05:00.000 --> 00:05:59.999 align:start position:0%
super intuitive. And so I think what we might want to do is at the especially when we just launched these features is to put tight bounds onto the acceptable values. so for instance like if today the default value for you know electric close timer is 500 or 5,000 milliseconds or 5 seconds if you were to change that to 50 milliseconds the network that bad things would happen and the network would be very unstable and so perhaps what we can do is given that at least my thinking the goal with this gap is to make small incre improvements we could have very tight bounds just at the you implementation level. and so say for instance like in protocol 23 we could say that the lower bound on the ledger close time is like four 4 seconds or maybe like 3 and a half or like that. And so worst case you know if someone

00:06:00.000 --> 00:06:59.999 align:start position:0%
was to propose like a 50 millisecond change it just wouldn't go through. And you know even like these lower bounds I think these would be like kind of guesses at this point because there's still lots of testing and validity checking that needs to be done on these values. But I think like you know if you go from 5 seconds to 4 seconds that might still cause some network instability. But I don't think you would break the network in the same way that you would if you went from like you know 5 seconds to 50 milliseconds. and so would something like that maybe some tighter bounds alleviate some of your concerns? Yeah. Yeah, that makes sense. this I still feel it might be a bit scary but yeah I guess we can try make sure that maybe one thing I thought of when you were talking is that maybe we could limit the upgrade not only in absolute sense but also in relative sense that you cannot reduce by more than

00:07:00.000 --> 00:07:59.999 align:start position:0%
x% the current value something that so that yeah we don't need to guess too hard. It just kind of enforces incrementality. incrementality. Yeah, that's a good idea. I think I mean like relative values like might have some potential issues like so for instance I I think I like the limited bounds a little bit better than relative changes because you might be in a scenario where for some reason the network is broken either because you've you know changed limits in some way or maybe that there's like some sort of like like a thing that's external to these parameters that's gone wrong that also needs fixing. So I could see a a possibility where due to the network being in a bad state, it would be advantageous to make large changes to these values. and so I don't know if the relative sort of

00:08:00.000 --> 00:08:59.999 align:start position:0%
safety measure is as safe as it sounds from like a disaster recovery standpoint. but I think limited bounds at the minimum would be good and like even for like the relative you know limit the relative limitations. The issue is is that for some of these values you can you know do damage going in both directions right so like you know increasing nomination timeout may improve performance but you know so what I mean by this is that like these parameters it's not that like you know the network gets more unstable if you go you know one direction and then less or and then more stable if you go the other and so I think you So having relative bounds might be a little tricky. I agree like the yeah having bounds in general is just absolute bones is probably the way we want this. , like I think we may want to have

00:09:00.000 --> 00:09:59.999 align:start position:0%
those be more like some sort of like config settings because I could see like for as the goal of this is to understand it in in you know like in in the context of like we want eventually to move those in the on the public network have like the same defaults. So that public network yeah is like it would take basically many you know many things to to be overridden. for for a bad vote to be accepted. But in a other environment like test net or a a test test cluster maybe you want to actually see what happens if you set those things to you know like half a second or whatever. So yeah, so I think it's the type of thing that we should do on the the thing I wanted to add though to this cap is that yeah it's it's the it's only the first building block I mean or the first change I think I

00:10:00.000 --> 00:10:59.999 align:start position:0%
imagine that is needed to really move on the latency front because I can see certain things like that are going to be impacted as if HD this runtime gets too small cuz today we have for example the a lot of things on the network that are tied to to like this 5 seconds. So like the the thing I can think of is we we take snapshots every 64 ledgers or the how fast do we spill from you know one level to another. those things maybe need to change as the block time gets goes down and right now they are not configurable. , of course changing the the u speed of spilling is a much more involved change than than changing the runtime. But that's I

00:11:00.000 --> 00:11:59.999 align:start position:0%
think something that maybe we'll have to to think about. Yeah. And I think that's one of the things that makes like this is a complex thing. interesting is that you know lowering the block time is down is bound to break something. I mean you know we can test dollar stellar core and simulation environments and stuff and even if you know the actual like layer one doesn't break downstream like something will break somewhere for sure. and so the hopefully if you you know shave 100 milliseconds off the time you have you know one thing breaking at a time in minor ways whereas if you went from like 5 seconds to two and a half I'd imagine many many things would break all at once which would be sad. I have more questions but the only comment that I have is that again this is a similar property of all the settings but since there is no like protocol version bump attached that doesn't that means that network may

00:12:00.000 --> 00:12:59.999 align:start position:0%
run on different versions of the core software which means that the the plan of like doing an upgrade based on some minor release changes may not be necessarily sustainable because it's kind of tricky to get everyone on the same version of the software and I guess this may like we can try to make it happen but still imagine the like major changes this direction would still need to be tied to like major releases probably. So I'm understand config setting. It's just an observation that even though it's a config setting, we might not be able to change it too often. often. Yeah. And I think that's why I'm kind of in favor of like a runtime bound limits. I think Nico might have been hinting at like having like a config setting that's like the actual value and then an additional config setting for the bound.

00:13:00.000 --> 00:13:59.999 align:start position:0%
, but I think like to Dimma's point, you know, like a protocol 23 package, , it's it should be known , that like, you know, the 23.0 package probably can only run within like these timing envelopes. And so I think that might be what , what's interesting , is that, you know, even though technically it's a config setting, what we might do is that we can only , you know, even though the bounds are , , part of runtime or, you know, they can even be part of the protocol at this point. and then like say the bound like the lower bound is 4 seconds in P23 and then the lower bound in P24 could be like 3 seconds. And so you don't change the actual value on the P23 to P24 upgrade. but you chose you change how low the value can be. And I think that might be the the best way to kind of think about these settings is that you know there is the bounds can change as you know our latency on ellipse gets better but the actual value is dependent on the network config settings. Yeah. And I guess to that point like

00:14:00.000 --> 00:14:59.999 align:start position:0%
since since bounceration bounceration yeah actually not sure if you can make some notes to disagree on the upgrade validity validity maybe yeah anyways that's not super important but yeah something to I don't think this really needs to be part of the protocol I mean I think this can be like a safety thing where you know there's like a contract that the the upper and lower bound are just you know constants in the C++ code similar to how the upper and lower bounds for other config settings are and there is just like a agreed upon you know contract that you change these bounds on protocol boundaries I guess there's a question chat so do we run the changes on the super cluster and then provide the validators input on any hardware of AM upgrades in a timely manner I guess can answer yeah yeah So I think yeah I think the answer is

00:15:00.000 --> 00:15:59.999 align:start position:0%
yes. so we're doing lots of supercluster testing and I think part of this work too is that I've been kind of running you know some one-off tests myself of late and I'm not sure if the default values on mainet today are actually the best values for the network as it exists. in particular the 1 second nomination timeout value and the 1 second ballot nomination or ballot timeout value are kind of like hard-coded magic constants that have been in core forever that we haven't really questioned and so I think part of this while not part of the actual you know cap itself is you know after we've released 23 doing testing both in supercluster and you know intestance and things like this and finding out what the the true value of these things should be I don't think you know ledger close time I think that one's you know pretty pretty set at 5 seconds. But for these other values, I think there probably is some experimentation to figure out what the actual correct value should be in protocol 23 and then of course in future

00:16:00.000 --> 00:16:59.999 align:start position:0%
protot figuring out the correct values are there as well. I have a lot to say. the intention is not to you know I think to answer those question more specifically to not use these config parameters to like force hardware changes or like force validators to you know upgrade to beefier EKS. I think that's a different conversation. but so so I think yeah we'll definitely test and the goal is not to use these parameters to require you to you know buy more expensive boxes. Right. And guess if there are no more questions on this topic, we can make a quick round up propos this protocol. This is what this med is supposed to be about. yeah maybe can I suggest like yeah not spending a whole lot of time on each cap and it's more like if there are caps

00:17:00.000 --> 00:17:59.999 align:start position:0%
that maybe had like some significant or some changes in the last you know last month maybe we can briefly talk about that but otherwise yeah like just yeah yeah exactly that was my plan basically what I wanted to start with is quickly go over caps that haven't changed and I That's the only thing the only action item that remains with them is just to approve them I guess. So no particular order cup 65 reusable module cache has been both finalized a while ago and also implemented and merged. No changes there. there. then then parallel parallel sorry memories. okay. Cap 62 and 66 about state

00:18:00.000 --> 00:18:59.999 align:start position:0%
archival and in memory resource current are still in implementation progress but there were no changes to the cap semantics as well. So please stay as they they are. are. , cap. Yeah. , cap 63 prior proism friendly transaction scheduling. , again no changes. changes. protocol part of the implementation work is done for the most part. The actual parallel execution is work in progress but again no substantial changes

00:19:00.000 --> 00:19:59.999 align:start position:0%
there. there. caps caps cap 70 has just been discussed. cap 69 new host functions hasn't been implemented but there were no new suggestions there and what remains are cap 68 and 67 and I guess for cap 68 there weren't any changes themselves as a cap about host function for getting executable for a contract address but I know Lee is Lee here might not be here. We had some concerns about necessity of this function and we could maybe work it out during this meeting. But yeah, since we doesn't seem to be here, I guess we'll take this offline. but in

00:20:00.000 --> 00:20:59.999 align:start position:0%
any case, I don't think there will be changes to this cup. Like the worst case is that we'll just not do it if you think it is not necessary. and I guess what remains is Cap 67 which is the unified asset events. and there has been a lot of discussion about this cap and pretty sure there were changes to it recently and the changes were basically ironing out some edge cases. specifically specifically okay looking like working backwards from the history what we did update is that we completely removed from max ID from all the classic events. So for some context

00:21:00.000 --> 00:21:59.999 align:start position:0%
originally CP 67 proposed for transfer events emitted by by the classic operations this cap 67 and by sban token transfers starting from prole 23. initially there was a proposal to allow multiplexing for the transfer source. but since it leads to a number of inconsistencies and is generally not something super widely used basically it's like a transfer where you want to know that some virtual cast account has initiated it even so I still need to sign for it. this kind of a weird use case and I guess the outcome of the discussion on all the edge cases this comes with was that let's not do this for a while until at least next

00:22:00.000 --> 00:22:59.999 align:start position:0%
protocol and let's just focus on the minimum things that we definitely know is useful which is to multiplex idea and we know this is useful because this is how exchanges typically identify their users that represent a non- custodial accounts so they can attribute token deposits to their owner owner database. so this is one change. , another change is actually what makes this cap still not ready for for the final approval I guess is the change to how we emit the information about the fury funds. So again from the previous discussion the current status is that it will emit two events called fee

00:23:00.000 --> 00:23:59.999 align:start position:0%
and the first fee event is what we charge initially before applying the transaction and the second event is also a fee event but with negative value and it represents a refund. So no and sorban refund there is refund both portion of the resource fee. So whatever portion of the fees that hasn't been used will be funded after applying the transaction and this is what we have in kept now. what we still haven't converged on is whether we want to add some additional attributes to this fee events that tell the consumer of the event when exactly did this charge appear because fees are charged before all the transactions are applied. So it's like not a part of the typical transaction

00:24:00.000 --> 00:24:59.999 align:start position:0%
flow and fee is refunded before protocol 23 it is refunded after the transaction is applied and starting from protocol 23 if you will be refunded after all the transactions are applied. So there is this annoying inconsistency with all the other events because all the Azure events happen during transaction being applied. Fees happen before sometimes after all the transactions were applied. And I guess the outcome is that we might alter the MXR slightly to add some information on what is the timing of the FE to kind of make this more obvious. But yeah, I'm still not sure if we have converged this value. So this is something I guess we'll try to prioritize and finalize this cap. yeah, it

00:25:00.000 --> 00:25:59.999 align:start position:0%
is yeah I guess not a major is happening here but that's lots of small pieces that it keep coming up so kind of it. So I guess that's the only cap that is still not fully finalized. finalized. and I I hope this timing will be the last small that we kind of clarify. yeah that's pretty much it. right any questions from this camp or any other caps? But again as I said before we proer caps are no changes.

00:26:00.000 --> 00:26:59.999 align:start position:0%
I guess there are no questions. so I don't know anything else to [Music] discuss it. Yeah. I was curious if yeah if if there was like any feedback on the restriction that were put on the memo from anybody. Okay. Yeah, I don't see any feedback. my my concern generally is that this stuff may not be super discoverable.

00:27:00.000 --> 00:27:59.999 align:start position:0%
my suspicion is that if we make some incorrect decisions in terms of event layout, we'll learn after we have launched cap 67 when people start actually consuming the events and find find out some use cases that are not covered. to be frank at this point, I think we should just converge on something that simply works. 95% of the cases and yeah if we find some issues after it has been launched we can address them in the future protocols protocols the good thing about ma events is that part of the protocol so we can issue a quick fix some information is missing or not necessary or not represents a value as it should. So it is fixable and I think a cup 6 to

00:28:00.000 --> 00:28:59.999 align:start position:0%
7 is in a reasonable scale trip now and it's too much room for centralization. centralization. So I I mean we are obviously open to the feedback but yeah as I said objectively like I feel like at this point like we we got in such such edge cases yeah not sure if it is clear enough for anyone who's who was even going to consume this events I don't think it's clear enough for them but things are happening or Okay, can see typing. , I've been talking a bit about cap 69, the getter for the address executable. executable. , yeah, for cap 67, the timing of

00:29:00.000 --> 00:29:59.999 align:start position:0%
the fees. I I don't think this has been finalized. We need to finalize this I guess outside of this meeting. I think you're almost there. We can just add the timing email to the transaction events. but yeah, we still need to make the respective update and post some discussions thread I guess. so what I wanted to talk about is cap 69 I get 66 69 I get for the address executable I know that you had some comments on this and there was some amazing discussion so maybe if you wanted to talk about this like you're concerned about it in general we could go on the stage

00:30:00.000 --> 00:30:59.999 align:start position:0%
Yeah, I think I I I don't want to read just rehash what , we discussed about I I think I was just like a little bit fuzzy on it. , second I'm just trying to find the cut. Sorry, what was the number? , it's 69. Oh, sorry. 16. No, that's Yeah, because we split it. We we That's right. We split up into

00:31:00.000 --> 00:31:59.999 align:start position:0%
two discussions. So I I guess I kind of like like here is my point of view on this like I kind of understand some of the concerns about like the use cases for this that say not as well defined but that said just from the API standpoint standpoint I don't have like like what I'm looking for is if there are concerns for the API itself like if someone thinks that it is not the information we should be exposing at all because if there are concerns like that then that's valid we could discuss them but you know if you're like trying to understand like the nuances of the use cases I like like I feel like we can fulfill some of the

00:32:00.000 --> 00:32:59.999 align:start position:0%
use cases at least and we can work on more advanced tools ess. ess. Yeah, I think like the the API that's proposed is very reasonable. I I think it it is very reasonable. I think it's the question is what you just highlighted in the is it is there a reason not to expose this information? And it's sort of it reminds me a little bit of the when we were looking at what APIs to expose and what ones not to expose. one that we chose not to expose that other blockchains do and Ethereum does is the concept of a message.cender. so like I think you know if there was a proposal to add message sender to sorban it would also look sort of similar to this one. It would look very reasonable. it sort of makes sense as a primitive that a contractor would have access to, but we made an intentional decision not to

00:33:00.000 --> 00:33:59.999 align:start position:0%
include it in the original you know CAT 46s 46s because in we have seen the effect of it in other ecosystems where you know it can be used inappropriately you know in a way that it's like a security issue. , and it sort of it provided a view into who's calling you. , as opposed to like what the or framework that we've designed is like a a better safer way that abstracts the concepts of like accounts and address like accounts and contracts. , so yeah, I guess that's that's where I'm coming from. That's where my concerns are coming from. And when I like when I read through these motiv the motivations in here, I think I understand the motivations now but it doesn't really completely address those those use cases. So you know if you want to pin the exact

00:34:00.000 --> 00:34:59.999 align:start position:0%
implementations yes it does work for direct dependencies but not for you know transitive dependencies. , so as a primitive, it sounds like it will fit some use cases. It's unclear if it's completely solving those use cases to me. And then yeah, I just have this concern as well of will this result in patterns of use that harm interoperability. , yeah, I agree on the parent's point. I'm not sure if transitive dependencies necessarily like this have I think two concerns that are kind of incompatible right right because like if we went down the pinning road then like and the concern is that the pinning is not strong enough and we should also allow for transitive pin then we are actually going deeper

00:35:00.000 --> 00:35:59.999 align:start position:0%
into the whole like no interoperability because not Not only do you like pin the direct call, but you also want to pin something that happens in the like as an implementation detail of that call. , honestly, like the harm well the harm impro interability piece. Sorry, that's I think there's there's like a few different that's not so much about the pinning. It's more to do with making contracts aware of say the stellar asset contract versus another token and then writing behavior that you know is explicitly different for the two. two. Yeah. I mean I kind of guess it's concern like this asset contract specifically say you can do this right now if you want to. you need to like do a bit more work

00:36:00.000 --> 00:36:59.999 align:start position:0%
than do that. So given that like like for for the site versus non-sack like I I kind of get the concern but we cannot really hide the either. So I don't know like yeah not Oh you're saying you can do this today. You can already do this today because you can go and get the name. Yes. And you can encode the XDR and then verify if they match the same. That's a good point. Right. So, so basically like like here the trade-off is not between like whether like this is faster or not. The trade-off is like if people want to do it, should they keep doing this in a hacker, less efficient way? And you know, whether their use case is good or not, like they still miss themselves into it because they kind of messed up with extern versus providing something that at least they kind of know works. And yes,

00:37:00.000 --> 00:37:59.999 align:start position:0%
you can build something better out of it. But you know, on the other hand, like there are different ways of kind of sensoring which contracts can interact with your contract. And this is actually something that people have been requesting and this is like how stuff like string key contract ID hard coding might end up working and people kind of keep coming up with this idea of like what if I want my contract on the interact with for example XLM or something. So I don't know I feel like you're kind of past the point where you could make things truly abstract. So I kind of get this concern but yeah at this point I feel like for the most part like much about it this guess you can get any of any contracts at least you can hard codes and contract ids.

00:38:00.000 --> 00:38:59.999 align:start position:0%
Yep. Okay. Yeah. I don't have anything else to add to it. I'm not like opposed I'm not like strongly opposed to it. they were just my concerns. So I get the benefits and yeah I think it looks good. Thanks. Sounds good. Yeah. I mean yeah I I'll think a bit more about this like and yeah maybe double check with other folks but yeah honestly like I feel especially for something like transitive dependencies like this is I think this actually strikes reasonable balance because like you still can achieve that but you need to make this explicit and making this implicit sounds like a bit sketchy because technically you shouldn't have control over what other contracts are doing. So, I don't know. Yeah. I guess that's

00:39:00.000 --> 00:39:59.999 align:start position:0%
kind of was it more or less. Yeah, I'll think a bit more about this, but hope should be more or less on the same page here and should be good to go with this this [Music] [Music] kind. Great. I guess it should be truly for today and there are no more concerns. thanks [Music] [Music] everyone. Yeah, thank you. Later the next protocol meetings and
