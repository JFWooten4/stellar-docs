WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
hear me my name is Julia Martinez senior developer Advocate and I'm super excited to get today's session kicked off where we will be learning the ins and outs of Russ smart contract development so I'll go ahead and kick it off with a quick introduction again my name is Julian Martinez senior developer Advocate and Common Man here at the Stellar development foundation once again over the next I guess half an hour to an hour or so depending on how you guys are feeling we're going to dive into some basic smart contract development and we may even scale it up to maybe getting into a staking smart contract just kind of depends on how the flow goes all right so first things first we're going to go ahead and dive into a great online IDE tool here it's called okashi again okashi is an online IDE it's really good for iterating on your smart contract ideas it's got a cool code window where you can type in all your syntax there's the contract window where you can actually call the functions related

00:01:00.000 --> 00:01:59.999 align:start position:0%
to the smart contract that you've just you just coded there's also a console window here that shows the output of the smart contract calls or the function calls rather so if you'd like to follow along you can actually scan this QR code and as I'm updating the smart contract online you should be able to see the smart contract being updated on your local machine as well so what I'm going to do here is bring okashi to my main screen you should be able to see it here all right so this is okashi again we have the code window ready for all the syntax and you know this is where the bulk of your your logic will live for your smart contracts we have the contract window which is going to hold all the functions and will allow you to you know execute and invoke different functions that live on that contract and you have your console window here which is just going to

00:02:00.000 --> 00:02:59.999 align:start position:0%
Output the I guess or it's going to show the return data of the function call itself all right so let's go ahead and dive into rust and sorond if you don't already know sorond is Stellar's smart contract platform so a few things here first things first you see the flag nod that is to tell the compiler to not use Russ standard Library sorb on Smart contracts this flag and optimize for smaller contracts so they don't take up as much space on The Ledger this makes for you know good good forward term thinking for things like State bloat and overall just being mindful of not taking up more space and storage than you need to because in the future it can lead to bottlenecks and user experience and overall just becomes IM manageable so you see here on line three you sorbon SDK this is because sorbon uses a

00:03:00.000 --> 00:03:59.999 align:start position:0%
special dialect of rust with dedicated data types and some special attributes so we're importing a couple of attributes here namely contract contract implementation the N data type symbol string and symbol short now let's go ahead and cover a few of these these two attributes reg are mainly pertain to telling the compiler to treat all the following syntax as a contract would be treated so when it comes to the contract implementation it exposes all the publicly facing functions to the environment for processing through different mechanisms like testing static envir static function testing Etc so with EnV this data type is going to be responsible for accessing smart smart contract storage within the contract itself as well as data from The Ledger so you'll see how we use

00:04:00.000 --> 00:04:59.999 align:start position:0%
this a little bit later when we're creating a key value kind of like storage mechanism for the smart contract symbol now symbol is a I don't want to say it's another term for string but you can think of it as a string so there are two types of symbols short symbol which is a string of up to nine characters and then long symbol which is a string of up to 32 characters but the difference here is that long symbols actually require you to pass in the N data type before constructing them here on the next data type we have the string string is exactly what it sounds like here it's going to be a concatination of letters symbol short is a function that we use to kind of just quickly create short symbols in this case we're going to create a short symbol for the word title now you see here on line five const title symbol equals symbol short title we're just going to use this as

00:05:00.000 --> 00:05:59.999 align:start position:0%
kind of like a label for the key value system that we're about to set up so again you see const title symbol equals symbol short and then we're using the word title all right here on line seven you see the contract attribute followed by line eight Pub struct title contract so we're creating an empty struct and all sorond smart contracts will follow a similar pattern you see a contract attribute the empty struct with the name of the contract itself and Then followed by a contract implementation attribute and then the implementation of the actual contract so let's go ahead and start writing some functions here this is our title contract and the main purpose of this is to kind of illustrate the key value system when it comes to storage so I'm going to create a value for a key and then I'm going to go ahead and well I'm going to create the key value get her and Setter so

00:06:00.000 --> 00:06:59.999 align:start position:0%
we're going to be able to set a value to a key then we're going to be able to retrieve that value from a key so let's go ahead and say Pub function we're going to say set title this is going to take in two arguments we're going to say m of the type n we're going to take in a string and this is going to be for the title value we're not going to return anything so we'll go ahead and get right into the logic again referring back to the n data type up here you see M storage we have to go instance do set and then we're going to actually if you see set we're going to say set and title and then we're going to bring the argument from the title or bring in the argument title in from the the functions here or the the argument

00:07:00.000 --> 00:07:59.999 align:start position:0%
here so let's go ahead and compile this let's see if this works again you see and storage we're taking in the we're taking in the or we're accessing the smart contract storage here we have instance which is a certain type of data type for sorbon smart contracts of which there are three temporary persistent and instance and then you see the set method here where we're actually setting a value to the title to the title key and then the value will be title but it looks like we have some errors here unused variable signature length unused variable signature little literal cannot find type title in this scope okay public function string title and storage okay we got some we got some issues here so let's see what we got

00:08:00.000 --> 00:08:59.999 align:start position:0%
and storage in title H so this looks like it was compiled function set title all right I'm just going to go ahead and do a quick sanity check I do have the correct function on the side here I'm also wondering if this is going to work all right let's go ahead and see what the issue was in the last set title and title okay not sure what the issue was here but let's go ahead and let's see if we can actually debug it side by side let's go ahead and find the difference see this see if this compiles it probably won't [Music]

00:09:00.000 --> 00:09:59.999 align:start position:0%
okay well I'm not sure what the issue was here but long story short here is the correct function as you can see we see Pub function set title we're taking in two arguments one is the data type n the next is the data type string for our title we're accessing the smart contract storage Again by typing m. storage. instance again there are three types of storage in sorb on Smart contracts and they each kind of serve a purpose when it comes to how long you want your data to live by default again temporary instance and persistence for this use case we're just going to use instance we have the set method here where we are setting a value to the key title and the value will be the title argument that we're passing in so let's

00:10:00.000 --> 00:10:59.999 align:start position:0%
go ahead and set a title we'll say soron soron rocks cool it looks like our function call went through and we didn't get any return data however to access this or to access the data that we just set to the contract storage we need to create a getter function so to do this we actually just have to follow the same structure here Pub function we have to say get title we're only passing in one argument that is of type in and if we want to return a string so for this we're going to go end storage instance and we're going to say get and we're going to say and title title and we are going to say do unwrap

00:11:00.000 --> 00:11:59.999 align:start position:0%
or I'm going to say string from from string and we're going to pass in the n and we're going to say default default default message all right so default message here so what is this doing let's see if this compiles first don't want to hit a block okay instance instant so it looks like we got a typo here all right so what are we doing in this function you see Pub function get title so we have one argument that we're returning or one argument that we're taking in that's of N and then we're returning the data type string so here you see n. storage again

00:12:00.000 --> 00:12:59.999 align:start position:0%
this is how we access the contract storage you see instance which is the storage type doget which is the metal the method to retrieve data and you see the key title so retrieving the value that lives at the key title and to access this value see. unwrap and now usually this would be fine right but if no value lives at that key then you need to have some error you need to have some like error handling right so if there is no value that lives at this key we're just going to return a default message in the form of this string that we defined so let's go ahead and get the title all right so this is a new deployment inside of a contained web browser inside contained web app so technically I have not set any data to this this new deployment after creating this function so I click get title the default message will be returned right so get title default message I'll go

00:13:00.000 --> 00:13:59.999 align:start position:0%
ahead and set a new title we'll say Stellar Stellar rules all right so we set a new title instead of sorbon rules we'll say Stellar rules we go ahead and get that all right cool so now you see that we are able to set some data with the set title right and then we can get the data by retrieving it using the get title method now once again this was okashi which is an online ID for sorond smart contracts now what I'd like to do is actually U the kind of tutorial over to the CLI part of things and we'll actually start coding and deploying on testnet which you can actually do on okashi as well but I do want to get you guys familiar with the tools that the SDF offers mainly because when it comes to the Stellar CLI this will be

00:14:00.000 --> 00:14:59.999 align:start position:0%
one of your best friends when or one of your best friends along your Stellar smart contract development Journeys so let's go ahead and switch the windows here all right close this out for now all right so getting started with the Stellar CLI and rust on your local machine takes three easy steps right so what you're going to want to do to make this easier for yourself is to actually scan this QR code here at the bottom left this will take you right to the getting started section of the docs where you'll be able to find these exact commands you'll them right into your CLI but for the sake of the tutorial I might as well kind of go through the steps with you guys so we see curl Proto https tslb 1.2 s

00:15:00.000 --> 00:15:59.999 align:start position:0%
F https and we're going to say rust up ROP sh. sh. sh so what this is going to do tlv T lsv https RS okay so what this is going to do is install the rust tool chain on your computer I've actually done this already so you can see I have rust version 1.79 it takes a little while so I will kind of spare you guys on moving forward so fast because I know it takes about two and a half minutes so in the mean time I can kind of go through the installment process for the rest of the tools we say rust up and Target add wasum oh my gosh 32

00:16:00.000 --> 00:16:59.999 align:start position:0%
32 unknown unnown the demo effect unknown unknown all right so what this is going to do is tell the Russ compiler to compile Russ smart contracts into wasum and it's going to Output those files into a Target directory we'll see this process a little bit later but yeah so that's what what the second command does is tells the Russ compiler to compile Russ files into WM and the last command we have cargo install and we have locked Stellar CLI so this is going to install Stellar CLI the latest version so we're on version 2.2.0 and I know again this would probably take around 2 and a half minutes so if you're following along and and it takes a little while not to

00:17:00.000 --> 00:17:59.999 align:start position:0%
worry I'll I'll move slow throughout the rest of the tutorial so just to kind of like make sure we have the correct version of Stellar installed we'll say Stellar DV again you see Stellar 2.2.0 cool so what we'll do next is we'll actually actually go here and we're going to say Stellar contract actually we'll say stellar and then we'll take a look at all the methods that you see the commands here completion contract events Keys Keys xdr Network Etc so let's go ahead and dive into contract we'll go ahead and clear this out we'll say Stellar contract and then we'll say init and we want Hello World so hello and world all right so you see the messages here writing hello world Etc ET all these good all

00:18:00.000 --> 00:18:59.999 align:start position:0%
these files being written and you see it has injected a cargo or a rust project right into the directory that we were working for or working from and let's go ahead and click into our cargo Tomo file you see a backwards compatible SDK s sorbon SDK 20.3 point2 this is a local issue so I'm just going to go ahead and restart my rust analyzer see if that fixes this little error but we're going to go ahead and dive right into the hello world directory so we'll CD hello world cool and let's take a look at the contract here and you see an older contract that we were not using or not an older contract but you see a boilerplate contract that is different from the one that we're using however I'm just going to go ahead and bring the contract that we're using right into here and we're actually going to work right from

00:19:00.000 --> 00:19:59.999 align:start position:0%
this this so you see this here where we have the Hello World project that we're in and one cool thing about the Stellar CLI is that you can actually generate key pairs right from the clii itself so what we're going to do is exactly that I'll go ahead and go to Stellar Ci or stellers stellers keys and we'll go ahead and list the keys we have already so Stellar Keys LS will list the different key pairs that you have available to actually sign transactions and what that means is every time you deploy a contract or invoke a function Etc that takes fees right so there has to be a source account assigned to that transaction to pay that fee now we have two that exist already but let's go ahead and demonstrate how to create a new one and we'll say Stellar generate we'll say Stell Keys

00:20:00.000 --> 00:20:59.999 align:start position:0%
generate and we'll Define the network network testet and we'll give this a name so for this name we want it to be shy so let's go ahead and generate a new key pair called sty for the testet network cool you see that the function has went through or the method has been executed Ed let's see LS right so you see stroy Alice and Joe and we'll see address shy and N Stellar Keys show Shy all right you see the two key or you see the key pair here this is the public key and private Key by the way I'm just doing this for demonstration purposes only please never share your private key with anybody but here is is what happens when you generate a new key pair

00:21:00.000 --> 00:21:59.999 align:start position:0%
using the Stellar Keys generate method as you can see you can see the address it begins with G and the source account or the source key that begins with s so moving forward let's go ahead and deploy this smart contract to the network and we're going to go ahead and say say Stellar contract deploy and we'll say actually we have to start with Stellar contract build Stellar contract buildt and again what this is going to do is actually compile the rust smart contract into its wasm format here and it'll be in the directory wasum Dash or wasm thir 2- unknown D unknown it'll take a little bit maybe around 1 to two minutes maybe less all right so about 1 minute we'll go ahead and look at the

00:22:00.000 --> 00:22:59.999 align:start position:0%
release directory you see here WM 32- unnown D unknown in the release directory you have the hello world wasm file that's because we're actually still defining this project as Hello World so when it gets compiled you'll see that it it gets compiled into the name of the project itself so to resolve that we would actually have to go and change the name of this project as as a whole but we won't do all that for the sake of this for the sake of this demo so we're still working from the hell World directory and we are going to deploy the Stellar smart contract onto testnet so we'll say contract deploy right and we have to define the wasum wasum is going to be Target Target wasm release and we'll say hello world and was and we'll say the network it's going to

00:23:00.000 --> 00:23:59.999 align:start position:0%
be testet and we're going to say source is going to be shy all right so this is the command to deploy contracts onto the network you see Stellar contract deploy you're defining the wasum location right where the the location of the wasum file so the compiled file of the smart contract you see network is test net and then the source is troopy so let's go ahead and send this transaction fingers crossed we get a contract ID back all right that was very fast and you see that this begins with the letter c so let's go ahead and go back to our key pair just a quick lesson on how addresses are defined on Stellar you see G is for the public address C is for contract addresses s is for Source account or Source Source keys or private Keys rather all right so we've deployed deployed the contract and here

00:24:00.000 --> 00:24:59.999 align:start position:0%
is our ID let's go ahead and call some functions on that contract so let's go ahead and do Stellar we got to do contract and for this we're going to do invoke and we're going to define the ID here and we're going to say network and we're going to say testet source is going to be stroy and then we are going to find our function by doing the following say dash dash we're going to call the function or Define the function and then we're going to Define the argument here so set title takes in one argument for title and we're going to use quotes and we're going to say Stellar smart contracts Ah that's too long we'll just say Stellar drop

00:25:00.000 --> 00:25:59.999 align:start position:0%
cool all right you can see here that there is an unrecognized sub command so what does that mean basically means that I spelled a command wrong right so one cool thing about the error messaging with the CLI is that it'll actually kick back some functions that it thought that you meant so we see here set title you can use an underscore or a dash or a hyphen I'm going to go with the underscore here and we're going to go ahead and we're we're going to demonstrate calling that function so we'll say set title and we have the correct function name so it should work it looks like it did and let's go ahead and get title all right so just like that we've used the Stellar CLI to create a

00:26:00.000 --> 00:26:59.999 align:start position:0%
new keyp pair deploy a smart contract to the test Network and invoke the functions for that smart contract and just to do a quick recap some some of the smart contract Basics that we learned today were data types as well as a little bit of the ins and outs of contract storage so really quickly I kind of want to recap those again we have contract comp cont contract implementation which are both attributes specific to soron and which is responsible for getting data for the smart from the smart contract as well as a blockchain on Stellar we call it the Ledger you have symbol which is either a string of up to nine characters or 32 characters string which is the string that you're familiar with symbol short which is a function that helps you create short symbols so that's a little bit about the data types and now when it comes to contracts storage we kind of went into some 101

00:27:00.000 --> 00:27:59.999 align:start position:0%
for key values I guess structure on Stellar smart contracts here you see on line five cons title symbol equals symbol short again we're just using this line as a placeholder to kind of have an easy reference for a key that we that we're naming throughout the smart contract contract attribute with the blank struct with the title here and this is basically how all sore Bond smart contracts look the contract implementation attribute followed by the implementation of the struct or the contract itself and the functions here you see Pub FN set title again we're taking in two two arguments the first one you will always see n as an argument within each function for soron smart contracts and this will kind of be like the pattern that you'll see throughout your development Journey with Stellar so

00:28:00.000 --> 00:28:59.999 align:start position:0%
just get familiar with this structure Al together so we have en as the first argument and then title as the next argument taking in a string value again to access storage within a smart contract you have to write the syntax end. storage Dot and then the type of storage so in this case instance but again three types temporary instance and persistent to set of value to a key you call the set method right and then you're defining the key so in this case title which is a placeholder or the the title or the name of the key and then the value that we're setting is the argument that we're passing in for the function also called title all right and then to retrieve that data you have to go and through a similar process but reverse so again accessing the smart contract Storage and. storage instance right. getet is the method that you'll

00:29:00.000 --> 00:29:59.999 align:start position:0%
be using you're referencing a key for the key in the smart contract storage so the key here title and to get the value of the key you have to use the unwrap method in this case we're planning for errors so we're saying unwrap and if no value lives at that key then return this default message all right so that's a quick recap about on on some basic SM contracts but we do have quite a bit of time left so I'm going to go ahead and kind of just like dive into some more Advanced smart contract methods or not methods a little bit more smart contract a little bit more advanced smart contract logic and I'm going to go ahead and just kind of freestyle this but I do have a staking repo that you guys can reference for your own kind of like studies if if you want to and you could find it here in this QR code so

00:30:00.000 --> 00:30:59.999 align:start position:0%
this will take you to a hackathon repo that I set up that has a couple directories in it you'll find a workshop directory and I think you'll also find a slides directory but we'll be working from the workshop directory here you should see staking and data types so I'll go ahead and give you a quick overview on how data types kind of look and I guess how they're implemented here so some of the main things that you're going to want to know is like enumeration right one thing that we use here kind of at when it comes to Stellar smart contract development we often use enumerations as Maps so when what does that mean right when you look at a data key of a smart contract when you look at a data key of a smart contract you're basically setting a key value system similar to the key value system that we defined earlier

00:31:00.000 --> 00:31:59.999 align:start position:0%
when we go back to I guess we can go back to this basic smart contract here hello world all right so you see con title right this is the key and then again we're setting the value later with the title right so key is title and then the value is also named title so if we go back to the staking smart contract right go ahead and dive into it you see here the data key we can set we can host many keys and throughout the smart contract logic we can Define the values for these Keys so we'll actually just Dive Right into this smart contract over the next 30 minutes and then by the end of it you should be able to understand more data types more ins and outs of smart contract storage and then we'll kind of like take a look at some more examples of Setters and Getters as well as cross contract calls all right so so go ahead and strap in stick with me thank you so much

00:32:00.000 --> 00:32:59.999 align:start position:0%
if you've been with us thus far and I hope you're learning something yeah so let's go ahead and get it kicked off again at the top you see no STD again that's to tell the smart cont or to tell the compiler not to use Russ standard Library when compiling Russ smart contracts or when compiling sorb on Smart contracts keeping them optimized small so they don't take up so much space on the Ledger again on line three you see us sorbon SDK some familiar attributes we saw from the last example contract contract implementation now you see contract type this is to this is to derive a certain type of what's it called certain type of how do I put this object from the sorond SDK and treat it accordingly so we can dive into the ins and outs after and I'd be happy to get you more information on how

00:33:00.000 --> 00:33:59.999 align:start position:0%
attributes work after the stream so here you see VC Vector is a an array of conc continuable data so what does that really mean it's just an array not specific to to types you can have a vector for integers you can have a vector for Strings Vector for symbols Etc address is just the way that that we or the data type for sorbon smart contract addresses U byes n which is a fixed bytes array or fixed bytes value you have the end data type which is again used for accessing data on the blockchain and Ledger and then interal we're not going to get into this but ve again this is the actual data typee V here in lowercase is the function that we use to quickly create vectors all right so let's go ahead and dive into

00:34:00.000 --> 00:34:59.999 align:start position:0%
the data key enumeration here in the comment it kind of explains everything but this is used to represent the state variables stored in the smart contract storage again it allows for super easy convenient access to data within the smart contract we covered this a little bit earlier but each one of these Keys here has a value that's attached to them so you see public enumeration data key and a list of all the keys within this within the contract you see contributions in parentheses address so what does this mean this means contributions is attached to many keys so all these Keys must hold the data type address right so address a b c and d u but all of these addresses are mapped to one value so basically this data key will record which address made which contribution right rors is just going to be a vector of all the

00:35:00.000 --> 00:35:59.999 align:start position:0%
addresses that have made contributions token is just going to be the address of the token that the contract corresponds with share token is going to be the we're actually going to Mint a token from this contract to use as a a share token so we're going to distribute tokens when a user makes a deposit and here we're actually going to write that into the contract itself is active is going to be a Boolean so if this value is true certain logic ensues if this value is false again a certain path of logic ensues admin is going to be an so this address will have certain capabilities and be able to hold domain over various functions initialized is going to be a Boolean that tells the caller whether or not this contract is or is not already initialized all right so this is our staking contract right

00:36:00.000 --> 00:36:59.999 align:start position:0%
and again you see the contract attribute empty struct with the name contract implementation attribute and let's go ahead and dive into our functions so this is our initialized function it takes in three arguments again and the execution environment of the contract admin pretty obvious it's the address of the admin token wasm hash this is an interesting one because we'll actually be creating a new token right from the wasum hash itself and then the token will be the address of the deposit token contract so the acceptable token for the campaign for for the staking campaign so it must cor the token being deposited must correspond with the address that is set here within the smart contract function during this initialized call and the token wasm has we're actually going to be able to use a wasm hash to access an interface whereby we will

00:37:00.000 --> 00:37:59.999 align:start position:0%
be minting a random token or a just generated token a soron token if you will to people who make deposits to the campaign all right so diving in you see some familiar functions here all right so first thing we're going to do is set the admin address in storage so n storage. instance set again as previously covered and to access the smart contract Storage storage to access you know the actual part of the smart contract for storage instance is the type of storage we're accessing set is the method and just a a quick variation from the demonstration before you see and data key and then admin same thing as before when you see the other smart contract here right let's go ahead and open this same thing as you see here and storage instance set and title let's go ahead

00:38:00.000 --> 00:38:59.999 align:start position:0%
and go back here end storage set and data key admin here it's just defined in this data key so you're just literally accessing that and then you're passing in the argument for the admin argument here in the function all right so you see let share contract equal token create contract we're actually able to do this this by importing do we import the token data type all right so there is a module here mod token and we're actually importing that importing this module this file here into the main smart contract and what this will do is import the pre-compiled sorbon token contract file and will allow the main smart contract to use use the functions that live on on this contract so

00:39:00.000 --> 00:39:59.999 align:start position:0%
actually from a compiled wasum file we're importing that into the main file into the main smart contract rather so where were we I'm getting all ahead of myself here so that's how we're able to use the token U file the token smart contract to call the function create contract so let share token right here we're going to create a new contract cont by calling the by calling the create contract method that lives on the token file and we're going to use the token wasm hash here to create pretty much the token file of the the token contract from this compiled wasm hash and we're going to take in we're going to call that interface at the token contract that we are setting in the initialized function here again you see token client

00:40:00.000 --> 00:40:59.999 align:start position:0%
new all right so we're going to create a new token kind of like interface over the share contract and then again we're going to call the initialize function so here we're going to set the admin as the current contract address so the staking contract itself we're going to Define the decimal places and then we're going to define the name and then we're going to define the symbol so just a quick recap what are we doing here we're going to say let the share token equal a new token contract right so we're going to create a new token contract again token wasm has token address all right so we've created a new token and then on that new token we're call the initialize function and this is what

00:41:00.000 --> 00:41:59.999 align:start position:0%
we're initializing that new token with all right so moving forward let's go ahead and see what else is happening we have end storage instance set so we're setting the token key with the token smart contract address and then again moving forward we're setting the share token key value as the share contract address and then we're setting initialize to true so after this is all set in done most of the data Keys have been defined you have the token being defined as the actual token address that has been passed in by the user the share token is defined when the share token is deployed and initialized is active hasn't come into play yet admin was passed in in the initialized function and then initialized the value here gets changed at the very end of the initialized sequence all right so moving forward we have start campaign and what this is going to do is just basically set the isactive value to true

00:42:00.000 --> 00:42:59.999 align:start position:0%
the thing here to note is that we're actually making a super cool use of authorization the authorization framework on Stellar so you see Pub function campaign admin address so admin. require off this means that the person making the call must be the same value that is passed in in the admin argument I can't pass in G2 if my address is G1 so this will fail if I'm passing in an address that is not the wallet that I'm calling from so let current admin equals end storage instant get so we're defining the current admin right so we're saying we're going to get the current admin from the contract storage here by unwrapping the key the data key admin and then we're going to say if there is no value that lives there which it

00:43:00.000 --> 00:43:59.999 align:start position:0%
should right because we've just initialized a smart contract then we're just going to return this current contract contract address and we're going to say here we're going to create an assertion if the admin does not match or if the admin address that was passed in for the argument does not match the current admin address value then we're going to panic and we're going to make this function fail all right so if that's all good then we're going to say end storage instance. set data key is active right so once we set that value to true the campaign has started and let's go ahead and take a look at what that means right so we can go the other way stop the campaign again same exact logic except for here at the end for setting that value data key is active to false after this we can easily check the campaign status right Pub function check

00:44:00.000 --> 00:44:59.999 align:start position:0%
campaign status we're returning a Boolean value so same as from the demonstration before M storage. instance. getet with the I guess Target location for lack of a better term and then we're using the unwrap or method if there's no value that lives at the key is active we're going to return false by default all right so go let's go ahead and take a look at the deposit functions in which draw functions I just want to make sure that we are in fact using the isactive variable doesn't look like we are okay actually we are here all right so let's go ahead and dive right into it so what does this function do this function will actually record a deposit made by a contributor if the staking campaign is active so it takes in four arguments and as always going to be the execution environment of the the contract contributor the address of the U person making the deposit the

00:45:00.000 --> 00:45:59.999 align:start position:0%
token the address of the token to deposit and obviously the amount so the contribution in tokens here you see contributor require off meaning that again only the wallet making the call is allowed to make the call I can't call deposit and then pass in another wallet address it has to be the wallet that I am making the call from that I am clicking the button with all right so let's go ahead and move forward if the status okay let is active equals and then we're going to Define this value as a Boolean value then we're going to call the function check campaign status right so we get that return value and we Define that is active we going say if active is not true we're going to panic and return this message campaign is inactive long story short if the campaign is not active you can't make a deposit all right moving forward we

00:46:00.000 --> 00:46:59.999 align:start position:0%
have token client new all right so we're going to put the interface over the token address right so in this case we're using the sorond smart contract address and we're putting the interface over and we're going to call the transfer method so we're calling the trans on the xlm token address at least according to the test here and we're going to transfer that over to the we're going to transfer that from the contributor from the wallet making the call over to the current contract address so the staking contract and then we're going to transfer the amount specified in the Contra or in the call here next we're going to Mint the share token to the contributor so we have let share token equal get share token again remember in the initialized function we deployed a new token called share token and then we recorded the address of that

00:47:00.000 --> 00:47:59.999 align:start position:0%
share token to the smart contract storage so here in this call get share token we're able to retrieve the address of the share token we're creating a new client or interface to lay over the share token right we're saying token. mint right so we're telling the share token to Mint an amount of share token tokens to the contributor and then here we set the contribution right so there's a command in here or a function in the smart contract called set contribution that manages the value for the contributor value or manages the value for the contributor key according to the address so set contribution we're saying getting the address of the contributor and then setting the amount to that key all right and then similarly if we go to the withdrawal function it works exactly the

00:48:00.000 --> 00:48:59.999 align:start position:0%
same but in Reverse so we say Pub function withdraw contributor address recipient and token so you see contributor require off again super cool here that you can just use the require author the authorization framework right in the smart contract right from the smart contract SDK to kind of have this Dynamic authorization framework for things like managing different calls from addresses so again you see contributor do require off meaning that only the wallet making the call can make this call can't be another address right you must pass in the address that you're using is active again we're doing a call to a function that exists within the smart contract that returns a true or false value so Boolean value if is active does not return true then the campaign or the withdrawal will be null right it will not go through so

00:49:00.000 --> 00:49:59.999 align:start position:0%
again the campaign must be active to make a withdrawal we should probably change change that all right cool so we're getting a couple values here so let contribution equal equals self get user contribution this is going to return a an amount we'll go ahead and dive into how that comes into play a little bit later again token client new laying that interface over the token address so in this so so this time it's going to be xlm at least according to the test and then we're going to say from this current contract address from the staking address we're going to transfer xlm over to the recipient and the amount will be the contribution amount that is defined here and get user contribution next we're going to go ahead and keep moving forward let share token equals get share token so we're returning an an address value here and again laying that interface over the

00:50:00.000 --> 00:50:59.999 align:start position:0%
share token address and calling the burn method the contributor is going to be the the I guess wallet is going to Target and the amount that it's going to burn is the contribution amount so again total contribution being defined here and then you see the burn happening here so the address of the contributor burning their entire contribution and last but not least you see set contribution we're going to take in the contributor value or the contributor address and set the value of that key contributions to Z all right so that's a quick rundown and I'd like couple of cool things that happened during this time so again we have our data keys and smart contract storage right data key here a good place to keep all your keys all these Keys have values how do you manage these values well you use the set method right so that's the contract storage right so

00:51:00.000 --> 00:51:59.999 align:start position:0%
to set a value to a key you have to go n storage instance. set to get a value from a key you have to go and storage. instance. getet so there's some data types and contract sorts action happening there and then one cool thing that I'd like to point out is the cross contract calls so when you actually when we're looking at the deposit function one thing that we may have looked over is that we're actually making a cross contract call so you see token client new all this is is that we're using the token contract right we're using this token contract to access functions at another address outside of the staking contract so token client new laying the interface over the external address which is the token address and then

00:52:00.000 --> 00:52:59.999 align:start position:0%
we're calling the transfer function on that token address that is defined by this import here so that might be a lot for some but this is a cross contract call and it's made super easy by being able to use this contract import function whereby you can actually import wasum files so compiled Russ smart contract files and actually call the functions from these compiled Russ smart contract files on other contracts and it's all super Compact and very very I guess malleable for lack of a better term all right so let's go ahead and actually dive into some tests here I'll just go ahead and quickly go into the staking directory we'll go ahead and run cargo test all right there wasn't very much action here but we have one huge test for everything

00:53:00.000 --> 00:53:59.999 align:start position:0%
that kind of goes over all of the things that we just went over let's go ahead and just kind of like dive in here you see the test contribute we're letting the end be defined as like a simulated environment or the end here is just going to be like a default environment being simulated here we're saying all authorizations have been accepted so users are able to call different functions when it comes to when it comes to the authorization framework that we have used here it's going to make it easier for us to kind of get around any blocks that may occur all right so we're generating a couple of new addresses some some mock addresses if you will by using the generate method so address generate we're using two so one for admin one for user we're creating a token contract so token 1 equals create token contract right so

00:54:00.000 --> 00:54:59.999 align:start position:0%
create token contract we're going to we won't dive into the ins and outs of this just yet but essentially it's going to create like a mock token and we're going to be able to use the functions from the token file or this token. RS file on this token contract so you see we're taking in one argument which is it the which is the address the admin address and we're going to return a token client so we're going to say token client new we're going to register like a default kind of asset contract available from the SDK and we're going to set the admin as the the admin address all right so let's go ahead and keep moving forward contract contract ID equals register contract we're going to pretty much just like upload the staking contract here using this this command client we're going to define a new client so a new interface for the staking contract at

00:55:00.000 --> 00:55:59.999 align:start position:0%
this contracted ID and again mind you this is all kind of just like setting up the the environment all right so you see here token one. mint this is some setup here that we're just minting the user kind of like prefunding their their wallet to interact with the contract assert that the token or the the token balance for the user is what we just minted so a th here you see initialize so client. initialize so when you see the word client it just means that you're interacting with the staking contract so client initialize this could be staking contract. initialize here you see the admin token token wasm that we're using and then the token one address so let's go ahead and dive into this token wasm file or this token wasm function so you see function install token WM is going to return a by value and what

00:56:00.000 --> 00:56:59.999 align:start position:0%
we're doing reporting the sorond token contract that we just kind of have pre-compiled here and we're going to upload that to the contained simulated blockchain that we're working in from the test environment but the main thing to focus on here is that we're using we're importing the token file and we're able to use different functions from this token file thanks to this installed token wasm function so again this returns a bytes 32 value and that's what we're going to use within the test all right so client. initialize we're passing in the admin we're passing in the token wasum value and then we're passing in the token address right we're we're calling the function start campaign so this is going to set the is active value to true and again we can't make deposits or withdrawals unless that is active value is true moving forward client. deposit so we're taking in a

00:57:00.000 --> 00:57:59.999 align:start position:0%
deposit from a user which token that they're depositing and the amount that they are depositing we're going to say assert that the user contribution of the user that just deposited matches the total deposit that they made and we're going to assert that the to total share token balance of that user matches the deposit of matches the initial deposit that's all should have right now and then we're going to go ahead and test the withdrawal function U making sure that the user after they make the withdrawal has zero contributions left within the contract so again just as an example when we run that test everything is okay and all of this logic passes the way it should all right so that's about it for me again if you want to check out the defi contracts portion or if you want to check out the I'll go ahead and like go

00:58:00.000 --> 00:58:59.999 align:start position:0%
through the links again one more time so we have the okashi link here if you want to check out the set title smart contract in an online IDE kind of environment you know that contract should be built out you should be able to just quickly hit compile start testing out all of the functions that live there again this setup slide this QR code here is going to take you to the setup part of the getting started section of the docs you're just going to run three simple commands to get started with the Stellar CLI if you want to check out some more advanced smart contracts that we just went through including more advanced what's it called data storage cross contract calls as well as some more various examples of Getters and Setters you can go ahead and check out this QR code here which will take you to the consensus hackathon and you should see a couple of directories namely staking and data

00:59:00.000 --> 00:59:59.999 align:start position:0%
types all right so in conclusion I always tell developers to read the docs as you can never go wrong with that feel free to scan this QR code here and it will take you right to the stellar.org stellar.org developers landing page where you'll see all the good developer docs that you will need and last but not least once again my name is Julian Martinez senior developer advocate here at SDF it's been an absolute pleasure I love talking about this stuff you know really love having developer workshops and tutorials happy to do them anytime and I really hope that you guys all learned something today if you have any questions then please please please do hop in the developer Discord or the Stellar Discord in the should be sorbon ddev or or Dev dhel any one of those channels in general just join the Discord and you can also ping me at the God

01:00:00.000 --> 01:00:59.999 align:start position:0%
handore again that's atthe godhand and then an underscore sign if you have any questions but yeah thanks again so much for your time and I hope to see you all soon take care
