WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
hey everyone I think we can get started so this is the storybond design discussion in which we discuss protocol changes related to soroban our topic today is State expression we're going to keep talking about rent and temporary storage Ledger entries so Garen can you take it away yeah so I think at the talent of the last week's meeting we were discussing about what happens when entries are delayed with outstanding run balance and we decided that it was probably not a good idea to refund the outstanding balance and instead just have the balance be burned the reason for this is that if you allow rent balance refund then you open up a lot of kind of a malicious attack vectors for instance because entries automatically have a run bump whenever they're touched you can have a smart contract that has every

00:01:00.000 --> 00:01:59.999 align:start position:0%
invocation of a function Touch One admin entry for instance and then this adminant tree especially for a popular contract could have lots of rent balance because it's touched another function call and then you could have an admin of this contract who maliciously deletes and recreates that entry periodically in order to essentially steal this rent balance from the collars of the function and also this would be difficult for users to be able to detect or even see if the stack Vector exists because for something like an admin entry it would seem like a normal operation for and not another contract to either create or modify that entry and so it'd be difficult to detect these sorts of attacks attacks also refunding my balance doesn't really make sense because many different users May pay for the rent balance only a single user benefits from the refund and so for these reasons it seems that the best policy for whenever an entry is

00:02:00.000 --> 00:02:59.999 align:start position:0%
delayed without standing rent balance is just for this rent balance to be burned now even though we're burning on this outstanding Grant Balance we still want there to be an incentive to delete entries before they're archived because even though we have the state expiration to reduce the size of The Ledger when an effort a restorable entry or like that's what we're calling Now entries that are eligible for archival so in non-temporary entry but whenever these entries run out for end even though they're delayed from The Ledger they still have to be stored perpetually in the archive and so if you have an entry that's no longer going to be used it's significantly more advantageous for this entry to be deleted instead of being sent to the archive because even though the archive is kind of like our deep storage and it's much slower and we have much more we're learning there for large amounts of state it would still be better just to have not have useless entries or entries that will never be used again taking space in The Ledger or

00:03:00.000 --> 00:03:59.999 align:start position:0%
the eye archive and so since we can't incentivize this Behavior via a rent bounce refund we're thinking instead of adding a base fee called the archival fee and essentially what this would be is just some flat fee probably tied to the size of Ledger entry that you have to pay in order to create the entry initially and then if you delete the entry before it gets archived you receive this as a refund and so this allows you to have someone set up for deletion and then if you don't delete an entry and gets into the archive then this archival fee is burned and so the thinking being that this gives users incessive to delete entries before it gets into the archive but because it is a fixed rate and is not something that can grow to large amounts like red balance it can't be gained nearly as much and one of the drawbacks is that this does make you know the answers more expensive and this also increases the size of the entry because we'll have to

00:04:00.000 --> 00:04:59.999 align:start position:0%
store the archival feed as a parameter so it increases the size of all entries by about four bytes but I think this provides a good incentive and can help us maintain the hygiene of the archive and so I guess General thoughts on both the issue about burning rent balance that's outstanding and also on this new archival basically foreign so I think yeah I think on the red balance getting burnt I think we're pretty much in agreement unless someone else has a different opinion there there I am very much concerned about introducing yet another type of V for for the purpose of motivating people to delete their their entries especially because we already have temporary storage which hopefully should take care of of like most of these cases like what is can you give us

00:05:00.000 --> 00:05:59.999 align:start position:0%
a use case for like when a non-temporary non-temporary entry might get deleted and how often do these happen yeah so just have to depend on usage patterns patterns and so one thing with the temporary entries is that their lifetime is fixed to a set amount or to a very limited time frame and so this is built for security reasons but also just for fee based reasons as well that temporary entries will have a maximum life something probably on the magnitude of like months so like three months or six months or something like that the exact value happened on the side yet so I think that there's a use case for say you have something like a payment Channel Channel that doesn't need to be preserved these don't want it to last longer than the maximum life of the temporary entry would be and so I think for Android types like that that aren't super important from the security standpoint but have a variable length

00:06:00.000 --> 00:06:59.999 align:start position:0%
time or a variable length lifetime then there might be some advantageous here for deletion I think the second issue too is if we have this archival fee it provides more incentive to use temporary entries as well because right now the savings you get from a temporary entry are relatively minimal because there's still essentially how we calculate the temporary entry fee is that say if your temporary entry lasts 128 ledgers what you do is that we take a snapshot of the current rent fee multiply that by 128 and that's how much temporary entry costs and so today a temporary entry and a restorable entry are very similar in price and so I could see Network incentives being well like well they're essentially the same so just be on the safe side I'll use a restorable entry when a temporary entry really could do so that's the second advantage to having a space feed is that by adding this fee to the restorable entry types and not adding this fee to the

00:07:00.000 --> 00:07:59.999 align:start position:0%
temporary entry types you also widen the gap between the cost of a temporary entry and a costly restorable entry to further incentivize more use of these temporary entries and lessen the restorable entry type have you considered any other options for widening the the gap between temporary entries and restorable entries that doesn't include an archography archography oh so there's like a there's an implicit savings because the rent fee snapshot and because rent fees tied to the bucket list size generally speaking at least for the access patterns you're seeing on starting classic now this might you know vary because we haven't seen soap on traffic yet in the real world but the bucket list grows relatively linearly and so because temporary entries are locking into the fee and we expect the bikeless size and therefore the print fees to increase linearly you are getting a cheaper rate because

00:08:00.000 --> 00:08:59.999 align:start position:0%
you're able to snapshot that being said especially for short-lived entries the settings are pretty minimal because the rent fee doesn't grow at a very fast rate and so I think they're I'm trying to think if there are any other implicit fee signs at the moment but I think if we want to incentivize temporary storage from a feed perspective we will have to add some additional costs to the restorable entry camera points counterparts now whether that be a refundable fee or other fee that's refunded on deletion or just a fee of creation that's immediately burned I think either of those could work but I think we do need to have some sort of price discrepancy in addition to the implicit discrepancy in the rent fee snapshot alternatively if we think that we don't need to incentivize these are temporary entries from a feed perspective and then just the utility they provide is good enough incentive on their own could also

00:09:00.000 --> 00:09:59.999 align:start position:0%
go back route but that could cause more archivable and restorable entry types than we want floating around the network and make our archives larger than they really should be okay yeah the question is how much bigger will will they get because this idea of yeah like creating like this this you know middle you know basically what you're saying you're like is is that there's there's a whole category of like Ledger entries that are like between temporary and restorable that could theoretically like not be archived and we're going to introduce another fee mechanism specifically for them and and but and we already have a fairly you

00:10:00.000 --> 00:10:59.999 align:start position:0%
know across the board we have a non-trivial like fee you know various fee mechanisms so introducing another one is something that I'm I'm not entirely comfortable with it yeah yeah yes any other potential saving is just that the temporary entries never require proofs for creation whereas some types of restore boundaries require briefs which is another difference that could be useful so for instance in the using storage type requires a proof of non-existence to create or temporary entries never require proof that being said the recreational storage type does not require such groups I think temporary entries are a powerful primitive on their own and so I'm not sure how much we need to incentivize their use from a fee perspective perspective so I'm just curious as to people who know like the the smart contract

00:11:00.000 --> 00:11:59.999 align:start position:0%
ecosystem better than me are like the temporary entry is strong enough on their own and do we not need this additional archival incentive foreign yeah so I think the you know the main use case we're we're seeing for for temporary storage is oracles we've talked with some of like the major Oracle providers who would love to see this this and so I I don't think even if there's you know if even if there's like even if with not a lot more fees they can get archivable storage I don't think they'll be interested in doing this because again their data is really short-lived is relevant for a short-lived time the other thing is that if like actually if if we add this archive or fee people

00:12:00.000 --> 00:12:59.999 align:start position:0%
will actually need to reclaim it right so that's like we're basically adding an operational burden on these entities to actually reclaim their fees through but I mean I I'm but this is sort of place temporary entries right so with the Oracle use case still want you know temporary interest of course this doesn't replace that I guess the the question is is there a good or is deleting a restorable entry happen often enough to to have the complexity of an extra fee and to add the additional four byte archival fee value right now I'm hearing no but that's probably not a use case that will happen very often and I kind of like appropriate and thinking about yeah I guess my my opinion

00:13:00.000 --> 00:13:59.999 align:start position:0%
understand is is clear is there anyone else with thoughts in the matter what is the cost of letting this go to archives like getting like a having a archival entry like go to the archives and stuff instead of again deleted also just the the thing about the archive is that it never shrinks so if an entry gets archived then you have to store that in the archive versus if the entry gets deleted then you don't have to store it in addition even once an entry is restored from the archive we still have to keep essentially a stub of its existence in the archive so what happens is that whenever an entry is restored it's Leaf node that uses from The Ledger entry as nulled out but the path to the node still needs to be maintained for all eternity and so I think just given that the archive is pretty much append only it is designed such that you know this is like a slow data structure

00:14:00.000 --> 00:14:59.999 align:start position:0%
that's meant to be you know like the the archive nodes are essentially just like you know SSD base and they're meant for storing large amounts of data and so it's not nearly as sensitive as the ledger size but it is something that we should probably keep in mind as that if we send something to the archive at least some of that data even if it's restored later will have to live forever which is why if there's an entry that user will never use I would much rather that interview deleted than having to store it perpetually in an archive even though archives are kind of meant to store things perpetually based off of what you said like I would expect temporary like I think you mentioned that the fee difference between temporary storage and non-temporary storage it like is like negligible but I would expect it to be someone significant just based off what you said oh what do you mean like I mean like it would make sense if we made temporary storage cheaper to incent to not incentivize what you're describing worry just like using

00:15:00.000 --> 00:15:59.999 align:start position:0%
recreatable storage well that's actually another thing we could do is instead of adding an additional fee to archival storage what we could say is right now temporary storage is just the feed calculation it's just a number of letters to live times current rent fee what we could do is just say like numbers of ledgers to the times current rent fee times like 0.8 or some like temp fee you know multiplier such that the temporary entries are still based on the current size of the bucket list and so they can still increase or decrease in price as the Ledger state grows or shrinks but they're strictly cheaper than archive entries by a significant margin and that also kind of simplifies the fee story because we're not adding an additional fee type because we already have separate fees for temporary entries and so this would just make them always smaller that would actually probably be a much simpler better idea than I think having this refundable archival fee

00:16:00.000 --> 00:16:59.999 align:start position:0%
thing thing yeah I guess this doesn't incentivize the actual deletion of those entries but I think you've seen less of them yeah I think if temporary entries are significantly cheaper or at least substantially cheaper then we didn't don't really need to incentivize deletion because if you're thinking about like what what the use case for restorable restorable entries are especially for like the recreatable type is pretty much just balances and I mean the I think the amount of balance deletions is probably pretty small and so I don't think it's probably a huge case of special case for it yeah I completely agree I think if we figure out a way to Discount the we figure out a way to Discount the temporary temporary entries the way that you described that will go a long way towards making people use them and in terms of you know the previous point on saving space for archivers I I hear you the question there is like

00:17:00.000 --> 00:17:59.999 align:start position:0%
you know like how much like makes it worth it like if we saved them you know ten percent of space like does does that worth is that worth the added complexity like obviously if we can if we can save archivers you know an order of magnitude's base or a goose in order of magnitude the the amount of space required then that is like a huge win but I don't think we'll get there I think there's like a pretty narrow use case for these deletable restorable entries so definitely my vote is for like the discount approach for temporary storage yeah I think I blame the discount approach too I think also just like on the our order of priorities we should prioritize kitten won't let your small and not prioritize keeping the archive small that much especially if it's like I think like a 10 decrease wouldn't be that big of a deal so I think I'm also leaning towards the the discount temporary entries approach as well are there any last thoughts before I

00:18:00.000 --> 00:18:59.999 align:start position:0%
move on I guess the conclusion was discount temporary entries and have no refunds for archival storage I'm thinking of is that if we go that route right where we we basically say hey the archives are kind of a dunking ground of like like all abundant major entries I think what we have to maybe like take into account is I think it's probably okay like I mean imagine that those nodes that are going to be used as a to to back up those high value Legend trees yeah the problem will end up doing some level of filtering like they only for example people on the keep our own Villages for things that look like balances for example or that are related to balances

00:19:00.000 --> 00:19:59.999 align:start position:0%
as opposed to like random stuff but I think even in that situation I think they have to keep the full training around right or hashes yeah so when how often does do we reset the tree is it like on a pair restart the the tree it's currently your epochs it's every year so then the Assumption will be that you know in a year we don't have too much of this craft accumulating accumulating which might be okay I mean that's kind of like the yeah like the I think for yeah for for those entries

00:20:00.000 --> 00:20:59.999 align:start position:0%
that are not like you know you were talking about it as a discount to get to the for the pricing of of of like you know attempts I think it's the other way around it's more like you you add actually so there's probably like a constant term and then a additional you know rate on top of the the price to to get to the restorable entry fee like the very first time you created and I think there's probably a constant Factor   I did want to bring Ian from from the crowd to speak because he has some interesting perspective and is very passionate about it sorry I was so passionate I've I've written papers on this topic for other blockchains as a paid service

00:21:00.000 --> 00:21:59.999 align:start position:0%
so I've done a wide breadth of study as well as deep diving into different trade-offs that were done and this influenced their design decisions but they're slow to move and slow to change change so there's a couple different concepts here the first one I want to cover is dust and that's the idea that the value of a record maybe less than the cost of maintaining it and those records should probably be cleaned up automatically but it's a problem on ethereum because you can never quite spend out a whole wallet you always have a little bit left over and so that little bit left over is referred to as just but that's only one example of dust there's many of them the second kind of approach here is that there's a huge ecosystem that's growing around smart contracts and each of those ecosystem players has different data needs and

00:22:00.000 --> 00:22:59.999 align:start position:0%
there's no one solution that fits everybody everybody and even you know other monolithic chains are are dealing with storage problems and then any modular chain has an extreme storage problem and the storage problem needs to be addressed in a way that you don't have nodes needing to install like four different protocols four different systems in order to access the data that's being referenced sometimes it might be 10 or 15 different storage protocols in order just to access what was in a hash what was in a roll-up what was intended by the data that was submitted to the blockchain blockchain for one second in in the context of the current state expiration proposal by Garand like what are you trying to say hmm hmm so you need to have different tiers of pricing a rent model is insufficient and

00:23:00.000 --> 00:23:59.999 align:start position:0%
and so is a couple other you know like sort of well we see this problem now what are we going to do there's not one solution that fits it it's really important to give a lot of flexibility to the people that are deploying on the network and give them as many options with pricing up front and they will simply do whatever is most efficient in order to save money up front if you try to to add an incentive like later on there's a few problems one is that your adoption is going to be very low and the second is that you're going to you're not going to have what they're necessarily looking for if they can just pay again to extend the lifetime of that storage then that's that's the best of both worlds worlds ideally there'll be an external storage for large amounts of data for example blob data should be not stored necessarily on

00:24:00.000 --> 00:24:59.999 align:start position:0%
chain but on a separate layer and you can incentivize the creation of those systems by limiting the amount of on-chain storage but allowing pointers to exist so your your best long-term solution when people start doing crazy things with blockchain which they're starting to but they're struggling to because the storage costs are so high is that you're going to start seeing a lot of you know flexibility wins the day and so if you have pricing tiers automatic expiration expiration optional renewal and you're charging by the byte by the day or in some cases by the minute then you're able to meet most of those use cases there are go ahead please I believe this is what we're pretty much doing I could be mistaken but if I'm understanding your proposal correlates that you have different tiers that automatically expire but the option to

00:25:00.000 --> 00:25:59.999 align:start position:0%
renew I believe that's what we're doing with the temporary entries the temporary entries being automatically deleting and being the cheapest whereas the restorable entry types must be periodically renewed so to speak I it is are you proposing something that's different than this well I heard different proposals and I think that I embrace what you're saying in terms of tier proposals I would just suggest number one that there's a a large number of tears at least four and number two some of the data will be archived with no ability to recall or if you excluded from archive with no ability recall some can be removed and not archived but pay an oracle to recall it and some can be you know permanently archived now I'm confused by you say remove you can pay an article two

00:26:00.000 --> 00:26:59.999 align:start position:0%
call it what do you mean by that I believe that's how our accountable system is essentially R5 the archive is off chain and then you pay to restore something from the archive so link to our archive proposal proposal is essentially the Oracle system you're talking about so if it's an optional flag they can pay for it if they think they need it but your archive is still smaller the reason that you might want to do that is that some people specialize in storage and they want to earn a fee for specializing in storage and by specializing I mean over 20 terabytes probably around you know a petabyte or so okay so I think Ian if you can maybe refer back well we can drop a link here to the actual proposal and we'd love to hear feedback about specifically I think that the type of

00:27:00.000 --> 00:27:59.999 align:start position:0%
issues that you are or the type of solutions you're talking about are actually embedded there but we'd love to hear if you think that's not the case we're talking to details now but I believe the archival system is pretty similar to what you propose actually but you can definitely add some comments in the docs so I guess are you ready to move on to Temporary entry issues okay okay so I guess and the second thing and this is somewhat relevant to the previous conversation is temporary entries so our current interface and I guess we've concluded that the temporary entries are substantially cheaper than the restorable entry types if I have some multiply or something like that if we have the temporary entries currently the interface is you define a key to find Value and Define a TTL

00:28:00.000 --> 00:28:59.999 align:start position:0%
measured in ledgers such that our time to live such that the entry is guaranteed to be deleted on the exact Ledger that you specify now systematically under the hood the entry is not actually removed on that ledger it persists in the bucket list for that sometime but it is inaccessible now one of the open questions we have is whether or not we should allow users to increase the TTL arbitrarily and in the current proposal we do not allow this there are two reasons there's a security reason and a gamification reason so first for the security reason we suspect that there is a strong use case case for temporary entries when it comes to things like allowances or kyc where if you specify an allowance that should only last 10 ledgers mentioned the last exactly 10 ledgers and by allowing contracts to Define behavior that increases TTL you can have

00:29:00.000 --> 00:29:59.999 align:start position:0%
foot guns where a buggy implementation might have some security a temporary authorization that should only last a short amount of time but by allowing life extension Primitives you are potentially allowing bugs for security purposes that's issue number one issue number two is out of gamification and so the whole issue with temporary entries is that we want them to be cheaper but we don't want them to be a way to game the rent system and what I mean by that is if continually extending the TTL of a temporary entry is cheaper than just paying rent that kind of excuse Network Dynamics Dynamics now I'm not exactly sure actually this is something we should avoid because temporary entries are self-deletion deleting so maybe we should allow users to just continually extend the life and essentially have cheaper rent than if

00:30:00.000 --> 00:30:59.999 align:start position:0%
they would create a restorable entry and just pay rent balances on those ledgers so perhaps this is something we want to allow but at least for now it seems that that's a a somewhat unfair usage for the temporary entries and we wouldn't want temporary entries to be used and to be able to continually extend their TTL such that they can drastically or pay significantly reduce the amount of rent and so their print system we do not allow modification of the TTL now there is an implicit way to extend the life of an entry what you can always do is load the entry delete it and then recreate the entry with the exact same value that's still allowed and so you can essentially buy this delete rewrite pattern specialized special case and extend the entry with the same key value if you really want to but we provide no way to essentially keep the same entry books in the TTL and so I'm wondering if there are any additional thoughts on this should we allow arbitrary detail extension should we not this is a slight side point maybe and

00:31:00.000 --> 00:31:59.999 align:start position:0%
kind of a question it seems like the difference between restorable entries and tempor entries is temporary entries you have to well this is your question I guess is should we allow rent bumps or do you is it prepay only for temporary entries but it seems like the only real difference is restorable ones go to the archive and temporary ones do not go to the archive is that roughly true or not quite yeah correct there's a couple of other differences like so right now like temporary entries are prepaid up front and so you get a better rate because you're paying essentially like for months like you're paying for a large amount of ledgers instead of one-offs one-offs I guess I'm saying could we just have one type of thing that there's basically two different things there's how much Renta has which is how long it stays on chain chain and then whether or not you've paid for it to go to the archive after that point or not right and if you pay more rent up front for either of them you get a discount discount and then this whole cheaper way to use it goes away so I think we shouldn't Define a

00:32:00.000 --> 00:32:59.999 align:start position:0%
difference and that's because the the primary difference and I should have mentioned this is that temporary entries I have strict lifetimes whereas Right Now restorable entries do not have strict lifetimes and so just the way that the buck list Works we have a variable per larger red fee and because it's you know variable we don't know what the Run fee of a given Ledger will be until that ledger occurs which means in order for the database to be up to date on the live rent values of every entry we have to iterate through the entire Ledger and decrement the rent balance of every single entry which is impossible from an efficiency standpoint and so because of this we charge really much retroactively which means that for restorable entries they live and are accessible longer than they should be the exact number is that we have about like on the lowest level bucket we have right now about 30 days of quote-unquote free rent where a restorable entry has out of rent but

00:33:00.000 --> 00:33:59.999 align:start position:0%
it's still accessible in live temporary entries have very definite time timelines whereas they only exist for 128 ledgers no more no less and I think for that's a powerful permit for security purposes which is one of the reasons we want to distinguish between the two yeah okay but were you just asking about we should do allow rent bumps for temporary entries entries well so not necessarily around bumps but but TTL extension and so in the current proposal of the rent system applies to restorable entries whereas they have a rent balance which is some about xlm which is deducted form and so their amount of legislative is not exact the the Quan quote web bump for temporary entries isn't increasing the rent balance because temporary entries do not have a rent balance rather it's increasing the TTL and so even if you allow changing of ttls you are it's not so much a rent bump because you still have a very definitive timeline and very definitive depth

00:34:00.000 --> 00:34:59.999 align:start position:0%
Ledger if you will so I'll defer to you on that thank you my bias is not to allow extending the TTL hey it's just another piece of functionality that people need to wrap their head around but also it doesn't sit that well with how like my mental model of what a temporary Ledger entry is so when I think about a temporary Ledger entry I think about a piece of information that I'm like broadcasting to the world for the next end ledgers and that's it so if if I update that like what what does that actually mean like what is the actual use case for updating these temporary Ledger entries

00:35:00.000 --> 00:35:59.999 align:start position:0%
yeah I personally don't know what the use cases I think one possible advantage of updating the entries is if you have a some a type that is trivially recreatable so you don't care if it gets deleted but you also want it to exist someone perpetually I can imagine a efficient solution where if the TTL is below like say 100 ledgers or something then use extended arbitrarily and if for whatever reason you miss a TTL bump and it does get deleted these arbitrarily recreated and so in this case you want to use an archivable type because it's triviably recreatable and so it wouldn't be worth restoring restoring but also you want to use it perpetually and so you would you wouldn't want a strip TTL now again

00:36:00.000 --> 00:36:59.999 align:start position:0%
you know we could also do is just like do a temporary entry set to the maximum TTL and then if it doesn't exist just recreate it and then again set to the max dtl that's also possible for arbitrarily recreable data but that's just a use case I could think of the top of my head I don't know if anyone else has has perhaps more interesting or is more knowledgeable in the smart contract space wants to share their thoughts well I guess maybe like the with the CTL thing like why are we trying to babysit so much like the you know like the the contract like like it feels like you know not allowing access of an entry right past its TTL that's like like and not allowing bumps you know for that reason sounds like we are stepping over the boundary in terms of responsibility like the contract you know if the contract doesn't want something to be valid Beyond a

00:37:00.000 --> 00:37:59.999 align:start position:0%
certain time like that should be implemented in the contract itself I think think and and if we do something like that I think then the the bumping that we're talking about I think we just have to make sure that when an entry gets bumped the number you know the the the actual expiration time will match the the lifetime in the in in the in the bucket list right like so so like if you're so at creation time that means we have to have like a a function that allows you to to compute the   like if you want to go from a number of ledgers or a number or actually number of ledgers you can do that of chain but like or actually time is the same thing thing yeah like I guess bumping like where it gets a little bit complicated is yeah

00:38:00.000 --> 00:38:59.999 align:start position:0%
just you have like some number and then you try to say okay extend it by at least 30 days because you won't be able to to actually do exactly 30 days if we don't make that strict TGI and you don't want people to pay to get free runs right for for whatever is the you know it takes too much that that for to actually expire that entry but that seems walkable I mean those are like help of functions right like that we can expose to the that are basically like allow you to kind of Reason about about the bucket list list well I guess the the interface would be a little weird though because essentially what you could do is the CTL you could make temporary entries but it would have to be a power of four ledgers so like four zero fourth one Etc but with a maximum lifetime being 30 days

00:39:00.000 --> 00:39:59.999 align:start position:0%
days and that just seems it just seems like a weird and not super user-friendly interface to to not have a a stripped thousand on a TTL because at least like I'm thinking of like use case it just seems from a contract developer perspective you know they don't have knowledge of the bucket list and so it just seems weird that you have this temporary entry that can only expire on Powers of four for some reason with poor granularity and I think it's it's weird from a security standpoint if you want something to only live 128 that you have this entrance type called temporary entries that is self-deleting but you on top of the self delaying temporary entry have to still in addition to that Implement your own TTL if for your use case it doesn't work to be on the exact boundary power of four it just seems that like we're exposing too much of the underbelly of the system between the developers in that case

00:40:00.000 --> 00:40:59.999 align:start position:0%
so just to be on just to be clear if I use a non-power of what is it power for for remember it will still live until like past my TTL until the the next Power four yeah so the way that just because of the nature of the bucket list apocalypse DB we can only remove entries from the data structure on power of four ledgers and so in the current implementation we have the TTL which is stored as a field inside the entry and so the entry itself does live on The Bucket List beyond the TTL in most cases unless it happens to be a power four but we just like do a check whenever you're trying to access that entry and if the TTL Ledger has passed we just return nulls if it doesn't exist even though it does exist on The Ledger and then we garbage collect on Powers of four four okay that that makes a lot of sense

00:41:00.000 --> 00:41:59.999 align:start position:0%
so so so I'm a bit confused as to what Nico just said like what the what's the confusing bit here also I think Nico is suggesting not to have the TTL field as part of protocol and to if users want a strip TTL they must Implement that themselves and essentially they're struck that they store must have the TCL value and instead just expose an interface where temporary entries live and are accessible as long as they're accessible on the bucket list and so when you specify a TTL you must specify a power for TTL Nico my understanding that correctly yeah basically it's kind of like I mean you still have a TTL it's more like it's actually it's it's more it's represents the we were in a special case the like right now right like if you have a if you load an entry that is in the bucket list but that has an expired TTL TTL you consider that it's not there and

00:42:00.000 --> 00:42:59.999 align:start position:0%
that we will get rid of that special casing by doing that and and just requiring requiring that the the TTL that you have is is is actually going to expire on the on a bucket boundary yeah like yeah I I agree with with Garen I think this is the potential like we like there's only so much we can expect from developers to understand the bucket list here and I think the the basic expectation from a temporary storage is is you know saying you know telling the platform this is how many ledgers I want this thing to live for and and putting restrictions on that or repeat or you know telling people you can only use powers before and if you want to do it like an exact detail then you need to write your own smart contract I think that's not the ideal product experience yeah I think yes the reason I mentioned that was to allow for bumping that here because if you have actually

00:43:00.000 --> 00:43:59.999 align:start position:0%
if you're a number if you want to allow bumping you have to take into account what is actually happening under the covers covers I I don't know if it's too complex but I kind of I kind of think we're solving two different problems here I think there is the case of a temporary entry or that has a certain deadline and dies and then such as like kyc or like a an allowance you want to exist for 10 letters and 10 letters exactly that's case one and there's a second case of you have the century you don't really care how long to live as long as it lives around this time and then you might want to bump it on every access I feel like those are two different classes of storage and I think a temporary entry with a exact TL sells one issue and so I'm wondering if it might be reasonable to have like a flag say on on the recreatable storage to say archive or not archive

00:44:00.000 --> 00:44:59.999 align:start position:0%
because I feel like that's a different use case than what at least in one on the temporary entry with the exact details getting at but again that might be too complicated having now like three or four different storage types you know or yeah I would rather not add anything else here I think that the the the first case that you described the one that you know a contract wants to you know put a ledger entry for exactly n ledgers I think that's the common case and that's the thing that we should that we should cater for if they want to have more you know sophisticated situations in which you know they can recreate or or or bump this entry once in a while then you know they can write a smart contract that that achieves that functionality that can be updated at specific times

00:45:00.000 --> 00:45:59.999 align:start position:0%
but I think we need to keep the you know keep the the main contract to something that's you know like the common use case yeah I think if if you want essentially like Implement that behavior it's still possible or just like if like the the ttls within X number of Legends just deleted and recreate the same value with a maximum TTL that's very possible and especially if we have a discount temporary entrance the deletion Recreation path might be at cost or cheaper than a restorable entry so I think that seems like a reasonable approach approach I think I'd rather not expose spotless powers for to any post-function or SDK okay it seems fine to not expose it then but at the same time like if we focus more on the actual what is that TTL is it a

00:46:00.000 --> 00:46:59.999 align:start position:0%
you know do we want that to be a a more of a leave at least for you know a given time and that way you can allow you know anybody to bump that ledger entry or do you want to have that be more like that strict thing like that you mentioned and because this strict definition of teachers seems super I don't know a bit too special I don't know like it doesn't seem like it's it's implicit it's it's it's not it's unlike other types of storage that we have but but I disagree here like I think the the con the interface that people are looking for is I want this to live for this amount of time and The Ledger number here is just a good approximation for for time like this idea of I want to live this I wanted this thing to live for at least this amount of time and the

00:47:00.000 --> 00:47:59.999 align:start position:0%
actual length of how much it lives depends on like the underlying implementation it's not that's not the case anymore because what we said you know the discussion we had right before was hey let's let's move the use cases where people don't want archival through those temporary entries the TTL is not about having this strict thing right going on it's about I don't want to parent I just want to be you know cheaper and if I have to refresh the thing and get it refreshed in some way and their contract in that case is not the one necessarily responsible for refreshing the the teachers or any anybody that cares basically in that context yeah I don't know in my mind it still feels like Tom was talking about issue a

00:48:00.000 --> 00:48:59.999 align:start position:0%
and then Nico's tackling SUV does this seemed like two infernally different use cases it's not what we're saying is that if people don't want this strict TTL they are pushed to use a cable you know like those things that end up in the archives and therefore I end up on some of the more expensive training but what exists in this space between a strict TTL and archivable Energies what what would like give me an example like what lives in that no this critical is is is another layer of like like like the strict ETL I mean I'm fine with this trick TTL it's more like the the what does it actually mean what do we mean by strategirl here like like it becomes a security feature I'm saying like if we get rid of the security feature basically allowing the

00:49:00.000 --> 00:49:59.999 align:start position:0%
teacher to be expanded then we have something actually that I to me seems to make sense because now we have like if you want to get into archive use the you know recruitable thing and it's kind of a you know you just use run for that or you use those temporary things that yeah if you want to refresh it's manual you have to do that and you get a little bit of a discount because yeah yeah they don't go to the archive by default and then if you want this trick like super constricting that you know never exactly a TTR that's exactly something and you cannot bump you have to implement that in your contract contract because yeah again like in terms of use cases what type of Entry when do you need something with a teacher that is kind of Frozen that you can never change well if you're in Oracle and you wanna

00:50:00.000 --> 00:50:59.999 align:start position:0%
and you have you know you publish like hourly price feeds and you want them to live exactly for an hour then you put a TTL of a number of blocks that constitute fairly like something that approximates an hour you mean like you don't want that thing to stay on Ledger or for longer yoga I mean as a record in that particular scenario scenario you're going to override that entry right well I think you're getting into the contract implementation you can see yeah I'm publishing some data and I don't want to pay for it you know after that time time it doesn't mean that you know it's not about I don't want to pay it's not just about I want to pay for it for an hour it's about this thing is relevant for an hour like I don't actually want this thing to be alive after an hour that's part of the the payload like this expiration is the contract puts that

00:51:00.000 --> 00:51:59.999 align:start position:0%
meaning like you're saying there are no use cases where you don't want like you don't want this this strict thing thing from the chat a lot of people seem to disagree with that notion so what we could do actually is is if I go for an extraction was just like round up to the the nearest power four or something like that and just like allow like users to say arbitrary ledgers and it may or may not last longer longer because because I think as a storage medium I'm starting to agree more with Nico such that I don't know if we need to specialize a security feature

00:52:00.000 --> 00:52:59.999 align:start position:0%
feature in a storage interface because I think perhaps we should make the storage interface more General I I don't know well what I'm saying is that I I I'm I think it makes sense to the usability aspect of of yeah when you say the teacher is like 10 legends right if you don't do anything after 10 measures that team is basically appears to be deleted even though it's still in the bucket list I think that's an implementation detail right and I think that's totally fine to have that at the same time I think it should be possible to bump that that that TTL if you want to go beyond energy and when you bump it I mean that means you have to pay for I mean it's not staying in the bucket list right it's not going to stay at the bottom it's basically kind of like a rewrite first of all we're going to implement it

00:53:00.000 --> 00:53:59.999 align:start position:0%
and then yeah in terms of security feature you wouldn't be able to rely strictly on that layer for security for the for guaranteeing that something is going to be to live exactly you know for for some time like if you want that you have to put that in as part of your your attach it to your data basically okay so Gary it sounds like we are at a bit of an impasse right now we probably need to kind of like regroup look at the pros and cons can you like summarize this this discussion and the pros and cons of the different approaches that we've discussed and potentially drop that on sir bondev later today and hopefully we can asynchronously regroup and think about this

00:54:00.000 --> 00:54:59.999 align:start position:0%
am I still on Gary can you hear me I mean I can hear you I don't know if Karen can thanks Paul maybe Garen is having some troubles connecting and he's typing something no we cannot hear Garand regardless we are almost at time right now so I think this is a a good stopping point to regroup and and think about these things moving forward Garen will hopefully share this on Sarah Von Dev and we can continue the discussion there we can also people can feel free to stick around and live chat and continue talking thank you all for joining and see you all

00:55:00.000 --> 00:55:59.999 align:start position:0%
next week
