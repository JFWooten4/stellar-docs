WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
right now hello everyone and welcome to another Stellar open protocol discussion as per usual in these meetings we discuss potential changes to the Stellar protocol that take the form of core advancement proposals or caps these are technical specs they suggest changes to the Stellar protocol that allow the Stellar protocol to add new features and evolve to meet the needs of the ecosystem we're live streaming them so that anyone who's out there can follow along but again i do want to point out it's again I do want to point out it's technical so if you are watching this you should probably look at cap 21 in order to understand what we're talking about that is what we're going to be talking about today cap21 and you should also join the Stellar dev mailing list where offline discussions about these changes take place

00:01:00.000 --> 00:01:59.999 align:start position:0%
about these changes take place also there it we do keep an eye on the also there it we do keep an eye on the discussion box so if you put comments or questions in there they do help inform our decisions going forward we may not actually address them in this meeting although if they're super germaine i may bring them up germaine I may bring them up today we are focusing specifically as i said on cap 21. cap 21 basically is a cap that lays the groundwork for building payment channels on Stellar so what we're talking about today sounds a little obscure keep that in mind payment channels are things that allow multiple parties to securely transact off chain and periodically settle on chain and among other things that make it easier to build high volume use cases on Stellar so changes to cap 21 are proposed by cat 21 they allow for payment channels last time we also discussed cap 40 and basically got it to a point where it was basically got it to a point where it was near ready to be accepted but cat 40 is near ready to be accepted but cat 40 is contingent on cap 21 and so here's where we are with cat 21 there are a few we are with cat 21 there are a few outstanding issues and questions that we're going to try to walk through today i think that we are actually quite I think that we are actually quite close to getting this accepted although

00:02:00.000 --> 00:02:59.999 align:start position:0%
close to getting this accepted although we'll see what the outcome of today's conversation is so with that in mind let's just kick it off cap 21 is what we were talking about today and i believe that I believe that you know the question is i think that there are a couple of I think that there are a couple of questions that came up on the mailing list and there was a question about transactions failing during execution that came up during the last meeting but to start with i think we should sort of to start with I think we should sort of try to deal with the outstanding questions that are on the mailing list and nico if you can just share the first and nico if you can just share the first of those questions with us so that we can start to discuss it I was looking yeah I didn't have those questions open hold on sorry so yeah i guess like the first question was yeah I guess like the first question was more of a minor

00:03:00.000 --> 00:03:59.999 align:start position:0%
of a minor thing that i minor thing that I that i didn't we didn't discuss but that maybe is something we should be at least putting as like a potential thing that is should that behavior that we have for tracking the modified time basically for the sequence number this be an opt-in right now it's kind of making this blanket change right like as soon as protocol whatever as soon as cap basically becomes active we are going to kind of yeah make like track this new less modified basically in each account i mean it basically in each account I mean it seems like from an implementation i mean the reason from an implementation I mean the reason i mentioned that as a flag right instead I mentioned that as a flag right instead of being a like a

00:04:00.000 --> 00:04:59.999 align:start position:0%
like a protocol base right like in terms of the code it's actually the same thing like you have to in the code to deal with you have to in the code to deal with all protocol version new protocol version so instead of checking against protocol version we could check against the flag the difference is that it would make it that the tests for sure are going to be much simpler because now we can actually just test that part like in a solution fairly easily whereas i know that lee fairly easily whereas I know that lee in the past raised the issue and i think in the past raised the issue and I think that's true that we would have to rework a bunch of tests given the way they are written today in core at least i don't know in outside in core at least I don't know in outside i mean it seems like a pretty big foot I mean it seems like a pretty big foot gun to have this flag right because now this is something that's going to like something that's going to like catastrophically break all kinds of you know smart contracts and stuff if like this flag ever gets cleared or if like people don't realize that it's not set so it would be there would have to be like it would be there would have to be like a huge advantage

00:05:00.000 --> 00:05:59.999 align:start position:0%
a huge advantage to having these like two kinds of accounts one that just blanket failed preconditions and ones that actually implement the preconditions no it would not so the preconditions would not fail it's the last modified the last modified yeah would not be enabled yeah so i don't know if it's yeah so I don't know if it's yeah like preconditions i think that the cap like preconditions I think that the cap says that if the you know if you take it there it's treated as zero yeah it's exactly it would be zero so i don't know so I don't know i think if you added the flag we could I think if you added the flag we could actually we don't need to have a default at all we just say that a transaction is invalid if it tries to use that feature and the account doesn't have it enabled and for any account to enable the feature the new stack that's a right now you have to like constantly check that when you're engaging in a that when you're engaging in a protocol that looks like it's okay that account actually has this flag set

00:06:00.000 --> 00:06:59.999 align:start position:0%
that account actually has this flag set so I'm really i don't understand what benefit really I don't understand what benefit could possibly outweigh like i was could possibly outweigh like I was saying it's a faster implementation so you know if we if you know if no i just wanted to mention because i no I just wanted to mention because i know that was raised before and by looking at the first kind of round of by looking at the first kind of round of questions on that lee had on that prototype i mean it looks like it's a legitimate I mean it looks like it's a legitimate concern i mean so maybe can you explain a I mean so maybe can you explain a little bit better like what the complication is of having it it's around the setup i think of test it's around the setup I think of test code like a lot of times we're creating accounts we're doing all those things and i think things and I think those accounts are created without accounting entry extensions well with the yeah with the default change like that they would be created with the this extension and then when we do the so

00:07:00.000 --> 00:07:59.999 align:start position:0%
and then when we do the so basically we create like a snapshot of the ledger right and then we run a bunch of tests for and then we run a bunch of tests for different protocol versions and here the protocol version is obviously in like for older protocol versions this would be invalid an invalid ledger state so i think there's a bunch of so I think there's a bunch of refactoring that needs to be done i mean refactoring that needs to be done I mean they've been involved ledger state well an account with such an extension is not valid as of today right so i mean what happened when you so I mean what happened when you upgraded to account entry extension v2 why is this any different from the v2 v1 why is this any different from the v2 v1 to v2 beyond v2 was an opt-in right like it was only when you were using i mean from everyone to each using I mean from everyone to each other liabilities right so that's what one number sponsored and number sponsoring like sponsors yeah otherwise we didn't change it we would not and touch it clarify something here is the

00:08:00.000 --> 00:08:59.999 align:start position:0%
clarify something here is the way that the proposal is currently written i think what I'm understanding written I think what I'm understanding is that when an account is created it'll automatically have an accounting entry extension v3 at that point there's no way otherwise right and yeah so basically like the reason that this will be confusing david is that like there's like old historical tests which is a lot of the tests like many thousands possibly tens of thousands of tests were written such a way that like the setup was done in the current protocol version and then you like time travel backwards in time and do the tests in the appropriate protocol version so we'd have to go and fix that yeah so you're saying that right now if i create a new you're saying that right now if i create you're saying that right now if I create a new account i don't get an account a new account I don't get an account entry extension v2 correct you just have null extension now maybe there's an argument that we should go and fix our tests anyway yeah i mean that's why i was saying like

00:09:00.000 --> 00:09:59.999 align:start position:0%
yeah I mean that's why I was saying like it's a trade-off right like can i it's a trade-off right like can i write you like an xdr write you can I write you like an xdr converter that will automatically i mean converter that will automatically I mean it seems like we could I mean do the tests have like specific like shot 256 hash values of ledger state is that the problem well they can't though because there's other values like the other there's other values like the ledger number and stuff that aren't there so what specifically is it there so what specifically is it that fails in the test like maybe there's just like an xdr there's like some template magic invalid xdr at as of currently so if I just so if you just write a an unmarching function that will unmarshal a new account entry to an old one by stripping off the entry extensions v2 and three then we're good right all we need is that one function no not really like i mean yes you could in

00:10:00.000 --> 00:10:59.999 align:start position:0%
like I mean yes you could in principle do that but like in practice what's happening is like we have these like invariants that are written right like they check that like nothing is broken things that things only exist if they should exist in effect like no negative balances blah and in practice like you could imagine the sequence of operations is like you're in protocol version 19 let's say or 20 or whatever whenever we get this done you create an account it has account entry extension v3 you travel back in time you go and do some other operation you know you're not doing like raw xdr operations it's like literally a seller operation so let's call it like a payment it goes and does this payment it goes it loads up this thing it loads it happily because it knows how to load it it's valid xdr in the terms to load it it's valid xdr in the terms of like what the xtr is sorry but it is of like what the xtr is sorry but it is marshalled or it's unmarshalled you're loading up the bytes so you're loading you're just have a simple structure floating around you're loading up the literal bytes but like this is happening like deep inside of cell record like not in the test it's like you know in the actual production code

00:11:00.000 --> 00:11:59.999 align:start position:0%
production code then you like load this thing up it's happy because it's good you go through you do the operation everything is fine and then you hit the invariant and the invariant's like oh no you're dead because you have this thing that shouldn't have been there the right solution is just to fix the test so that they do the setup in the test so that they do the setup in the right version do you realize you guys are like massively making the case that i was making several weeks ago that like I was making several weeks ago that like we shouldn't be doing our extensions this way right because like if there's any benefit to doing this horrible cascading nested thing that's wasteful of bites wasteful of like program or keystrokes and wasteful of your right-hand margin it should be that like this backwards compatibility stuff isn't an issue but like no but david this is an issue but like no but david this is not this doesn't matter like this is invalid this is an invalid byte configuration in existing critical version that's what john just said it's a we have invariants that check that you don't have garbage in the ledger right that's garbage like from today's point of view it's garbage right it's not bad but I'm saying the extension it has

00:12:00.000 --> 00:12:59.999 align:start position:0%
but I'm saying the extension it has nothing to do with how extensions are set up right but which should i mean set up right but which should I mean shouldn't that be one of the benefits of doing these cascaded xdrs is this backwards compatibility with sources not by quad compatible that's the point like it this is garbage from today's protocol I'm just saying like this is we have to rewrite the test for this but we have to rewrite the test for this but we would also have had to rewrite the tests if we'd done it the original way that i did the extension so i don't i that I did the extension so I don't i don't see what we've won by this latest change that i've made because a lot of things have been written wrong in the first place but the production code doesn't have to change at all the production code all just works exactly the same that's the thing let's see well whatever okay so do we have to write about yourself the issue here is just tests right like the in the production code the way that it works as proposed is good it prevents there from being like a foot gun but it requires us to rewrite a bunch of tests is that to rewrite a bunch of tests is that correct

00:13:00.000 --> 00:13:59.999 align:start position:0%
correct yeah i mean like the so the reason going yeah I mean like the so the reason going back to the question i was asking right back to the question I was asking right the reason i was asking the question the reason I was asking the question was to see how bad would it be if we were making how bad would it be if we were making this a flag right that's the question yeah and david it seems like it's about yeah it would be really bad so that means we need to go fix the test i that means we need to go fix the test i mean that's kind of what you know okay cool fixing test is easy it just takes time like we just need exactly it's going to be a bit of a time sync but going to be a bit of a time sync but that's okay i mean if we're that's okay I mean if we're saying it's basically a non-starter to have a flag it takes either it takes time or it takes xdr trickery right so it may be like oh no the xdr trickery is going to be like it's going to be validation protocol that's why we can't do that so let's but let's yeah that's fine let's take it offline regardless it's test hackery right yeah so yeah i wanna just yeah so yeah I wanna just exactly one thing about like if we do if exactly one thing about like if we do if we were to introduce a flag i think it we were to introduce a flag I think it would have an impact on the usability

00:14:00.000 --> 00:14:59.999 align:start position:0%
an impact on the usability of this stuff as well because like you're saying like we would never be able to just create a transaction for an existing account that hadn't enabled the flag which means that if you have an account that's just sitting there on the network and you want to interact with it in this way and with some new with it in this way and with some new contract that maybe doesn't require interactive setup initially you can't just go and use these features of the network which is sort of inconvenient like so that doesn't won't affect the payment channel protocol that we're hoping to use this for right now but it hoping to use this for right now but it might affect some other future thing yeah and it's worse than that because we don't have spv so like there's no concise proof that an account actually has this flag so it means that the receiver side would like synchronously need to like query some trusted horizon instance in order to like participate in what should be an offline protocol so okay so flags fix the tests yeah it's bummer for the test but

00:15:00.000 --> 00:15:59.999 align:start position:0%
okay what was the second question time point this one should be a lot easier yeah the unsigned thing so my question was like i don't remember what was like I don't remember what happened there but like making that change is there is actually not a lot of like is there is actually not a lot of like the mention in the backwards compat section is actually a bit misleading it says that you know nobody cares I'm actually not true I'm not so sure i I'm pretty sure we do not so sure I I'm pretty sure we do have in historical data transactions with large max time and the other thing too is that to this and the other thing too is that to this code regardless you know core horizon sdks they have to handle those large numbers so in a way like making that change just makes everything more complicated so I'm not sure it's actually delighted to leave it unsigned i originally had it to leave it unsigned I originally had it unsigned and then i feel like unsigned and then I feel like people objected to that i mean all i

00:16:00.000 --> 00:16:59.999 align:start position:0%
people objected to that I mean all i want is like i think all our time points want is like I think all our time points should be like a type def right so it's should be like a type def right so it's like the only thing worse i mean i think the only thing worse I mean I think either signed or unsigned is fine it's just it's bad to have like a mix of the just it's bad to have like a mix of the two right like we should just be consistent about sign and unsign because when you start comparing signed and unsigned numbers as we all know like you know bad things start happening so we already have now we already have a mix claymore balances you signed time down to use unsigned i mean we're there so I mean we're there so oh yeah okay so i guess so I guess out of luck on this one so i mean i so i really don't care i so I mean I so I really don't care i just want to be the same as other things just want to be the same as other things so i guess i'll keep it unsigned and you so I guess i'll keep it unsigned and you know we can add we can regular transactions that's kind of the concern i have here is that it changes concern I have here is that it changes regular transactions

00:17:00.000 --> 00:17:59.999 align:start position:0%
so i'll make it unsigned again what make time point unsigned and we'll deprecate signed time points in future operations another option would be to make the time point inside the new precondition version 2 signed since that's a new field nobody's going to be that's a new field nobody's going to be using that yet we keep the old time point as unselling for backwards compatibility i know it seems I know it seems not worth it to me but yeah let's keep it unsigned okay sounds good all right so time points remain unsigned where we got next one is around the section on how transactions get

00:18:00.000 --> 00:18:59.999 align:start position:0%
section on how transactions get forwarded so basically says that they are like those two criterias a and b that allows a node to decide if it's going to allows a node to decide if it's going to accumulate basically this transaction in its queues its in its queues and yeah so like the first question is that so yeah so I think that the criteria b talks about lower signals it's actually not clear it's it seems to imply that you are actually allowing transactions to be accumulated if we receive them out of order and i think receive them out of order and I think this is probably not the intent that's the first question oh so in other words i say don't forward

00:19:00.000 --> 00:19:59.999 align:start position:0%
oh so in other words I say don't forward it but you should it should be stronger than that it should be just like throw it away like should yeah like it should not be better that's a good point right e is actually it should be it shouldn't have this lower sequence number i think on the does that make sense wait what do you mean there shouldn't be no you like right now you're saying it's invalid if either you know the condition is not met so this is those are easy right the b is what I'm interested in like right now it says it's invalid if there is already a transaction with a lower signal sorry it's invalid no it is valid that's what your text says is the polarity a transaction with a non-zero min ck german sequential atmosphere is invalid enough forwarded if either a the appropriate condition doesn't hold

00:20:00.000 --> 00:20:59.999 align:start position:0%
doesn't hold or b there are pending valid transactions with lower sequence numbers on the same source account okay so wait so what's and you're saying b i should so what's and you're saying b I should say and in case b should also throw it say and in case b should also throw it away instead of storing it in memory well it's in valid right so we are throwing it away my the question it's not no it's not invalid it's not no it's not invalid in a it's in validity it's valid but they're things with a lower sequence number so let me give you an example just to make sure we're on the same page right so you have a transaction with sequence number two but that could execute immediately because it has a because it has like a min seek noun that's less than the default and you have a transaction with sequence number one right so you could just execute two in isolation or you could execute one but you can't execute them both in

00:21:00.000 --> 00:21:59.999 align:start position:0%
one but you can't execute them both in the same ledger no that understands yes like but here so if you receive so in your example i have two right so in your example I have two right and i have two and that and then i and I have two and that and then i receive one what happens then one takes priority like you okay so this then it makes so then this is kind of broken right it's actually under specified first of all it's why is it underspecified well you're actually not saying that you're talking about i guess it so yeah you're saying you're kicking out highest transactions with higher signal that's right like you'll still vote for a block you know you'll still nominate a block that has it but is that a good

00:22:00.000 --> 00:22:59.999 align:start position:0%
block that has it but is that a good property i mean it sounds kind of weird property I mean it sounds kind of weird we already have this it's exactly we already have this exact situation no we don't kick out transactions like this okay let me tell you a situation okay let me tell you a situation i believe is exactly analogous which is I believe is exactly analogous which is that you receive a transaction with you know a fee of 100 and then you receive another transaction the same sequence number that has like a fee of 200 right and so now if you've fee of 200 right and so now if you've already of course forwarded the 100 well you forwarded it fine but now you'll forward the 200 and if you see both you'll only forward the one with the higher fee and so that's the same and so that's the same way we're basically like among multiple mutually exclusive but valid transactions you need a way to prioritize them and I'm saying here you prioritize the one with the lower sequence number now why do you need this question

00:23:00.000 --> 00:23:59.999 align:start position:0%
oh because the second one might could later be valid right you're not yeah unlike the case of the sequence numbers you're not numbers you're not necessarily completely invalidating the second transaction you're just it will have to execute like a you know an hour have to execute like a you know an hour later or whatever the you know whatever the min seek age is so or men whatever the yeah so you know you might as well like keep them the most number of transactions valid i mean if you're if transactions valid I mean if you're if you are strongly opposed to this we could i guess doesn't really matter we could I guess doesn't really matter we could favor the other one but i don't we could favor the other one but I don't i don't see i mean i like it sounds like I don't see I mean I like it sounds like kind of arbitrary so that's why I'm asking like why the first one shouldn't win in this case in some ways it might be more useful if in some ways it might be more useful if the second one is yeah because we often say that sequence say that we often say that sequence numbers is how you invalidate prior transactions

00:24:00.000 --> 00:24:59.999 align:start position:0%
transactions so it sounds like if we say that the first one wins then you could never use a higher sequence number transaction with a min sequence number it was lower to invalidate a prior transaction but someone could always well they might not be able to submit it because they might not it might have a might they might not it might have a timeout it might have a min I'm in time right which is generally how this works so like you know the reason I did this so like you know the reason I did this is because like you know it seems more useful to have like two if you have two transactions then they can both execute it seems helpful to have it be such that both can helpful to have it be such that both can execute and you know if you accidentally release if you accidentally send out the second transaction too soon like you know I don't strongly care if you want it the other way around i can do it around it other way around I can do it around it has some implication right from a dos money because you can basically like

00:25:00.000 --> 00:25:59.999 align:start position:0%
money because you can basically like if you have this rule right well you don't say first win first one wins you basically can so with the example this will collect more fees right the current draft will collect fees on both transactions no you're dropping transfer you know let me finish so with the example you give you said it's the same thing when the fee with the fee you same thing when the fee with the fee you have to actually outbid right so you have to constantly like if you want to cancel a pending transaction you have to update it right with this one you don't have to update it can be the same fee no you are you said the that transaction that was in the transaction queue gets discarded because i have a lower sequencing number because I have a lower sequencing number I'm not currently discarding it i thought that's what you were suggesting currently you're just not forwarding it so just to be clear david what you're suggesting is like imagine that i have

00:26:00.000 --> 00:26:59.999 align:start position:0%
suggesting is like imagine that I have seen like currency numbers 10 i submit a seen like currency numbers 10 I submit a transaction with minstic 10 actual seek 12 and then i later receive and then I later receive seek 11. europe your approach that what you what we think is in the cap and i've been we think is in the cap and i've been rereading it like five times here while everybody's been talking to make sure i think that's what actually it says is that you would actually keep both in that case because yes because you don't know like you could see a block that has either one it's the same way like if you either one it's the same way like if you see i mean i really i think it's very I mean I really I think it's very similar to the to the multiple similar to the multiple prices to the multiple fees right whereas like you know you see you saw the fee of 100 then you see this you saw the fee of 100 then you see this fee of 200 so you forward that as well fee of 200 so you forward that as well and you know you still need to kind of and you know you still need to kind of keep the fee of 100 around because it could be that the block that gets nominated has that so you don't want to like if you see a hash of that transaction you still will need to like you know get the pre-image of it right we actually don't have that transaction

00:27:00.000 --> 00:27:59.999 align:start position:0%
we actually don't have that transaction so you might actually have to then go fetch it from another Stellar core potentially but the other thing we can do the other thing though is that with the fees back off exponentially the fees back off exponentially that's a big difference against this and i think that's what nico was saying I think that's what nico was saying like i think i forget what multiplier we like I think I forget what multiplier we use i forgot if we ended up using two or use I forgot if we ended up using two or ten we debated about it for a long time ten we debated about it for a long time but either way it's like you can only do but either way it's like you can only do this 64 times with fees or maybe it's 10 times or 20 with fees or maybe it's 10 times or 20 times with the like the scenario that i've been trying to think about while i was rereading to think about while I was rereading your thing repeatedly is like what if i have two transactions what if I have two transactions and they can't both execute because of fees i don't have enough balance to pay fees I don't have enough balance to pay both fees but so like going back to my scenario you're at 10 you have minty 10 seek 12 you're at 10 you have minty 10 seek 12 then you receive 11. the fees be the fees make the two transactions mutually exclusive which one do i take which one do I take because then i do end up throwing out

00:28:00.000 --> 00:28:59.999 align:start position:0%
because then I do end up throwing out the future one if i take the other one if I take the other one and how do you implement this and what's the right thing to do like it's not obvious in that case if the fees make it mutually exclusive so like the implementation is actually harder in that case well so hold on this seems no different from today so suppose forget you know the min seek num right suppose that i put out transactions you know with I put out transactions you know with sequence numbers 11 and 12. like right now they'll both be forwarded but what if there's not enough fee for 12 well then you would throw that out i guess right but i wouldn't accepted 12 because you kind of so you're in the so for pending transactions you're sort of keeping track of the cumulative fee that's been charged i'd have to go and check how we do this for fee bumps i don't remember if we reject I don't remember if we reject the fee bump if you wouldn't have the

00:29:00.000 --> 00:29:59.999 align:start position:0%
the fee bump if you wouldn't have the fee to pay for all the subsequent transactions or if we yeah it's the same thing we have to basically you have to whatever is in the queue you have to be able to is in the queue you have to be able to pay for the feeds that are you sure that's what we implemented I'm not positive okay oh no it's yeah I'm sure yeah so then that would make this that yeah so then that would make this a little bit trickier david where it's like then you have to handle the case like oh like i have to handle the case like oh like I have this earlier transaction but i don't this earlier transaction but I don't have a fee for it we should make it have a fee for it we should make it symmetric against the female case i guess the female case I guess so wait so you're saying that the feedback the outer transaction doesn't have enough to pay or sorry what's your yeah the outer like oh it doesn't really matter like it like i both i have both a I both I have both a normal transaction and a fee bump transaction that I'm paying for

00:30:00.000 --> 00:30:59.999 align:start position:0%
transaction that I'm paying for on a different account you're saying and now you have to like prioritize one or the other does it even have to be on a different account i think it could even different account I think it could even work on the same account on different accounts it definitely works like this if you don't have the balance on this the other account then we'll just reject you know but there's different sequence numbers so i can issue like fee bumps on like three different transactions on three different source accounts right and if i can only pay for two out of those if I can only pay for two out of those three then like different validators are gonna forward potentially like different subsets of these three transactions right so this seems like a very similar situation so i don't know why no it's situation so I don't know why no it's not it is similar if you that's what I was teasing out right like what you described right like what you described in the so imagine your mean is like one you know it's like whatever it doesn't matter basically it's set but it's one and now you're at yeah like the six you get first transaction the six you get first transaction sequence number ten

00:31:00.000 --> 00:31:59.999 align:start position:0%
sequence number ten then you get the second transaction sequence number eleven that's what you actually described here you're dealing with that case that is 11 in this case with that case that is 11 in this case you will consider it invalid because for now right because you have 10 and you can't process it in the same block so you just in this case you just discard 11 everything is good 11 basically can be resubmitted later all right now consider the this in the other direction I'm receiving 11 and right now you're saying that 10 is valid so if 10 is valid i need to discard 11. so if 10 is valid I need to discard 11. that's the difference here is that you're discarding things from the queue so you basically can have a situation where now take this to you know a thousand I'm now take this to you know a thousand I'm going to flood t 1000 then and I'm going to basically submit to the network nine you know like one less every time and those are all going to get forwarded they're all getting flooded and at the end only one gets actually in and at the end only one gets actually in the queue which is the smaller one

00:32:00.000 --> 00:32:59.999 align:start position:0%
the queue which is the smaller one so i use all this capacity on the so I use all this capacity on the overlay right with no repercussion keywords okay so you so and this would be fixed if we picked the highest sequence number if we pick no you don't need you so highest has the same problem right it's what you want to do is the first one wins i think independent of the sequence number the first string don't care basically you don't care like if there is the first one that's in the queue then if the second one arrives it says oh there is already something with a condition like that yeah so the like we can totally do that the downside now is that you're more likely to get conflicting nominations if there's more than one leader yeah but that's fine it's

00:33:00.000 --> 00:33:59.999 align:start position:0%
yeah but that's fine it's actually better from a flooding point of view the network is going to be much more resilient at this point and it's just yeah sorry and is this what happens with female is this what happens with female transactions like in my example of because we should just be consistent so in my example where i create three bumps any two of the I create three bumps any two of the three are okay and i basically flood three are okay and I basically flood different pairs of them to different validators they'll each forward like the first two that they got i mean it's the first two that they got I mean it's the same with p bunk it's the same if you same with p bunk it's the same if you have like you know if i submit two have like you know if I submit two transactions with the same fee and same signal right they're basically competing on the overlay and the second one is always like a bad check right like you always say and then just you just have to fetch it from then just you just have to fetch it from the denominator it's not that you fetch it it's like whoever submitted that thing will have to resubmit it to the network but what's going to happen is someone's going to nominate a block and like a bunch of validators are going to be missing like one of the transactions in that blocks and then they'll just all

00:34:00.000 --> 00:34:59.999 align:start position:0%
that blocks and then they'll just all like have to make sure the validators that had the other the this other transaction in their queue right when the block is going to close they are going to discard the transaction because it's actually at this point invalid at this point in time it's going to be likely invalid and like depending on the condition right on your like if you say for example all that the i need the transaction to be I need the transaction to be submitted you know like five ledgers from now well obviously it's invalid right now right and one thing you know i guess right and one thing you know I guess my question is kind of independent of this particular example right we have this ability to actually create fee bump transactions and kind of spray out a bunch of mutually conflicting fee bump transactions the result is that whatever block gets nominated is likely going to be missing it's good looking to have transactions that most of the validators don't have

00:35:00.000 --> 00:35:59.999 align:start position:0%
don't have and so of course they'll just fetch the pre-image of that transaction hash but that of course has overhead on its own but you're saying like that's not how it was kind of okay oh yeah like transaction sets are flooded independently of transactions today right of transactions today right so basically like you end up nominating a transaction set i see the pre i see a transaction set I see the pre I see the hash of that transaction set in the nomination message and i turn around and I'm like i don't and I turn around and I'm like I don't know what that transaction set is and then i have downloaded all the then I have downloaded all the transactions anyway sorry so you download all the transactions anyway even if you already have most of them that's right nico i mean you're more active yeah I'm pretty sure that's right okay yeah that's the way to do it right now okay that's the way to do it right now okay well then that's easy so i think the well then that's easy so I think the simple change is you don't prioritize one way it's just you don't prioritize one way it's just first come first serve for forwarding yeah right i think that's good I think that's good cool yeah actually that's that was what i was asking with my question number three in the in that section

00:36:00.000 --> 00:36:59.999 align:start position:0%
in the in that section yeah which is so there's like a in the second question inside this you know section on transaction forwarding and ordering there was this i was asking basically I was asking basically if we should do something about like bad properties basically so we have like with the current proposal right that we have for the payment channel it's actually using separate transactions for di and ci is basically like on like one is the one that is allowing you to move the to move the sequence number and the other one allows you to or uses the delay right if you were going to create a smart contract where you're putting

00:37:00.000 --> 00:37:59.999 align:start position:0%
putting the condition and the jump in one transaction you're going to have like those kind of delay attacks right you can delay those contracts pretty badly so the question i had was so the question I had was should we just not allow people we can always by the way like leave that constraint later but like for now like if you make it that you can't have a mean condition combined with yeah like minsektom I mean yeah you can't combine those the two mean second mean age basically sorry like you can't jump you can't combine in the same transaction the jump and the age restriction

00:38:00.000 --> 00:38:59.999 align:start position:0%
what would that i think i did we're in the two-way I think I did we're in the two-way payment channel or so imagine yeah right now so the cur the prop the protocol for payment channel doesn't have this problem because the two transactions ci and the i they actually have very and the I they actually have very different purpose right and one allows you to jump in the sequence numbers and the other allows you to delay you know to grab like those grace periods yeah imagine if yeah but imagine if you try to do like a yeah but imagine if you try to do like a and i know we're actually looking at and I know we're actually looking at that at some point where it was actually the same transaction has allows you to jump and has the condition right the on the delay right if you have I'm not sure i understand so you're I'm not sure I understand so you're saying that you would make it so that people couldn't use nin sikh num and men see gauge in the same transaction in the same transaction in order to because if you imagine like imagine that pidi somehow could be

00:39:00.000 --> 00:39:59.999 align:start position:0%
imagine that pidi somehow could be combined yeah which is what this is talking about like imagine you have a contract for your lrc in the ai to be combined right at that point i don't know what that at that point I don't know what that means because di is like declares that you're going to do something and then ci actually does it yeah but the way you could do it right yeah but the way you could do it right you could imagine having a cidi combined yeah on the same sequence number yep you have one that is just the jump yep you have one that is just the jump and then you have another one that oh i don't know like it's a different oh I don't know like it's a different protocol right like I'm not talking about the existing payment channel I'm is where you have like okay you still have d you have like okay you still have d and so you declare something and then you have this thing that could happen in the future but then in the middle maybe you have optional transactions that can be submitted like maybe

00:40:00.000 --> 00:40:59.999 align:start position:0%
like maybe that would be a use case for that like that would be a use case for that like that last transaction you want it to be submittable without a specific sequence number of the account so maybe you want like 10 sequence numbers in between and there are some other transactions that can be submitted before that I don't know how you why that's not i don't think that's what I'm describing I don't think that's what I'm describing a transactions where you have both the open range right on sequence number and the delay and the delay yeah so that's what I'm yeah so that's what I'm describing so you have that open range so you can submit optional transactions between d and c the c still has both it needs to have the min sequence num so that it can be the min sequence num so that it can be submitted whether those optional transactions be submitted or not but they will have the delay said yeah i see yeah you could do that said yeah I see yeah you could do that basically like you jump and then you

00:41:00.000 --> 00:41:59.999 align:start position:0%
basically like you jump and then you have like and you need to wait for a little bit to and you need to wait for a little bit to do those other transactions but they are not going to be and if they don't happen closing your final transaction can still be submitted after the delay yeah so my point here was that if you actually allow people to craft such transactions those transactions can be attacked because you can like the assumption with those things is that you can always like you know I because I have the more recent version of that transaction i can recent version of that transaction I can always submit it in a way but here it's not the case anymore and i but here it's not the case anymore and i have because i can submit those state have because I can submit those state ones in the contract right and now you can basically like if s like the grace guys or whatever is like fairly big like as in you know like

00:42:00.000 --> 00:42:59.999 align:start position:0%
like fairly big like as in you know like media more than a few minutes and you have a lot of transactions that you're exchanging offline you can basically submit all of them all the ones that were until you expire until you actually expire the window certainly I'm confused can you like imagine that I clarify something is this is this is your objection that this is like too restrictive that there's transactions that you want that you can't that are illegal or it's the other way around that there's transactions okay all right so what specifically is the transaction that is bad it's so the transaction itself is not so it's not that you have bad is not so it's not that you have bad transactions that they are you have like in a payment channel kind of situation right you exchange a lot of those things offline that's why you need

00:43:00.000 --> 00:43:59.999 align:start position:0%
why you need to be able to jump forward right so that you have the latest transaction being processed and what I'm saying here is that i think that I think that is if you were designing a smart contract that was combining the two constructs it's actually a foot gun like it's slightly wrong which two it's like it's slightly wrong which two constructs are we talking about the delay and jump is the reason why you're saying this is a foot gun like I'm trying to understand just like david is as well like imagine that you have like a the gap is like from sequence number 10 to 20 just to be super concrete so you've got 11 slots let's make it 10 to 19 so got 11 slots let's make it 10 to 19 so you've got 10 slots and then like the delay is one day like the min seek age is one day the min seek age is one day what you're i think what nico's saying what you're I think what nico's saying but i could be wrong but I could be wrong is that you actually might incur a

00:44:00.000 --> 00:44:59.999 align:start position:0%
is that you actually might incur a 10-day delay because somebody could play in each of the slots and then you go into each of the slots and then you go into the last one is that what you're saying nico or is that not i mean yeah like for the delay that not I mean yeah like for the delay ones that's exactly what will happen yet also the other way around where you expect like the you say oh this is only expect like the you say oh this is only valid for the next five minutes right and now you can basically cause the thing to expire by replaying older ones like it's actually those would not be sorry those would be like ones with conditions that are going to be absolute I mean yes of course if you i can give you a yes of course if you I can give you a protocol where when i throw in time protocol where when I throw in time bounds or ledger bounds like it doesn't work because those bounds aren't there but like to say that that's a foot gun it's like to say that that's a foot gun it's like well just don't use that feature if you don't need it and it won't get in your don't need it and it won't get in your way right i just don't see it what I'm saying is

00:45:00.000 --> 00:45:59.999 align:start position:0%
I just don't see it what I'm saying is that i don't see right now a use case that I don't see right now a use case where you would put both i can only think of bad I can only think of bad things so you can put both so the argument is understandable you're saying like we should we have a tx conditions v2 and the tx conditions v3 or something no it doesn't need to be v1 d2 it's more like a tx conditions like relative delay and a tx conditions like jump sequence gap or something like should there be like two flavors of precondition that are mutually exclusive and that have subsets of these things rather than throwing them all into one tx giant tx conditions v2 one tx giant tx conditions v2 i mean like yeah i don't think I mean like yeah I don't think it's yeah maybe annoying i don't hate it's yeah maybe annoying I don't hate that if that's necessary to go that if that's necessary to go in I don't see it I guess I'm not yeah I'm not maybe explaining very well like the

00:46:00.000 --> 00:46:59.999 align:start position:0%
like the like i know that we were when we were like I know that we were when we were looking earlier at this protocol some transactions had actually those two things you know set and if you're not careful yeah like you did you end up with a bad like basically did you end up with a bad like basically a broken contract a broken contract and you know it's part of like you know and you know it's part of like you know kind of giving the ecosystem like you know the least number of things that they can trip on those present transactions i don't object to that if we want two I don't object to that if we want two flavors of tx conditions i can do that i can see you know there's I can do that I can see you know there's some benefit in terms of like transactions take fewer bytes when serialized there's some additional complexity then now you have to like you know check the union can we keep it as one structure and then can we keep it as one structure and then just have core not allow those two things fields to be set at the same time i was going to ask set at the same time I was going to ask the same question like

00:47:00.000 --> 00:47:59.999 align:start position:0%
I mean that seems like the worst of all worlds because now we're adding like additional constraints that aren't expressed in xdr so like reading the xdr is not enough to know like you can make is not enough to know like you can make transactions that look valid because xdr is valid but they violate some rules so that i don't like that I don't like plus you don't get the benefit of the more compact transactions so i would suggest either keeping it so I would suggest either keeping it this way or having two different kinds of tx conditions i think can we maybe take this on I think can we maybe take this on offline like I'm yeah i feel like offline like I'm yeah I feel like crosstalk syntax at this point right but it's clear there are two choices and there is like a design decision involved right one is like split it in two in right one is like split it in two in order to protect users more and two is keep it simpler even though we are potentially leaving something in there that although we could use an error actually i do have a actually I do have a potential a use for this

00:48:00.000 --> 00:48:59.999 align:start position:0%
well maybe this is not a very good one but like but like you could worry about someone submitting a bunch of these transactions and like draining the fees from the account or something and so maybe you want to make sure that you know the other person is only doing so many but that's kind of bogus also because you could always just use a fee bump transaction to get the one that you want to execute through so all right well again I'm pretty agnostic on this so it's a binary choice and it's pretty clear what it is so i think moving it clear what it is so I think moving it offline and just trying to find a way to offline and just trying to find a way to just ultimately choose one or the other that makes sense okay the only other thing i'd add to this it's like we should probably convince ourselves that like it actually is always a bad idea to like it actually is always a bad idea to do this it probably is nico I think niko's point sounds right but like i don't think sounds right but like I don't think any of the rest of us had actually considered that question so we should probably take at least a few minutes offline to think about that yeah okay

00:49:00.000 --> 00:49:59.999 align:start position:0%
offline to think about that yeah okay what else we got here we got six minutes now more questions I'm sorry I took over the meeting i think this is great because we're I think this is great because we're getting through these questions concrete action items all right so the next things are around transaction validation so yeah so those are like things that i think this is there's a section that talks about like I think dual validation right in the dark that basically what happens basically during nomination basically and then what happens later right when you actually apply i think this is what this is apply I think this is what this is really about so there's a thing that says all but the transaction with the lowest signum on a given source account might have

00:50:00.000 --> 00:50:59.999 align:start position:0%
on a given source account might have zero for the mean sec age and mean sec zero for the mean sec age and mean sec ledger fields all right we're nominated block of transactions right asking is like should we simplify this to just be something more like the rule that we just discussed for the rule that we just discussed for flooding transactions and basically the rule is if you have a mean sec the rule is if you have a mean sec you know thing condition on the on you know thing condition on the transaction you can never mix it with any other transaction in the same for the same source icon like instead of having this weird like you know the lowest i don't understand what we gain by I don't understand what we gain by having this extra kind of you know

00:51:00.000 --> 00:51:59.999 align:start position:0%
having this extra kind of you know like basically special cases where you can put two transactions yeah i mean yeah I mean you often might want to do that like you want to bump a sequence number and then execute a bunch of things at that sequence number that are valid but are you talking about yeah but like it sounds like it's complicated things for no real good reason I agree with the fact that it's an implementation detail like we could not this one is actually part of the this one is part of the this one is part of the protocol that's why this one is actually very important because yeah so the question said valid so yeah so the question is like do you do yeah so the question is like do you have like you know could you have like sort of various sequences of transactions that you can execute with you know so after some

00:52:00.000 --> 00:52:59.999 align:start position:0%
so after some delay right and one reason you might want to do this is suppose for some reason you don't want to use claimable balances or you're worried about something failing right you'd want to break a set of operations up into several different transactions in case like one of them fails so the sequence number's consumed and you can execute the other ones right and so then if these if this ones right and so then if these if this kind of series of things you want to do kind of series of things you want to do has some relative delay then what you do is like the first in the sequence would have like a min seek age and then the others you would just kind of like not because you can only execute them with the right sequence numbers so to me this seems like something you'd want to do it doesn't seem like a particularly hard thing to implement i mean you're already checking that all the sequence numbers are consecutive or that they have mint numbers that make sense so just to sort of say that like other than just to sort of say that like other than the first one the min cage also has to the first one the min cage also has to be zero it doesn't seem like a big deal be zero it doesn't seem like a big deal but

00:53:00.000 --> 00:53:59.999 align:start position:0%
but i mean small conditions right sorry i don't i was definitely useful right so the I was definitely useful right so the only reason to remove it would be if it's like really hard to implement right it's going to you have to also do that in overlay right in the queues like for all the queues that are being managed well they all are going to have you have to solve them yeah they have to you have to solve them yeah they have to be sorted and yeah like yeah but we already have to do that because we have to make sure because we have to make sure number one it's more like now you have like certain conditions between depending on the order right press you know if you think of I think what we are talking about earlier is that okay if there's any transaction in the queue you know i don't i can't add the you know I don't I can't add the condition for example if i can condition for example if I can i can't add that transaction sorry

00:54:00.000 --> 00:54:59.999 align:start position:0%
right but that's why we already talked about that we're gonna oh sorry what I'm not particularly offended by what you have david just to provide a counterpoint to nico like i think there could be merit to I think there could be merit to pipelining and i don't think pipelining and I don't think like i don't think compared to the like I don't think compared to the already very large amount of condition checking that we do in especially in the transaction queue i don't think this transaction queue I don't think this would be a very material change that's my opinion if we think that this kind of pipelining situation is like not only possible but plausible and i think it probably is plausible and I think it probably is i don't think it's that bad personally at this point we're also out of time so okay are you okay with that nico okay so okay are you okay with that nico or do you still you're still not convinced no i say it's probably fine convinced no I say it's probably fine yeah it's just more conditions like i said more conditions like I said okay this one i do think it's useful so

00:55:00.000 --> 00:55:59.999 align:start position:0%
okay cool so leave this one as is because it's useful and possible unless you know obviously i think that unless you know obviously I think that perhaps what happens now is that we move this back to the mailing list there are a few action items for you david to make a few action items for you david to make changes to and a few things we still need to discuss async but they're pretty simple straightforward decisions to make and then that also gives anyone time if you know nico if you think about this last point and decide that actually the utility may not warrant the actual work or something you know there's time to sort of bring it up but it feels like sort of bring it up but it feels like these are fairly discreet changes and action items that can actually get this thing in a position where we can evaluate a draft possibly with an eye towards acceptance very soon does that seem true yeah all right well awesome everybody thanks again for being here thanks everyone at home for watching and i'll see you all soon

00:56:00.000 --> 00:56:59.999 align:start position:0%
